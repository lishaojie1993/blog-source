{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/melody/source/melody-favicon.ico","path":"melody-favicon.ico","modified":1,"renderable":1},{"_id":"themes/melody/source/baidu_verify_9HYrO8fACI.html","path":"baidu_verify_9HYrO8fACI.html","modified":1,"renderable":1},{"_id":"themes/melody/source/js/hexo-theme-melody.js","path":"js/hexo-theme-melody.js","modified":1,"renderable":1},{"_id":"themes/melody/source/css/404.styl","path":"css/404.styl","modified":1,"renderable":1},{"_id":"themes/melody/source/js/copy.js","path":"js/copy.js","modified":1,"renderable":1},{"_id":"themes/melody/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/melody/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/melody/source/js/fancybox.js","path":"js/fancybox.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/fireworks.js","path":"js/fireworks.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/head.js","path":"js/head.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/katex.js","path":"js/katex.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/scroll.js","path":"js/scroll.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/sidebar.js","path":"js/sidebar.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/transition.js","path":"js/transition.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/melody/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/canvas-ribbon.js","path":"js/third-party/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/anime.min.js","path":"js/third-party/anime.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","path":"js/third-party/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/velocity.min.js","path":"js/third-party/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","path":"js/third-party/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/jquery.min.js","path":"js/third-party/jquery.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","path":"js/third-party/reveal/markdown.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","path":"js/third-party/reveal/head.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","path":"js/third-party/reveal/marked.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","path":"js/third-party/reveal/math.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","path":"js/third-party/reveal/notes.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","path":"js/third-party/reveal/zoom.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","path":"js/third-party/reveal/reveal.min.js","modified":1,"renderable":1},{"_id":"themes/melody/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","path":"js/third-party/reveal/highlight.min.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"b947e07c64fd840e01011443cebf20d3673a7d44","modified":1581924605307},{"_id":"source/CNAME","hash":"a13b825bb875171c6f4243505bdee63819efbc9d","modified":1578720344311},{"_id":"themes/melody/.eslintignore","hash":"55f36fe3be2270ae2746eddbb2982e4e1472bc31","modified":1578319060076},{"_id":"themes/melody/.gitignore","hash":"7ed73f0edfb682b12a42070fd2730d5d712ec2fa","modified":1578319060077},{"_id":"themes/melody/.eslintrc","hash":"cfcd1b454efdd6cc1a0d43be7bc79027b84531f7","modified":1578319060076},{"_id":"themes/melody/.travis.demo.yml","hash":"4482d40a58a035ef96888dfc4ed96c861b8f78a5","modified":1578319060077},{"_id":"themes/melody/FAQ.md","hash":"5984dd5335f8ead64f14d3885de5cc5ef09dfff8","modified":1578319060077},{"_id":"themes/melody/_config.yml","hash":"3d938200a11e8b87a7ee7fc30ccbce873c3b1a89","modified":1579232464422},{"_id":"themes/melody/.DS_Store","hash":"00eefb040f3bc7efbe671729bd140b506d6fa85a","modified":1579182712967},{"_id":"themes/melody/package.json","hash":"222a9e63733787e4ff05c6027a748f93b4c232c2","modified":1578319060086},{"_id":"themes/melody/LICENSE","hash":"dbbc2e6e42affa5ac962826f01bffa8c7aecd6b8","modified":1578319060077},{"_id":"themes/melody/README.md","hash":"dce38795877740f8acd4a56379fbc3d7cf26ab14","modified":1578319060078},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1580634562709},{"_id":"source/_posts/BTree.md","hash":"a0ffe3c98204a797f5907d1196f58a3c33e17cf8","modified":1579237693807},{"_id":"source/_posts/ConcurrentHashMap.md","hash":"fa2af5ada5e8f6cf726c076d12f2629a53dda7fe","modified":1579237774028},{"_id":"source/_posts/HashMap.md","hash":"73173ae1552bc42fa8500e7277c16f54751d27b6","modified":1579237653645},{"_id":"source/_posts/LinkedList-Reverse.md","hash":"4b19988f1b9fbcba03791d0f7b0c5f657775e530","modified":1579240778274},{"_id":"source/_posts/MD5.md","hash":"766129deb464d4d24f408fcc519bdb3044b0078b","modified":1579256137083},{"_id":"source/_posts/AES.md","hash":"9932eaf5844b69f89b8613608dae641eb0813047","modified":1579254564465},{"_id":"source/_posts/MQ.md","hash":"cbac1810815b820547b7827809db9d8b9a4fd2b6","modified":1581698022630},{"_id":"themes/melody/stylus_format.json","hash":"2fbe63b06901d202773457d7ce658ab6aa85d02b","modified":1578319060102},{"_id":"source/_posts/Sort.md","hash":"9eead49ab13e4e9b82b9b41d6fb1ebb6bae0d0ca","modified":1579237617432},{"_id":"source/_posts/Tampermonkey.md","hash":"4bc83c61e60ad6140dd105c69190885e3311b98f","modified":1578819800662},{"_id":"source/_posts/Sub-table.md","hash":"11b04f01c51661cb947cf1bc0d41260026513980","modified":1581655260866},{"_id":"source/_posts/Thread-Pool.md","hash":"e29e797c0aad311db34982111f945ffcad7cd2d9","modified":1579608451944},{"_id":"source/_posts/encryption.md","hash":"172c6ef937ee6b58727207d01f3acfcec86a4869","modified":1579244701844},{"_id":"source/_posts/factory.md","hash":"b88f79c927e67e34f06730392b963b52950977c4","modified":1579237826082},{"_id":"source/_posts/git.md","hash":"b3dd74fd9921b02188d1c944958871e9a286e0a8","modified":1579068227938},{"_id":"source/_posts/firewall.md","hash":"61a37f86a2680d577d6e28a5fd079fa05d02cce9","modified":1581926214817},{"_id":"source/_posts/macappfree.md","hash":"5e41a77e15e0e221b6baf2803a3a646a996a1046","modified":1578882621524},{"_id":"source/_posts/ghelper.md","hash":"2dab1f9c1e1e540e6500162ba779a50af7539dc9","modified":1578820018908},{"_id":"source/_posts/hello-world.md","hash":"384dff59b58151b9a413ad64077bf5d7b0be646e","modified":1578720344317},{"_id":"source/_posts/maven.md","hash":"67ea297f591ad6b5a780eaa34437e609ef354882","modified":1579068210082},{"_id":"source/_posts/macapp.md","hash":"59941f1965d25f36c498df93046a02ddfc335881","modified":1578887172658},{"_id":"source/_posts/mybatis.md","hash":"a32c4fc8bcb50c9e3b97a59dbe80058d21f1dd22","modified":1580635628319},{"_id":"source/_posts/singleton.md","hash":"d5614d6f4ea9389d0561beb24078d10cb1752e98","modified":1579237855059},{"_id":"source/_posts/win-activation.md","hash":"5ad8f18e85699ff12e23f9a92b069b20b7d2dc65","modified":1578963301456},{"_id":"source/_posts/nginx.md","hash":"0bfbf53572e38184f7fc4cb82bf7767ee60a01c4","modified":1579181195851},{"_id":"source/_posts/redis.md","hash":"deb3abf48a163905a99e9028cea0649380d58e47","modified":1581697117938},{"_id":"source/_posts/volatile.md","hash":"ad13f5a2a392dc7279ccadc5d6f974cc644b3351","modified":1579188115599},{"_id":"source/categories/index.md","hash":"3e66f26aab3f16438e1d185c9584b0ad2522a38a","modified":1578720344324},{"_id":"source/_posts/zookeeper.md","hash":"52c456bbe17a579077ab5b1f1df876c2a0ac124d","modified":1578883596432},{"_id":"source/tags/index.md","hash":"5e98cbcc0d479086ae9d033c03e597155b0c094a","modified":1578720344325},{"_id":"themes/melody/scripts/hexo-plugins.txt","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578319060086},{"_id":"source/_posts/article.md","hash":"43165fe530c34f0e7b7476b24652e125f06212f2","modified":1578720344313},{"_id":"themes/melody/.github/ISSUE_TEMPLATE.md","hash":"66c3f31c24530922420b92f5fd827f69197ee0e2","modified":1578319060076},{"_id":"themes/melody/.vscode/launch.json","hash":"3098e8e395a33fa130747d2fd104a21278f266a6","modified":1578319060077},{"_id":"themes/melody/.vscode/settings.json","hash":"fe06aa97b88db812231f3f1d1befe4b9b95604ea","modified":1578319060077},{"_id":"themes/melody/layout/archive.pug","hash":"2133e9f369dac19b9f843fc956521f864ace7567","modified":1578319060079},{"_id":"themes/melody/layout/category.pug","hash":"ea5f82d69e586f293f428f3b237c17bf873b4f03","modified":1578319060079},{"_id":"themes/melody/layout/404.pug","hash":"0ad5d251ba70edad5c04a45d13ca6a8db3bf7b42","modified":1578319060079},{"_id":"themes/melody/layout/index.pug","hash":"5e969c09fa5902829ad0b14c0af8d432bd4c7078","modified":1578319060086},{"_id":"themes/melody/layout/.DS_Store","hash":"ae37dd218934adbe6720c8655597f47bcf295e5a","modified":1578555443867},{"_id":"themes/melody/layout/gallery.pug","hash":"c083a7bbf5f46305daed74632aef3403b7d94dc7","modified":1578319060079},{"_id":"themes/melody/layout/post.pug","hash":"949550f3b7195124b2ca5f34e3bdab6fd08de0d4","modified":1578554584194},{"_id":"themes/melody/scripts/gallery-tag.js","hash":"74e2e95f8daec619578f4b7dd1ed77cd5907f37e","modified":1578319060086},{"_id":"themes/melody/scripts/replace-config.js","hash":"7476015a4e091203c3048c5377ec5d67439520fa","modified":1578319060086},{"_id":"themes/melody/layout/slides.pug","hash":"1e84a92d5b854dd233e0b511d59c1cd7c8d647a1","modified":1578319060086},{"_id":"themes/melody/layout/tag.pug","hash":"ca333911bc97bc9d3eba6e1bc05e96b209ecedfb","modified":1578319060086},{"_id":"themes/melody/layout/page.pug","hash":"64f1a6564f674a6bbc9dbcb371ae6e23c1335221","modified":1578319060086},{"_id":"themes/melody/languages/default.yml","hash":"2af19daf22ec99daf2482af9dac5c3ff641497c4","modified":1578319060078},{"_id":"themes/melody/languages/en.yml","hash":"2af19daf22ec99daf2482af9dac5c3ff641497c4","modified":1578319060078},{"_id":"themes/melody/source/melody-favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1578319060102},{"_id":"themes/melody/languages/zh-Hans.yml","hash":"68c5794ec57227daec2e3afe2c5d502fa0a7092a","modified":1578319060078},{"_id":"themes/melody/source/.DS_Store","hash":"d29b0c24329815a8ff990d715bdab85281a49a2e","modified":1578548074551},{"_id":"themes/melody/source/baidu_verify_9HYrO8fACI.html","hash":"1e9eeb93ab60269dc256ece659366f57833df754","modified":1578553738639},{"_id":"themes/melody/source/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578319060092},{"_id":"themes/melody/layout/includes/additional-js.pug","hash":"c4ca62466684758d5a26e5866f9ed87b5c9401b8","modified":1578319060080},{"_id":"themes/melody/layout/includes/config.pug","hash":"b55265d49832decb34d57f222deb64f04cc9aa12","modified":1578319060081},{"_id":"themes/melody/layout/includes/footer.pug","hash":"0e9f1778f021f1c205f0b1be83014fba576797af","modified":1578319060081},{"_id":"themes/melody/layout/includes/layout.pug","hash":"58856b5048fb64e7dab75a6ae32cc2a0ad94de4f","modified":1578319060082},{"_id":"themes/melody/layout/includes/head.pug","hash":"cdabb5841dc42a58b6e06df9bc4f5acf90bc8419","modified":1578319060082},{"_id":"themes/melody/layout/includes/header.pug","hash":"006f86f19256eecc05c6cc6e66d5c0c79ddfcc63","modified":1578319060082},{"_id":"themes/melody/layout/includes/.DS_Store","hash":"912f012078768d143aa5e5fd7bbfb02bc72924a1","modified":1578555443867},{"_id":"themes/melody/layout/includes/nav.pug","hash":"3f1fe059784df45f923587b81cc972659ed22e01","modified":1578319060083},{"_id":"themes/melody/layout/includes/recent-posts.pug","hash":"128c448f5bab71f59912516edff9d476ff6b8afe","modified":1578319060083},{"_id":"themes/melody/layout/includes/sidebar.pug","hash":"211b8ecfdb7b5dd836c87436def410a52dfa5ecd","modified":1578319060085},{"_id":"themes/melody/layout/includes/pagination.pug","hash":"fe33a94d90836b767c42654ccc4c4de7d7f227fc","modified":1578319060083},{"_id":"themes/melody/source/css/404.styl","hash":"b7a0f8b23cb137b1a6c4fa0f9a35e06e93065b2c","modified":1578319060087},{"_id":"themes/melody/source/js/copy.js","hash":"ce7f8601c7c75ced79e2e9851beec37299d49fd1","modified":1578319060092},{"_id":"themes/melody/source/css/index.styl","hash":"2053ba56db707e7a03796ba59f77103765b02353","modified":1578319060090},{"_id":"themes/melody/source/css/var.styl","hash":"36dd6bb7271f1bc0bcda4fde5fce88e397cdfae9","modified":1578377495926},{"_id":"themes/melody/source/js/fancybox.js","hash":"2d3eaa654b2524c41dc5aba1d5e2e7cc9aaefd26","modified":1578319060092},{"_id":"themes/melody/source/js/fireworks.js","hash":"17d5770d46d9b531b675b129835561146290af83","modified":1578319060092},{"_id":"themes/melody/source/js/head.js","hash":"555e9caa046d5a174af8d20c75e9e89c25aabb6c","modified":1578319060092},{"_id":"themes/melody/source/js/katex.js","hash":"a5a999b357c0fd9aeacae721bf121f30d40d6726","modified":1578319060092},{"_id":"themes/melody/source/js/scroll.js","hash":"50aee3035949bbc178eafd86adf19fd51916640d","modified":1578319060093},{"_id":"themes/melody/source/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1578319060093},{"_id":"themes/melody/source/css/.DS_Store","hash":"834364e0f60341d09986a1d050ee76d179d96d4d","modified":1578408751005},{"_id":"themes/melody/source/js/transition.js","hash":"11c3b82a5e9ef2bf7bd712b6c211d86426f9a23e","modified":1578319060101},{"_id":"themes/melody/source/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1578319060102},{"_id":"themes/melody/source/js/.DS_Store","hash":"21f9944add8dc9d39fbb10055318e39859501350","modified":1578377313905},{"_id":"themes/melody/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1578319060091},{"_id":"themes/melody/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1578361100996},{"_id":"themes/melody/layout/includes/gallery/script.pug","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1578319060082},{"_id":"themes/melody/layout/includes/404/404-nav.pug","hash":"4cd894857bb90fe44b55e852864692ed06588b8e","modified":1578319060079},{"_id":"themes/melody/layout/includes/404/layout.pug","hash":"9c7cdf16a9b9b4aa251dba9378a0f00d985101de","modified":1578319060079},{"_id":"themes/melody/layout/includes/comments/disqus.pug","hash":"e62b73df92566806bfb170f204295cffd7074215","modified":1578319060080},{"_id":"themes/melody/layout/includes/comments/gitalk.pug","hash":"86bdbc4a52024c3573bea27817394dd118b70a26","modified":1578319060080},{"_id":"themes/melody/layout/includes/comments/gitment.pug","hash":"0b7cd8b0b114876238ca022abda4c1fcdfaee12f","modified":1578319060080},{"_id":"themes/melody/layout/includes/comments/index.pug","hash":"6c16214e5945142e5f3b58e7694397e26f28849d","modified":1578319060080},{"_id":"themes/melody/layout/includes/comments/laibili.pug","hash":"97de1d1fb0459e7a2394ac2f5e449adf9b6986cb","modified":1578319060080},{"_id":"themes/melody/layout/includes/comments/valine.pug","hash":"9115ffd74549d356c18d4e2ad0a85d7b320b8c6e","modified":1578319060081},{"_id":"themes/melody/layout/includes/gallery/layout.pug","hash":"8ff96c4f9afb416c5fc586c9585ae51cb6129529","modified":1578319060081},{"_id":"themes/melody/layout/includes/count/busuanzi.pug","hash":"4df5e63ab0113efb93f05ef781b2a7e3f34ba753","modified":1578319060081},{"_id":"themes/melody/layout/includes/mixins/article-sort.pug","hash":"297b098dc6bba73b76bac4cf6bcd0c29d5dcb2ed","modified":1578319060083},{"_id":"themes/melody/layout/includes/mixins/slide.pug","hash":"91975f700b20131ab4df4d2ea3e1acc8bf2d3eef","modified":1578319060083},{"_id":"themes/melody/layout/includes/search/algolia.pug","hash":"44d5a061df53a276d22b3855652645d90117d0b6","modified":1578319060084},{"_id":"themes/melody/layout/includes/search/index.pug","hash":"b01828b37d789797aeb5433f1705cff3c540a4d5","modified":1578319060084},{"_id":"themes/melody/layout/includes/share/add-this.pug","hash":"17a11c1c36c9078639c2a82628ce5fc6584daffb","modified":1578319060084},{"_id":"themes/melody/layout/includes/share/index.pug","hash":"a2ec6da33cf5fa0ba6c8c38ec3841a0b0003ce98","modified":1578319060084},{"_id":"themes/melody/layout/includes/search/local-search.pug","hash":"f88070a84379bc06fb385e1193448fae6a8a54e1","modified":1578319060084},{"_id":"themes/melody/layout/includes/share/share-js.pug","hash":"e612725ba48711fc119f91c6196287ad13f5a2ba","modified":1578319060084},{"_id":"themes/melody/layout/includes/slide/layout.pug","hash":"f90bfc1cbe21e799a8784129e1a34bd59404e3df","modified":1578319060085},{"_id":"themes/melody/layout/includes/third-party/canvas-ribbon.pug","hash":"39a03f188ac415642766b062a80b1b710f3ea609","modified":1578319060085},{"_id":"themes/melody/layout/includes/slide/script.pug","hash":"940c000ececf7f7596bf8c452dda9b92a5df7710","modified":1578319060085},{"_id":"themes/melody/layout/includes/third-party/katex.pug","hash":"79b2336ad8d921907a5b1badc10ba1651c92843b","modified":1578319060085},{"_id":"themes/melody/layout/includes/third-party/mathjax.pug","hash":"33b350f9826795cd59d9e277a24accc8a9bc9076","modified":1578319060085},{"_id":"themes/melody/source/css/_global/index.styl","hash":"2a6195ce7e822362633ebf403c9438b42fa126bb","modified":1578319060087},{"_id":"themes/melody/source/css/_layout/comments.styl","hash":"e58602aad6792f1a5dbda0677ecb04d21ac10e97","modified":1578319060088},{"_id":"themes/melody/source/css/_layout/head.styl","hash":"73488de3f36369c29ecd5e0be9661bb2b508548c","modified":1578319060088},{"_id":"themes/melody/source/css/_layout/footer.styl","hash":"ca8c816bdb144503bec7e755344fb0e4e370a7bf","modified":1578319060088},{"_id":"themes/melody/source/css/_layout/pagination.styl","hash":"a3f52d1f7ff1eaead8df016b2a4def6f7b4e9559","modified":1578319060088},{"_id":"themes/melody/source/css/_layout/page.styl","hash":"d2f6050bf6ef80523ed9a5a0f058fa5dbaf72ea8","modified":1578319060088},{"_id":"themes/melody/source/css/_layout/post.styl","hash":"9fd88cc878a156e8b275c8dcb95717ca5ceea83a","modified":1578319060088},{"_id":"themes/melody/source/css/_layout/sidebar.styl","hash":"e8315401a6c791d00617c031be01f45df70fe7fd","modified":1578319060088},{"_id":"themes/melody/source/css/_highlight/diff.styl","hash":"ffdfbf088da7bf33899557395abcac0d2bffd67d","modified":1578319060087},{"_id":"themes/melody/source/css/_highlight/theme.styl","hash":"7d85860927afa1d93b4a39febff3d95a73de4c36","modified":1578319060087},{"_id":"themes/melody/source/css/_highlight/highlight.styl","hash":"016c800bf7a0ef6d520e135ab69ef072760483cb","modified":1578319060087},{"_id":"themes/melody/source/css/_search/algolia.styl","hash":"534e5641e3efe2452db95cc25ec8da0111ceadcf","modified":1578319060089},{"_id":"themes/melody/source/css/_search/index.styl","hash":"63cae4465ac54b71361c1795206534c7f2e6e5b1","modified":1578319060089},{"_id":"themes/melody/source/css/_search/local-search.styl","hash":"d7970b385265fef782cdcaaf4fe68a2217625467","modified":1578319060089},{"_id":"themes/melody/source/css/_third-party/jquery.fancybox.min.css","hash":"f9c94ec04062a1bfe1ef894c49e6ec33fa121778","modified":1578319060090},{"_id":"themes/melody/source/css/_third-party/normalize.min.css","hash":"e12eef6d6811c132f4f2fcf6c936be384191bcaf","modified":1578319060090},{"_id":"themes/melody/source/js/third-party/canvas-ribbon.js","hash":"8fd084e962fb2028be9f748b5cb5f53d030d1d03","modified":1578319060094},{"_id":"themes/melody/source/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1578319060094},{"_id":"themes/melody/source/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1578319060101},{"_id":"themes/melody/source/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1578319060093},{"_id":"themes/melody/source/js/search/local-search.js","hash":"b7e77c27097d9d3ced13618912069d1ddf1cd64a","modified":1578319060093},{"_id":"themes/melody/source/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1578319060101},{"_id":"themes/melody/source/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1578319060094},{"_id":"themes/melody/source/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1578319060095},{"_id":"themes/melody/source/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1578319060100},{"_id":"themes/melody/source/js/third-party/reveal/head.min.js","hash":"8c9495c76d5aa00d3dfb88653c362fba9f10cbb2","modified":1578319060095},{"_id":"themes/melody/source/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1578319060100},{"_id":"themes/melody/source/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1578319060100},{"_id":"themes/melody/source/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1578319060100},{"_id":"themes/melody/source/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1578319060101},{"_id":"themes/melody/source/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1578319060101},{"_id":"themes/melody/source/img/avatar.png","hash":"a093f97fa1ee988979b0948e424bd1f2a98a8ba8","modified":1578324265744},{"_id":"themes/melody/source/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1578319060100},{"_id":"public/baidusitemap.xml","hash":"cb6dba72d8cc58080efa5936815f5f1e8c294d44","modified":1581926238616},{"_id":"public/sitemap.xml","hash":"4a31026a76b8e53d2ba26eb6677e3106f8394f00","modified":1581926238623},{"_id":"public/atom.xml","hash":"1def7831382d4555aa0dde35a01676c54298dd43","modified":1581926238625},{"_id":"public/categories/index.html","hash":"952f40d63f2e002defd97ffd1f82bef31ec820b7","modified":1581926238653},{"_id":"public/tags/index.html","hash":"109905159c1b104fa437aed7eecd7098d1d65fb1","modified":1581926238653},{"_id":"public/2020/02/17/firewall/index.html","hash":"d751a3cf756d0885364f18802f448e77d6f772e1","modified":1581926238653},{"_id":"public/2020/01/10/Tampermonkey/index.html","hash":"77c299943fbc68817fc59cfdfc1e175c59e52b86","modified":1581926238653},{"_id":"public/2020/01/09/ghelper/index.html","hash":"a9002db4869839d17ccc66c7389468cbba4a3f7d","modified":1581926238653},{"_id":"public/2020/01/06/macappfree/index.html","hash":"2ccf38d7b96e13702dc114089d0a611e3c433263","modified":1581926238654},{"_id":"public/2019/07/03/encryption/index.html","hash":"fc20b3b76d95a6535925303215bfb5c92da66fc8","modified":1581926238654},{"_id":"public/2019/03/10/win-activation/index.html","hash":"f2b57f53059f3495ddbe1987b4c68e3a14220b77","modified":1581926238654},{"_id":"public/2018/06/06/nginx/index.html","hash":"5ea7ff56867320db4049bb729ce2aabdd5a2a813","modified":1581926238654},{"_id":"public/2018/05/12/maven/index.html","hash":"5eb400a0bf957ca750ac6586550219ab7fe84424","modified":1581926238654},{"_id":"public/2017/09/02/hello-world/index.html","hash":"4b7935281ba927ea25f803892b3f58b84e83f1db","modified":1581926238654},{"_id":"public/archives/index.html","hash":"fd22a2818c2207c4084f4dd05698e3ae4105e9ea","modified":1581926238654},{"_id":"public/archives/page/2/index.html","hash":"a314de65fe2c5d294ca35484cb9e9143dca5c4c9","modified":1581926238654},{"_id":"public/archives/2017/index.html","hash":"73787468b90617ecf79cadd669bdb6b8bdccddd2","modified":1581926238654},{"_id":"public/archives/2017/09/index.html","hash":"c3f7e56a65f86c573d3ac754a002429920a4eef9","modified":1581926238654},{"_id":"public/archives/2017/11/index.html","hash":"80d18d6371d4158dc4a077d8ea61ec8b37c1fc3d","modified":1581926238654},{"_id":"public/archives/2018/index.html","hash":"ce1994cd253d567bcff53b0eba4ab3b66f6c1a84","modified":1581926238654},{"_id":"public/archives/2018/03/index.html","hash":"65e3f493864ae62f1aa672b8386c1748d43763d9","modified":1581926238654},{"_id":"public/archives/2018/05/index.html","hash":"fdda95834dd7e31ffafcd09a98592a241d213d8a","modified":1581926238654},{"_id":"public/archives/2018/06/index.html","hash":"77224801cc16f7cec825aa0ff76f2491d03a573f","modified":1581926238654},{"_id":"public/archives/2019/index.html","hash":"a86cb5290fdb9a9d5c3347a737e45239a0af2dc6","modified":1581926238654},{"_id":"public/archives/2019/03/index.html","hash":"25b4726df9ee50683c577d268ef841f0f063c7a4","modified":1581926238654},{"_id":"public/archives/2019/06/index.html","hash":"369c19bf6adbb97d67f8c6efaec6180661f8184a","modified":1581926238654},{"_id":"public/archives/2019/07/index.html","hash":"d9eb21d9680b72133772406a160ffb60353f4174","modified":1581926238654},{"_id":"public/archives/2020/index.html","hash":"41a11a63bf352bb8105fe1273780427ff1ee4f19","modified":1581926238654},{"_id":"public/archives/2020/01/index.html","hash":"5390333c7c1570b5daf57e6cd0d4100d1efb1d4e","modified":1581926238654},{"_id":"public/archives/2020/02/index.html","hash":"8d80c52a3d23ec7b64962a294469f7cf224e999d","modified":1581926238654},{"_id":"public/categories/Java/index.html","hash":"642801cabb0a923e87ad30c66cbc8a4ee31ed5ff","modified":1581926238655},{"_id":"public/categories/Java/page/2/index.html","hash":"e6721f571874bf796711eba5023f81c4e1c68599","modified":1581926238655},{"_id":"public/categories/Java/算法/index.html","hash":"7dad5a7dd1aab9e4944faffa0c040931629b4f75","modified":1581926238655},{"_id":"public/categories/Java/数据结构/index.html","hash":"075778bd07a24a3389b4e365fabf6ecd35baf57f","modified":1581926238655},{"_id":"public/categories/Java/设计模式/index.html","hash":"175316d4e63ac467f48ce1b8a7e2d0c84d850a53","modified":1581926238655},{"_id":"public/categories/System/index.html","hash":"40e97a8fe2b67b025747eefbcd4560133385ac16","modified":1581926238655},{"_id":"public/categories/Java/高并发/index.html","hash":"09dd3c56f86c528d38982fea7db9373c7d519b3d","modified":1581926238655},{"_id":"public/tags/数据结构/index.html","hash":"ac6438d48c614e386ffdb0e3399ab7a64c2ebe46","modified":1581926238655},{"_id":"public/tags/B-Tree/index.html","hash":"a44ad8c5ad326191ab3ec2ca996a39c78542f9dc","modified":1581926238655},{"_id":"public/tags/高并发/index.html","hash":"02c195136737240f304164f16917e7f66873a351","modified":1581926238655},{"_id":"public/tags/ConcurrentHashMap/index.html","hash":"d48632c76a3b6a7abcb1f8ba82cc2beae3912cb6","modified":1581926238655},{"_id":"public/tags/HashMap/index.html","hash":"97a98f2b084bc0c2f2d6b821427f452eda94c12d","modified":1581926238655},{"_id":"public/tags/算法/index.html","hash":"67f65d491529eb7d52731e9a2483b9b28a223cef","modified":1581926238655},{"_id":"public/tags/链表逆序算法/index.html","hash":"1c5a6fed1b583d36803d8905035a99725294fa2c","modified":1581926238655},{"_id":"public/tags/AES算法/index.html","hash":"d432dbd62a55fb9915e4431f2ab968ba18339fc7","modified":1581926238655},{"_id":"public/tags/MD5算法/index.html","hash":"6f32c5079f317faf32bbe41e857588e19c7164af","modified":1581926238655},{"_id":"public/tags/Google-plugin/index.html","hash":"06432cbd70b5bc50b6b8fce491a4048a29e0409b","modified":1581926238655},{"_id":"public/tags/Tampermonkey/index.html","hash":"43b01e40dacb75a992ef48c150f20aa575a87bb9","modified":1581926238655},{"_id":"public/tags/加密算法/index.html","hash":"543694e424e06c1a52317fcc3edbae8c55f3e252","modified":1581926238655},{"_id":"public/tags/设计模式/index.html","hash":"cfe19e35b340a562acd0d4c0f02f06db203e6247","modified":1581926238655},{"_id":"public/tags/factory/index.html","hash":"2a15b4458c7d2f3466bfab77892d80fafefbf9c5","modified":1581926238655},{"_id":"public/tags/CentOS/index.html","hash":"3d09358f55ec7feb0fb0d5896822c50c99d94042","modified":1581926238656},{"_id":"public/tags/FireWall/index.html","hash":"6ac498bce2e53cd6514e1210c48a5480d787c909","modified":1581926238656},{"_id":"public/tags/macOS/index.html","hash":"7c3fcb56a8883bcd1595f86fda0db21828c35130","modified":1581926238656},{"_id":"public/tags/free-apps/index.html","hash":"edf9925db7e516cb74fd6fc7b939b8e4f587bfc3","modified":1581926238656},{"_id":"public/tags/Ghelper/index.html","hash":"e83934c9c49b9ec5ecb3235939e3a78ba5b8b056","modified":1581926238656},{"_id":"public/tags/version-control/index.html","hash":"9606b6a59f296c462c9c3f182a60b9c35b5b70d1","modified":1581926238656},{"_id":"public/tags/maven/index.html","hash":"9bd3ab55212e759476aa12933615c1f9fda8d587","modified":1581926238656},{"_id":"public/tags/paid-apps/index.html","hash":"09dee46b88badd9ed809d4091b4d4f8afa196595","modified":1581926238656},{"_id":"public/tags/singleton/index.html","hash":"83cb0334a2dc798fde50affde1e63158a1a23907","modified":1581926238656},{"_id":"public/tags/Windows/index.html","hash":"aa56aa10cef821f8ffc9ba10717a7403ef12b1d9","modified":1581926238656},{"_id":"public/tags/activation/index.html","hash":"95f0c8609a4ee9949505cc44cbce182905c95a62","modified":1581926238656},{"_id":"public/tags/分布式/index.html","hash":"695b448db9949e2cb3680737d35201f7710ec8a4","modified":1581926238656},{"_id":"public/tags/nginx/index.html","hash":"1538b57f11d7d07746e82695991be825788db87f","modified":1581926238656},{"_id":"public/tags/volatile/index.html","hash":"7e851676abdea9a66a614ae42d21b25f0cbb9ba4","modified":1581926238656},{"_id":"public/tags/消息队列/index.html","hash":"52c9b2604bcc01432fbc8837d3e46d383c4d7c50","modified":1581926238656},{"_id":"public/tags/数据库/index.html","hash":"8189f65a12123467d51b25c11b8584af5c6ec8bf","modified":1581926238656},{"_id":"public/tags/Sub-table/index.html","hash":"61694fd17baf66b81cd92ce4eb80ff5b49308684","modified":1581926238656},{"_id":"public/tags/git/index.html","hash":"abae0e0427b5a9db060806037267050660bb75a6","modified":1581926238656},{"_id":"public/tags/web框架/index.html","hash":"05f5750646c0489e7afe53e2c3ac737b618aa166","modified":1581926238656},{"_id":"public/tags/mybatis/index.html","hash":"bf124b286823b5d741890c71abd88e4c97903405","modified":1581926238656},{"_id":"public/tags/zookeeper/index.html","hash":"822640e2724f0062a58e98a4e6629f788ecbdffc","modified":1581926238656},{"_id":"public/tags/八大排序算法/index.html","hash":"b60930b3705fcf7d7f2f5deee8b04a224b12d7b7","modified":1581926238656},{"_id":"public/tags/线程池/index.html","hash":"f73b9c5b751540ee201b9d357ad6f22c851569e7","modified":1581926238656},{"_id":"public/tags/redis/index.html","hash":"11e86f0307ae1938c1fd2f40b59b98bf3206bdd7","modified":1581926238656},{"_id":"public/tags/develop-frame-summary/index.html","hash":"8d14922d58be5a1bf0adfcda2edca12e9e573214","modified":1581926238656},{"_id":"public/2020/01/08/macapp/index.html","hash":"132437655cfae62f7f85bd90ee448e09b915c34f","modified":1581926238656},{"_id":"public/2019/07/05/AES/index.html","hash":"878b933e1637f012208ce784b4645accb5be7af9","modified":1581926238656},{"_id":"public/2019/07/04/MD5/index.html","hash":"ddccb7cd1c0221cc2271ffec244b8487d5ea77c1","modified":1581926238657},{"_id":"public/2019/06/18/LinkedList-Reverse/index.html","hash":"5165e9ace3810ef9152a874a29b83efd10511331","modified":1581926238657},{"_id":"public/2019/06/17/Sort/index.html","hash":"d26c8a690f098127331e49453ef2102d15632c67","modified":1581926238657},{"_id":"public/2019/03/19/MQ/index.html","hash":"565983ca584378b71a11751cc7f353207457dec4","modified":1581926238657},{"_id":"public/2019/03/19/ConcurrentHashMap/index.html","hash":"77cf6cad64ce74d41cf415e1dec92b2ce806a771","modified":1581926238657},{"_id":"public/2019/03/18/HashMap/index.html","hash":"97bffa41080d6dcae00c78f737f4ead4ac265810","modified":1581926238657},{"_id":"public/2019/03/17/Sub-table/index.html","hash":"699ce69f9d712f80d497f616c0b777f94569c9da","modified":1581926238657},{"_id":"public/2019/03/16/BTree/index.html","hash":"69f4550285dcb7b4976b663f94d94dbfc95eece8","modified":1581926238657},{"_id":"public/2019/03/15/volatile/index.html","hash":"87352b7b0c139882f198c7160e579f3ca61a87fa","modified":1581926238657},{"_id":"public/2019/03/12/redis/index.html","hash":"c00e3618b929a9de46671c6765478bb4bdf1860b","modified":1581926238657},{"_id":"public/2019/03/11/Thread-Pool/index.html","hash":"889872ff16037e5512d08830186d5f400526ed19","modified":1581926238657},{"_id":"public/2018/06/03/zookeeper/index.html","hash":"3878cbaae55e178595e8868d262a0b2b88f0bc41","modified":1581926238657},{"_id":"public/2018/05/13/git/index.html","hash":"1672aa9381560a00d798fc58c90c7d29814192d2","modified":1581926238657},{"_id":"public/2018/03/22/mybatis/index.html","hash":"58a6469443f9d5f7e5b6c1b79ad59198e734b9d9","modified":1581926238657},{"_id":"public/2017/11/10/factory/index.html","hash":"04a0b51ae8691d34c9545b98b4b637884b9e1d53","modified":1581926238658},{"_id":"public/2017/11/10/singleton/index.html","hash":"430337c6f75d533976b8cae4c31ee88de7705e19","modified":1581926238658},{"_id":"public/2017/09/08/article/index.html","hash":"a29715e5d15b6720fb3b4dd5f0bf333e859ec0ab","modified":1581926238658},{"_id":"public/index.html","hash":"bf45a3afceda57334a7232102b4fc8ace69233eb","modified":1581926238658},{"_id":"public/page/2/index.html","hash":"aafa7d48de1a5ccfe36e9cb676e54f9f2f7f6803","modified":1581926238658},{"_id":"public/page/3/index.html","hash":"f9606bea359a5ee28f399d1ae8ab5d5f8c2f2833","modified":1581926238658},{"_id":"public/CNAME","hash":"a13b825bb875171c6f4243505bdee63819efbc9d","modified":1581926238662},{"_id":"public/melody-favicon.ico","hash":"e33c804e570eb238fe095ed28346dd1b3a0666ae","modified":1581926238662},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1581926238662},{"_id":"public/assets/algolia/algoliasearchLite.min.js","hash":"284416885e4e80e27fa4eae6fc305f4de15b914c","modified":1581926238662},{"_id":"public/assets/algolia/algoliasearch.min.js","hash":"a3b131a9a47ccc16f4dd8988fabb6d306548db2f","modified":1581926239202},{"_id":"public/js/copy.js","hash":"ce7f8601c7c75ced79e2e9851beec37299d49fd1","modified":1581926239219},{"_id":"public/css/404.css","hash":"712ecbf4ac203ab5f1ea92989c0f0062a3d0aca9","modified":1581926239219},{"_id":"public/js/hexo-theme-melody.js","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581926239219},{"_id":"public/js/head.js","hash":"555e9caa046d5a174af8d20c75e9e89c25aabb6c","modified":1581926239219},{"_id":"public/js/fancybox.js","hash":"2d3eaa654b2524c41dc5aba1d5e2e7cc9aaefd26","modified":1581926239219},{"_id":"public/js/fireworks.js","hash":"17d5770d46d9b531b675b129835561146290af83","modified":1581926239219},{"_id":"public/js/scroll.js","hash":"50aee3035949bbc178eafd86adf19fd51916640d","modified":1581926239219},{"_id":"public/js/katex.js","hash":"a5a999b357c0fd9aeacae721bf121f30d40d6726","modified":1581926239219},{"_id":"public/js/sidebar.js","hash":"a42109c5a69dedc87e1aaf8cb2383fd43069677e","modified":1581926239219},{"_id":"public/js/transition.js","hash":"11c3b82a5e9ef2bf7bd712b6c211d86426f9a23e","modified":1581926239219},{"_id":"public/js/utils.js","hash":"f514662ad80803e1bb5f6bc653c4b9ad06ea4932","modified":1581926239219},{"_id":"public/js/third-party/canvas-ribbon.js","hash":"8fd084e962fb2028be9f748b5cb5f53d030d1d03","modified":1581926239220},{"_id":"public/js/search/algolia.js","hash":"8d2cc7ac4a015563344a3981c3040d308489935c","modified":1581926239220},{"_id":"public/js/search/local-search.js","hash":"b7e77c27097d9d3ced13618912069d1ddf1cd64a","modified":1581926239220},{"_id":"public/js/third-party/reveal/markdown.min.js","hash":"859d70cd7c459819b90fe27afb940d16ecff6614","modified":1581926239220},{"_id":"public/js/third-party/reveal/math.min.js","hash":"779c98dbd83a528f27ea4b9f2d420c957c0939ba","modified":1581926239220},{"_id":"public/js/third-party/reveal/notes.min.js","hash":"4bb2925b111467791fdef3c4e4b41993d59ce90f","modified":1581926239220},{"_id":"public/js/third-party/reveal/zoom.min.js","hash":"aca47bf417d451c4d364c6eb287a230e4b462b17","modified":1581926239220},{"_id":"public/baidu_verify_9HYrO8fACI.html","hash":"1e9eeb93ab60269dc256ece659366f57833df754","modified":1581926239220},{"_id":"public/css/index.css","hash":"9b47e96b7fee5c6b1dba47416950c472b045e94b","modified":1581926239220},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1581926239225},{"_id":"public/js/third-party/anime.min.js","hash":"3c46c9597c721644a515c1c54ab13f46406657f7","modified":1581926239225},{"_id":"public/js/third-party/velocity.ui.min.js","hash":"d8124c091d19fa4072616a44a8897fabc6599fce","modified":1581926239225},{"_id":"public/js/third-party/reveal/head.min.js","hash":"95c9de30444117adbbb3218070fda00af187a76a","modified":1581926239225},{"_id":"public/assets/algolia/algoliasearchLite.js","hash":"e56ad6b82caf69066de545201014291fc961635e","modified":1581926239225},{"_id":"public/js/third-party/reveal/marked.min.js","hash":"37f3186f93ec854f56bf745a5988a89225e8da6c","modified":1581926239230},{"_id":"public/assets/algolia/algoliasearch.js","hash":"6948fcdf071e4983e784e8c458cf201536f77792","modified":1581926239230},{"_id":"public/img/avatar.png","hash":"a093f97fa1ee988979b0948e424bd1f2a98a8ba8","modified":1581926239234},{"_id":"public/js/third-party/velocity.min.js","hash":"69c85b9d6a931a7d3a5b0657e60112c31fb3b286","modified":1581926239248},{"_id":"public/js/third-party/jquery.fancybox.min.js","hash":"2ec3ef6c31b971ba5e58eb4a0c5ede902bbdd4af","modified":1581926239252},{"_id":"public/js/third-party/reveal/reveal.min.js","hash":"d8377a86451712488dea87caf5acbf8e97aa991f","modified":1581926239252},{"_id":"public/js/third-party/jquery.min.js","hash":"1055018c28ab41087ef9ccefe411606893dabea2","modified":1581926239265},{"_id":"public/js/third-party/reveal/highlight.min.js","hash":"10dd530e712a67f25cf27845213c0f28d2fe9e4d","modified":1581926239274}],"Category":[{"name":"Java","_id":"ck6q61bia0003a6ybtqtkebc1"},{"name":"算法","parent":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bin000ha6ybd6434d7o"},{"name":"数据结构","parent":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61biq000ma6yb87o1vpvj"},{"name":"设计模式","parent":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bj5001ma6ybnuj7jniw"},{"name":"System","_id":"ck6q61bj8001sa6ybof88zfi9"},{"name":"高并发","parent":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61cnp004ra6yb6vruz1lt"}],"Data":[],"Page":[{"title":"文章分类","date":"2020-01-07T01:06:12.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 文章分类\ndate: 2020-01-07 09:06:12\ntype: \"categories\"\n---\n","updated":"2020-01-11T05:25:44.324Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck6q61bi80001a6ybs3b8vzzd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2020-01-07T01:04:41.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-01-07 09:04:41\ntype: \"tags\"\n---\n","updated":"2020-01-11T05:25:44.325Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck6q61bju003ra6ybd1hw09p0","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Mysql索引,B+Tree详解","date":"2019-03-16T15:00:13.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## Mysql索引？\n\n### 索引是什么？\n\n索引是为了加速对表中数据行的检索而创建的一种分散存储的**数据结构**。\n\n### 为什么要创建索引？\n\n1. 创建索引可以大大提高系统的查询性能。\n2. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面。\n4. 在使用分组喝排序子句进行数据检索时，同样可以显著减少查询中分组喝排序的时间。\n5. 通过使用索引，可以在查询过程中，使用优化隐藏器，提高系统的性能。\n\n<!-- More -->\n\n### 索引的缺点\n\n1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。\n2. 除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如要建立聚集索引，则需要空间更大。\n3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。\n\n### 适合添加索引的字段\n\n经常需要搜索的列、主键、外键、经常需要范围查询的列、经常需要排序的列、经常使用的where子句的列。\n\n注意：建立索引一般按照select的where条件来建立，比如条件是where f1 and f2，需要在f1、f2上同时建立。\n\n### 不适合添加索引的字段\n\n查询中很少使用的字段、区分度不高的列、text,image,bit等数据量大的列、修改性能大于检索性能不要加。\n\n## 二叉树的缺陷\n\n**搜索效率不足，树的深度不可控。**（树的深度决定着搜索时IO次数）\n\n**节点数据内容太少。**（没有很好的利用系统和磁盘的数据交换特性）\n\n## B-树的特点\n\nB-树是一种多路平衡二叉树，相比于二叉树大大降低了树的高度，减少了磁盘IO。\n\n## B+树的特点\n\n1. 每一个根节点的元素都出现在子节点中，是子节点的最大（或最小）元素。\n2. 根节点的最大元素就是整个B+树的最大元素，无论插入删除多少元素，始终保持最大元素在根节点中。\n3. 由于特点1，所以叶子节点包含了全量的元素信息。\n4. 每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。\n\n### 卫星数据的位置\n\n在B-树中，无论中间节点还是叶子节点都带有卫星数据。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gay4wwcz3lj30ji0brae3.jpg)\n\n在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gay4x092ahj30jk0bfjv0.jpg)\n\nPS：在数据库的聚集索引(Clustered Index)中，叶子节点直接包含卫星数据；在非聚集索引(NonClustered Index)中，叶子节点带有指向卫星数据的指针。\n\n### B+树的优点\n\n- B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的元素，这就意味着数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询时IO次数更少。\n- B+树的查找性能更稳定，因为B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，所以B-树的查找性能不如B+树稳定。\n- 在范围查找方面，B-树只能依靠繁琐的中序遍历，反观B+树则要简单的多，只需要在链表上做遍历即可。\n\n**综上所述，B+树相比于B-树的优势有三个**\n\n1. 单一节点存储更多的元素，使得查询的IO次数更少。\n2. 所有查询都要查找到子节点，查询性能稳定。\n3. 所有叶子节点形成有序链表，便于范围查询。\n\n## 最左匹配原则\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gay93ok47nj30sz0gj45e.jpg)\n\n## 联合索引\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gay94rzzm0j30sy0ef47q.jpg)\n\n## 覆盖索引\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gay95n2xzmj30sp0i4gyc.jpg)","source":"_posts/BTree.md","raw":"---\ntitle: Mysql索引,B+Tree详解\ndate: 2019-03-16 23:00:13\ncategories: \n  - Java\n  - 数据结构\ntags: \n  - 数据结构\n  - B+Tree\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## Mysql索引？\n\n### 索引是什么？\n\n索引是为了加速对表中数据行的检索而创建的一种分散存储的**数据结构**。\n\n### 为什么要创建索引？\n\n1. 创建索引可以大大提高系统的查询性能。\n2. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\n3. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面。\n4. 在使用分组喝排序子句进行数据检索时，同样可以显著减少查询中分组喝排序的时间。\n5. 通过使用索引，可以在查询过程中，使用优化隐藏器，提高系统的性能。\n\n<!-- More -->\n\n### 索引的缺点\n\n1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。\n2. 除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如要建立聚集索引，则需要空间更大。\n3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。\n\n### 适合添加索引的字段\n\n经常需要搜索的列、主键、外键、经常需要范围查询的列、经常需要排序的列、经常使用的where子句的列。\n\n注意：建立索引一般按照select的where条件来建立，比如条件是where f1 and f2，需要在f1、f2上同时建立。\n\n### 不适合添加索引的字段\n\n查询中很少使用的字段、区分度不高的列、text,image,bit等数据量大的列、修改性能大于检索性能不要加。\n\n## 二叉树的缺陷\n\n**搜索效率不足，树的深度不可控。**（树的深度决定着搜索时IO次数）\n\n**节点数据内容太少。**（没有很好的利用系统和磁盘的数据交换特性）\n\n## B-树的特点\n\nB-树是一种多路平衡二叉树，相比于二叉树大大降低了树的高度，减少了磁盘IO。\n\n## B+树的特点\n\n1. 每一个根节点的元素都出现在子节点中，是子节点的最大（或最小）元素。\n2. 根节点的最大元素就是整个B+树的最大元素，无论插入删除多少元素，始终保持最大元素在根节点中。\n3. 由于特点1，所以叶子节点包含了全量的元素信息。\n4. 每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。\n\n### 卫星数据的位置\n\n在B-树中，无论中间节点还是叶子节点都带有卫星数据。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gay4wwcz3lj30ji0brae3.jpg)\n\n在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gay4x092ahj30jk0bfjv0.jpg)\n\nPS：在数据库的聚集索引(Clustered Index)中，叶子节点直接包含卫星数据；在非聚集索引(NonClustered Index)中，叶子节点带有指向卫星数据的指针。\n\n### B+树的优点\n\n- B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的元素，这就意味着数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询时IO次数更少。\n- B+树的查找性能更稳定，因为B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，所以B-树的查找性能不如B+树稳定。\n- 在范围查找方面，B-树只能依靠繁琐的中序遍历，反观B+树则要简单的多，只需要在链表上做遍历即可。\n\n**综上所述，B+树相比于B-树的优势有三个**\n\n1. 单一节点存储更多的元素，使得查询的IO次数更少。\n2. 所有查询都要查找到子节点，查询性能稳定。\n3. 所有叶子节点形成有序链表，便于范围查询。\n\n## 最左匹配原则\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gay93ok47nj30sz0gj45e.jpg)\n\n## 联合索引\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gay94rzzm0j30sy0ef47q.jpg)\n\n## 覆盖索引\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gay95n2xzmj30sp0i4gyc.jpg)","slug":"BTree","published":1,"updated":"2020-01-17T05:08:13.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bi40000a6yb9mmmc62x","content":"<h2 id=\"Mysql索引？\"><a href=\"#Mysql索引？\" class=\"headerlink\" title=\"Mysql索引？\"></a>Mysql索引？</h2><h3 id=\"索引是什么？\"><a href=\"#索引是什么？\" class=\"headerlink\" title=\"索引是什么？\"></a>索引是什么？</h3><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p>\n<h3 id=\"为什么要创建索引？\"><a href=\"#为什么要创建索引？\" class=\"headerlink\" title=\"为什么要创建索引？\"></a>为什么要创建索引？</h3><ol>\n<li>创建索引可以大大提高系统的查询性能。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面。</li>\n<li>在使用分组喝排序子句进行数据检索时，同样可以显著减少查询中分组喝排序的时间。</li>\n<li>通过使用索引，可以在查询过程中，使用优化隐藏器，提高系统的性能。</li>\n</ol>\n<a id=\"more\"></a>\n\n<h3 id=\"索引的缺点\"><a href=\"#索引的缺点\" class=\"headerlink\" title=\"索引的缺点\"></a>索引的缺点</h3><ol>\n<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>\n<li>除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如要建立聚集索引，则需要空间更大。</li>\n<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。</li>\n</ol>\n<h3 id=\"适合添加索引的字段\"><a href=\"#适合添加索引的字段\" class=\"headerlink\" title=\"适合添加索引的字段\"></a>适合添加索引的字段</h3><p>经常需要搜索的列、主键、外键、经常需要范围查询的列、经常需要排序的列、经常使用的where子句的列。</p>\n<p>注意：建立索引一般按照select的where条件来建立，比如条件是where f1 and f2，需要在f1、f2上同时建立。</p>\n<h3 id=\"不适合添加索引的字段\"><a href=\"#不适合添加索引的字段\" class=\"headerlink\" title=\"不适合添加索引的字段\"></a>不适合添加索引的字段</h3><p>查询中很少使用的字段、区分度不高的列、text,image,bit等数据量大的列、修改性能大于检索性能不要加。</p>\n<h2 id=\"二叉树的缺陷\"><a href=\"#二叉树的缺陷\" class=\"headerlink\" title=\"二叉树的缺陷\"></a>二叉树的缺陷</h2><p><strong>搜索效率不足，树的深度不可控。</strong>（树的深度决定着搜索时IO次数）</p>\n<p><strong>节点数据内容太少。</strong>（没有很好的利用系统和磁盘的数据交换特性）</p>\n<h2 id=\"B-树的特点\"><a href=\"#B-树的特点\" class=\"headerlink\" title=\"B-树的特点\"></a>B-树的特点</h2><p>B-树是一种多路平衡二叉树，相比于二叉树大大降低了树的高度，减少了磁盘IO。</p>\n<h2 id=\"B-树的特点-1\"><a href=\"#B-树的特点-1\" class=\"headerlink\" title=\"B+树的特点\"></a>B+树的特点</h2><ol>\n<li>每一个根节点的元素都出现在子节点中，是子节点的最大（或最小）元素。</li>\n<li>根节点的最大元素就是整个B+树的最大元素，无论插入删除多少元素，始终保持最大元素在根节点中。</li>\n<li>由于特点1，所以叶子节点包含了全量的元素信息。</li>\n<li>每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。</li>\n</ol>\n<h3 id=\"卫星数据的位置\"><a href=\"#卫星数据的位置\" class=\"headerlink\" title=\"卫星数据的位置\"></a>卫星数据的位置</h3><p>在B-树中，无论中间节点还是叶子节点都带有卫星数据。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gay4wwcz3lj30ji0brae3.jpg\" alt></p>\n<p>在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gay4x092ahj30jk0bfjv0.jpg\" alt></p>\n<p>PS：在数据库的聚集索引(Clustered Index)中，叶子节点直接包含卫星数据；在非聚集索引(NonClustered Index)中，叶子节点带有指向卫星数据的指针。</p>\n<h3 id=\"B-树的优点\"><a href=\"#B-树的优点\" class=\"headerlink\" title=\"B+树的优点\"></a>B+树的优点</h3><ul>\n<li>B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的元素，这就意味着数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询时IO次数更少。</li>\n<li>B+树的查找性能更稳定，因为B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，所以B-树的查找性能不如B+树稳定。</li>\n<li>在范围查找方面，B-树只能依靠繁琐的中序遍历，反观B+树则要简单的多，只需要在链表上做遍历即可。</li>\n</ul>\n<p><strong>综上所述，B+树相比于B-树的优势有三个</strong></p>\n<ol>\n<li>单一节点存储更多的元素，使得查询的IO次数更少。</li>\n<li>所有查询都要查找到子节点，查询性能稳定。</li>\n<li>所有叶子节点形成有序链表，便于范围查询。</li>\n</ol>\n<h2 id=\"最左匹配原则\"><a href=\"#最左匹配原则\" class=\"headerlink\" title=\"最左匹配原则\"></a>最左匹配原则</h2><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gay93ok47nj30sz0gj45e.jpg\" alt></p>\n<h2 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h2><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gay94rzzm0j30sy0ef47q.jpg\" alt></p>\n<h2 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h2><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gay95n2xzmj30sp0i4gyc.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Mysql索引？\"><a href=\"#Mysql索引？\" class=\"headerlink\" title=\"Mysql索引？\"></a>Mysql索引？</h2><h3 id=\"索引是什么？\"><a href=\"#索引是什么？\" class=\"headerlink\" title=\"索引是什么？\"></a>索引是什么？</h3><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p>\n<h3 id=\"为什么要创建索引？\"><a href=\"#为什么要创建索引？\" class=\"headerlink\" title=\"为什么要创建索引？\"></a>为什么要创建索引？</h3><ol>\n<li>创建索引可以大大提高系统的查询性能。</li>\n<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>\n<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面。</li>\n<li>在使用分组喝排序子句进行数据检索时，同样可以显著减少查询中分组喝排序的时间。</li>\n<li>通过使用索引，可以在查询过程中，使用优化隐藏器，提高系统的性能。</li>\n</ol>","more":"<h3 id=\"索引的缺点\"><a href=\"#索引的缺点\" class=\"headerlink\" title=\"索引的缺点\"></a>索引的缺点</h3><ol>\n<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li>\n<li>除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如要建立聚集索引，则需要空间更大。</li>\n<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。</li>\n</ol>\n<h3 id=\"适合添加索引的字段\"><a href=\"#适合添加索引的字段\" class=\"headerlink\" title=\"适合添加索引的字段\"></a>适合添加索引的字段</h3><p>经常需要搜索的列、主键、外键、经常需要范围查询的列、经常需要排序的列、经常使用的where子句的列。</p>\n<p>注意：建立索引一般按照select的where条件来建立，比如条件是where f1 and f2，需要在f1、f2上同时建立。</p>\n<h3 id=\"不适合添加索引的字段\"><a href=\"#不适合添加索引的字段\" class=\"headerlink\" title=\"不适合添加索引的字段\"></a>不适合添加索引的字段</h3><p>查询中很少使用的字段、区分度不高的列、text,image,bit等数据量大的列、修改性能大于检索性能不要加。</p>\n<h2 id=\"二叉树的缺陷\"><a href=\"#二叉树的缺陷\" class=\"headerlink\" title=\"二叉树的缺陷\"></a>二叉树的缺陷</h2><p><strong>搜索效率不足，树的深度不可控。</strong>（树的深度决定着搜索时IO次数）</p>\n<p><strong>节点数据内容太少。</strong>（没有很好的利用系统和磁盘的数据交换特性）</p>\n<h2 id=\"B-树的特点\"><a href=\"#B-树的特点\" class=\"headerlink\" title=\"B-树的特点\"></a>B-树的特点</h2><p>B-树是一种多路平衡二叉树，相比于二叉树大大降低了树的高度，减少了磁盘IO。</p>\n<h2 id=\"B-树的特点-1\"><a href=\"#B-树的特点-1\" class=\"headerlink\" title=\"B+树的特点\"></a>B+树的特点</h2><ol>\n<li>每一个根节点的元素都出现在子节点中，是子节点的最大（或最小）元素。</li>\n<li>根节点的最大元素就是整个B+树的最大元素，无论插入删除多少元素，始终保持最大元素在根节点中。</li>\n<li>由于特点1，所以叶子节点包含了全量的元素信息。</li>\n<li>每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。</li>\n</ol>\n<h3 id=\"卫星数据的位置\"><a href=\"#卫星数据的位置\" class=\"headerlink\" title=\"卫星数据的位置\"></a>卫星数据的位置</h3><p>在B-树中，无论中间节点还是叶子节点都带有卫星数据。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gay4wwcz3lj30ji0brae3.jpg\" alt></p>\n<p>在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gay4x092ahj30jk0bfjv0.jpg\" alt></p>\n<p>PS：在数据库的聚集索引(Clustered Index)中，叶子节点直接包含卫星数据；在非聚集索引(NonClustered Index)中，叶子节点带有指向卫星数据的指针。</p>\n<h3 id=\"B-树的优点\"><a href=\"#B-树的优点\" class=\"headerlink\" title=\"B+树的优点\"></a>B+树的优点</h3><ul>\n<li>B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的元素，这就意味着数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询时IO次数更少。</li>\n<li>B+树的查找性能更稳定，因为B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，所以B-树的查找性能不如B+树稳定。</li>\n<li>在范围查找方面，B-树只能依靠繁琐的中序遍历，反观B+树则要简单的多，只需要在链表上做遍历即可。</li>\n</ul>\n<p><strong>综上所述，B+树相比于B-树的优势有三个</strong></p>\n<ol>\n<li>单一节点存储更多的元素，使得查询的IO次数更少。</li>\n<li>所有查询都要查找到子节点，查询性能稳定。</li>\n<li>所有叶子节点形成有序链表，便于范围查询。</li>\n</ol>\n<h2 id=\"最左匹配原则\"><a href=\"#最左匹配原则\" class=\"headerlink\" title=\"最左匹配原则\"></a>最左匹配原则</h2><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gay93ok47nj30sz0gj45e.jpg\" alt></p>\n<h2 id=\"联合索引\"><a href=\"#联合索引\" class=\"headerlink\" title=\"联合索引\"></a>联合索引</h2><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gay94rzzm0j30sy0ef47q.jpg\" alt></p>\n<h2 id=\"覆盖索引\"><a href=\"#覆盖索引\" class=\"headerlink\" title=\"覆盖索引\"></a>覆盖索引</h2><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gay95n2xzmj30sp0i4gyc.jpg\" alt></p>"},{"title":"ConcurrentHashMap底层实现","date":"2019-03-19T14:54:49.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## Segment\n\nSegment本身就相当于一个HashMap对象，同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。像这样的Segment对象，在ConcurrentHashMap集合中有2的N次方个，共同保存在一个名为segments的数组当中。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaza7kcjxqj30kw0bsgn7.jpg)\n\n<!-- More -->\n\n可以说，ConcurrentHashMap是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。这样的二级结构，和数据库的水平拆分有些相似。\n\nConcurrentHashMap优势就是采用了[锁分段]技术，每一个Segment就好比一个自治区，读写操作高度自治，Segment之间互不影响。\n\n### 并发读写的情况\n\n1. 不同Segment的并发写入——**可以并发执行**\n\n   ![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazahwt8gmj30hs083jrj.jpg)\n\n2. 同一Segment的一写一读——**可以并发执行**\n\n   ![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazai5be4aj30jv07wgmh.jpg)\n\n3. 同一Segment的并发写入——**会发生阻塞**\n\n   ![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazaicuv2mj30k1081q3s.jpg)\n\nSegment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞。\n\n由此可见，ConcurrentHashMap当中每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。\n\n## ConcurrentHashMap读写过程\n\n### Get方法\n\n1. 为输入的Key做Hash运算，得到hash值。\n2. 通过hash值，定位到对应的Segment对象\n3. 再次通过hash值，定位到Segment当中数组的具体位置。\n\n### Put方法\n\n1. 为输入的Key做Hash运算，得到hash值。\n2. 通过hash值，定位到对应的Segment对象\n3. 获取可重入锁\n4. 再次通过hash值，定位到Segment当中数组的具体位置。\n5. 插入或覆盖HashEntry对象。\n6. 释放锁。\n\n**从步骤中可以看出，ConcurrentHashMap在读写时都需要二次定位。首先定位到Segment，然后定位到Segment内的具体数组下标。**\n\n## ConcurrentHashMap的Size方法\n\n### 实现逻辑\n\nConcurrentHashMap的Size方法是一个嵌套循环，大体逻辑如下：\n\n1. 遍历所有的Segment。\n2. 把Segment的元素数量累加起来。\n3. 把Segment的修改次数累加起来。\n4. 判断所有Segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。\n5. 如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计。\n6. 再次判断所有Segment的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。\n7. 释放锁，统计结束。\n\n### 官方代码\n\n```java\npublic int size() {\n    // Try a few times to get accurate count. On failure due to\n   // continuous async changes in table, resort to locking.\n   final Segment<K,V>[] segments = this.segments;\n    int size;\n    boolean overflow; // true if size overflows 32 bits\n    long sum;         // sum of modCounts\n    long last = 0L;   // previous sum\n    int retries = -1; // first iteration isn't retry\n    try {\n        for (;;) {\n            if (retries++ == RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j < segments.length; ++j)\n                    ensureSegment(j).lock(); // force creation\n            }\n            sum = 0L;\n            size = 0;\n            overflow = false;\n            for (int j = 0; j < segments.length; ++j) {\n                Segment<K,V> seg = segmentAt(segments, j);\n                if (seg != null) {\n                    sum += seg.modCount;\n                    int c = seg.count;\n                    if (c < 0 || (size += c) < 0)\n                        overflow = true;\n                }\n            }\n            if (sum == last)\n                break;\n            last = sum;\n        }\n    } finally {\n        if (retries > RETRIES_BEFORE_LOCK) {\n            for (int j = 0; j < segments.length; ++j)\n                segmentAt(segments, j).unlock();\n        }\n    }\n    return overflow ? Integer.MAX_VALUE : size;\n}\n```\n\n### 设计思想\n\n这种思想和乐观锁悲观锁的思想如出一辙。\n\n为了尽量不锁住所有Segment，首先乐观地假设Size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment保证强一致性。\n\n## ConcurrentHashMap的扩容机制\n\n当ConcurrentHashMap中元素的数量达到cap * loadFactor时，就需要进行扩容。扩容主要通过transfer()方法进行，当有线程进行put操作时，如果正在进行扩容，可以通过helpTransfer()方法加入扩容。也就是说，ConcurrentHashMap支持多线程扩容，多个线程处理不同的节点。\n\n## JDK1.8下做了哪些优化\n\n### 优势\n\nJDK1.8 放弃了分段锁Segment而是用了Node，采用了 CAS + synchronized 来保证并发安全性，降低锁的粒度，提高性能，并使用CAS操作来确保Node的一些操作的原子性，取代了锁。\n\n### 缺陷\n\nConcurrentHashMap的一些操作使用了synchronized锁，而不是ReentrantLock,虽然说JDK1.8的synchronized的性能进行了优化，但是我觉得还是使用ReentrantLock锁能更多的提高性能。\n\n","source":"_posts/ConcurrentHashMap.md","raw":"---\ntitle: ConcurrentHashMap底层实现\ndate: 2019-03-19 22:54:49\ncategories: \n  - Java\n  - 数据结构\ntags:\n  - 数据结构\n  - 高并发\n  - ConcurrentHashMap\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## Segment\n\nSegment本身就相当于一个HashMap对象，同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。像这样的Segment对象，在ConcurrentHashMap集合中有2的N次方个，共同保存在一个名为segments的数组当中。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaza7kcjxqj30kw0bsgn7.jpg)\n\n<!-- More -->\n\n可以说，ConcurrentHashMap是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。这样的二级结构，和数据库的水平拆分有些相似。\n\nConcurrentHashMap优势就是采用了[锁分段]技术，每一个Segment就好比一个自治区，读写操作高度自治，Segment之间互不影响。\n\n### 并发读写的情况\n\n1. 不同Segment的并发写入——**可以并发执行**\n\n   ![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazahwt8gmj30hs083jrj.jpg)\n\n2. 同一Segment的一写一读——**可以并发执行**\n\n   ![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazai5be4aj30jv07wgmh.jpg)\n\n3. 同一Segment的并发写入——**会发生阻塞**\n\n   ![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazaicuv2mj30k1081q3s.jpg)\n\nSegment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞。\n\n由此可见，ConcurrentHashMap当中每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。\n\n## ConcurrentHashMap读写过程\n\n### Get方法\n\n1. 为输入的Key做Hash运算，得到hash值。\n2. 通过hash值，定位到对应的Segment对象\n3. 再次通过hash值，定位到Segment当中数组的具体位置。\n\n### Put方法\n\n1. 为输入的Key做Hash运算，得到hash值。\n2. 通过hash值，定位到对应的Segment对象\n3. 获取可重入锁\n4. 再次通过hash值，定位到Segment当中数组的具体位置。\n5. 插入或覆盖HashEntry对象。\n6. 释放锁。\n\n**从步骤中可以看出，ConcurrentHashMap在读写时都需要二次定位。首先定位到Segment，然后定位到Segment内的具体数组下标。**\n\n## ConcurrentHashMap的Size方法\n\n### 实现逻辑\n\nConcurrentHashMap的Size方法是一个嵌套循环，大体逻辑如下：\n\n1. 遍历所有的Segment。\n2. 把Segment的元素数量累加起来。\n3. 把Segment的修改次数累加起来。\n4. 判断所有Segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。\n5. 如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计。\n6. 再次判断所有Segment的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。\n7. 释放锁，统计结束。\n\n### 官方代码\n\n```java\npublic int size() {\n    // Try a few times to get accurate count. On failure due to\n   // continuous async changes in table, resort to locking.\n   final Segment<K,V>[] segments = this.segments;\n    int size;\n    boolean overflow; // true if size overflows 32 bits\n    long sum;         // sum of modCounts\n    long last = 0L;   // previous sum\n    int retries = -1; // first iteration isn't retry\n    try {\n        for (;;) {\n            if (retries++ == RETRIES_BEFORE_LOCK) {\n                for (int j = 0; j < segments.length; ++j)\n                    ensureSegment(j).lock(); // force creation\n            }\n            sum = 0L;\n            size = 0;\n            overflow = false;\n            for (int j = 0; j < segments.length; ++j) {\n                Segment<K,V> seg = segmentAt(segments, j);\n                if (seg != null) {\n                    sum += seg.modCount;\n                    int c = seg.count;\n                    if (c < 0 || (size += c) < 0)\n                        overflow = true;\n                }\n            }\n            if (sum == last)\n                break;\n            last = sum;\n        }\n    } finally {\n        if (retries > RETRIES_BEFORE_LOCK) {\n            for (int j = 0; j < segments.length; ++j)\n                segmentAt(segments, j).unlock();\n        }\n    }\n    return overflow ? Integer.MAX_VALUE : size;\n}\n```\n\n### 设计思想\n\n这种思想和乐观锁悲观锁的思想如出一辙。\n\n为了尽量不锁住所有Segment，首先乐观地假设Size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment保证强一致性。\n\n## ConcurrentHashMap的扩容机制\n\n当ConcurrentHashMap中元素的数量达到cap * loadFactor时，就需要进行扩容。扩容主要通过transfer()方法进行，当有线程进行put操作时，如果正在进行扩容，可以通过helpTransfer()方法加入扩容。也就是说，ConcurrentHashMap支持多线程扩容，多个线程处理不同的节点。\n\n## JDK1.8下做了哪些优化\n\n### 优势\n\nJDK1.8 放弃了分段锁Segment而是用了Node，采用了 CAS + synchronized 来保证并发安全性，降低锁的粒度，提高性能，并使用CAS操作来确保Node的一些操作的原子性，取代了锁。\n\n### 缺陷\n\nConcurrentHashMap的一些操作使用了synchronized锁，而不是ReentrantLock,虽然说JDK1.8的synchronized的性能进行了优化，但是我觉得还是使用ReentrantLock锁能更多的提高性能。\n\n","slug":"ConcurrentHashMap","published":1,"updated":"2020-01-17T05:09:34.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bi90002a6ybrrqva6fd","content":"<h2 id=\"Segment\"><a href=\"#Segment\" class=\"headerlink\" title=\"Segment\"></a>Segment</h2><p>Segment本身就相当于一个HashMap对象，同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。像这样的Segment对象，在ConcurrentHashMap集合中有2的N次方个，共同保存在一个名为segments的数组当中。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaza7kcjxqj30kw0bsgn7.jpg\" alt></p>\n<a id=\"more\"></a>\n\n<p>可以说，ConcurrentHashMap是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。这样的二级结构，和数据库的水平拆分有些相似。</p>\n<p>ConcurrentHashMap优势就是采用了[锁分段]技术，每一个Segment就好比一个自治区，读写操作高度自治，Segment之间互不影响。</p>\n<h3 id=\"并发读写的情况\"><a href=\"#并发读写的情况\" class=\"headerlink\" title=\"并发读写的情况\"></a>并发读写的情况</h3><ol>\n<li><p>不同Segment的并发写入——<strong>可以并发执行</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazahwt8gmj30hs083jrj.jpg\" alt></p>\n</li>\n<li><p>同一Segment的一写一读——<strong>可以并发执行</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazai5be4aj30jv07wgmh.jpg\" alt></p>\n</li>\n<li><p>同一Segment的并发写入——<strong>会发生阻塞</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazaicuv2mj30k1081q3s.jpg\" alt></p>\n</li>\n</ol>\n<p>Segment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞。</p>\n<p>由此可见，ConcurrentHashMap当中每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。</p>\n<h2 id=\"ConcurrentHashMap读写过程\"><a href=\"#ConcurrentHashMap读写过程\" class=\"headerlink\" title=\"ConcurrentHashMap读写过程\"></a>ConcurrentHashMap读写过程</h2><h3 id=\"Get方法\"><a href=\"#Get方法\" class=\"headerlink\" title=\"Get方法\"></a>Get方法</h3><ol>\n<li>为输入的Key做Hash运算，得到hash值。</li>\n<li>通过hash值，定位到对应的Segment对象</li>\n<li>再次通过hash值，定位到Segment当中数组的具体位置。</li>\n</ol>\n<h3 id=\"Put方法\"><a href=\"#Put方法\" class=\"headerlink\" title=\"Put方法\"></a>Put方法</h3><ol>\n<li>为输入的Key做Hash运算，得到hash值。</li>\n<li>通过hash值，定位到对应的Segment对象</li>\n<li>获取可重入锁</li>\n<li>再次通过hash值，定位到Segment当中数组的具体位置。</li>\n<li>插入或覆盖HashEntry对象。</li>\n<li>释放锁。</li>\n</ol>\n<p><strong>从步骤中可以看出，ConcurrentHashMap在读写时都需要二次定位。首先定位到Segment，然后定位到Segment内的具体数组下标。</strong></p>\n<h2 id=\"ConcurrentHashMap的Size方法\"><a href=\"#ConcurrentHashMap的Size方法\" class=\"headerlink\" title=\"ConcurrentHashMap的Size方法\"></a>ConcurrentHashMap的Size方法</h2><h3 id=\"实现逻辑\"><a href=\"#实现逻辑\" class=\"headerlink\" title=\"实现逻辑\"></a>实现逻辑</h3><p>ConcurrentHashMap的Size方法是一个嵌套循环，大体逻辑如下：</p>\n<ol>\n<li>遍历所有的Segment。</li>\n<li>把Segment的元素数量累加起来。</li>\n<li>把Segment的修改次数累加起来。</li>\n<li>判断所有Segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。</li>\n<li>如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计。</li>\n<li>再次判断所有Segment的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。</li>\n<li>释放锁，统计结束。</li>\n</ol>\n<h3 id=\"官方代码\"><a href=\"#官方代码\" class=\"headerlink\" title=\"官方代码\"></a>官方代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Try a few times to get accurate count. On failure due to</span></span><br><span class=\"line\">   <span class=\"comment\">// continuous async changes in table, resort to locking.</span></span><br><span class=\"line\">   <span class=\"keyword\">final</span> Segment&lt;K,V&gt;[] segments = <span class=\"keyword\">this</span>.segments;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> overflow; <span class=\"comment\">// true if size overflows 32 bits</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> sum;         <span class=\"comment\">// sum of modCounts</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> last = <span class=\"number\">0L</span>;   <span class=\"comment\">// previous sum</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> retries = -<span class=\"number\">1</span>; <span class=\"comment\">// first iteration isn't retry</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j)</span><br><span class=\"line\">                    ensureSegment(j).lock(); <span class=\"comment\">// force creation</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sum = <span class=\"number\">0L</span>;</span><br><span class=\"line\">            size = <span class=\"number\">0</span>;</span><br><span class=\"line\">            overflow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class=\"line\">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (seg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    sum += seg.modCount;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> c = seg.count;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span> || (size += c) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                        overflow = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum == last)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            last = sum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j)</span><br><span class=\"line\">                segmentAt(segments, j).unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h3><p>这种思想和乐观锁悲观锁的思想如出一辙。</p>\n<p>为了尽量不锁住所有Segment，首先乐观地假设Size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment保证强一致性。</p>\n<h2 id=\"ConcurrentHashMap的扩容机制\"><a href=\"#ConcurrentHashMap的扩容机制\" class=\"headerlink\" title=\"ConcurrentHashMap的扩容机制\"></a>ConcurrentHashMap的扩容机制</h2><p>当ConcurrentHashMap中元素的数量达到cap * loadFactor时，就需要进行扩容。扩容主要通过transfer()方法进行，当有线程进行put操作时，如果正在进行扩容，可以通过helpTransfer()方法加入扩容。也就是说，ConcurrentHashMap支持多线程扩容，多个线程处理不同的节点。</p>\n<h2 id=\"JDK1-8下做了哪些优化\"><a href=\"#JDK1-8下做了哪些优化\" class=\"headerlink\" title=\"JDK1.8下做了哪些优化\"></a>JDK1.8下做了哪些优化</h2><h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>JDK1.8 放弃了分段锁Segment而是用了Node，采用了 CAS + synchronized 来保证并发安全性，降低锁的粒度，提高性能，并使用CAS操作来确保Node的一些操作的原子性，取代了锁。</p>\n<h3 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h3><p>ConcurrentHashMap的一些操作使用了synchronized锁，而不是ReentrantLock,虽然说JDK1.8的synchronized的性能进行了优化，但是我觉得还是使用ReentrantLock锁能更多的提高性能。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Segment\"><a href=\"#Segment\" class=\"headerlink\" title=\"Segment\"></a>Segment</h2><p>Segment本身就相当于一个HashMap对象，同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。像这样的Segment对象，在ConcurrentHashMap集合中有2的N次方个，共同保存在一个名为segments的数组当中。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaza7kcjxqj30kw0bsgn7.jpg\" alt></p>","more":"<p>可以说，ConcurrentHashMap是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。这样的二级结构，和数据库的水平拆分有些相似。</p>\n<p>ConcurrentHashMap优势就是采用了[锁分段]技术，每一个Segment就好比一个自治区，读写操作高度自治，Segment之间互不影响。</p>\n<h3 id=\"并发读写的情况\"><a href=\"#并发读写的情况\" class=\"headerlink\" title=\"并发读写的情况\"></a>并发读写的情况</h3><ol>\n<li><p>不同Segment的并发写入——<strong>可以并发执行</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazahwt8gmj30hs083jrj.jpg\" alt></p>\n</li>\n<li><p>同一Segment的一写一读——<strong>可以并发执行</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazai5be4aj30jv07wgmh.jpg\" alt></p>\n</li>\n<li><p>同一Segment的并发写入——<strong>会发生阻塞</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazaicuv2mj30k1081q3s.jpg\" alt></p>\n</li>\n</ol>\n<p>Segment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞。</p>\n<p>由此可见，ConcurrentHashMap当中每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。</p>\n<h2 id=\"ConcurrentHashMap读写过程\"><a href=\"#ConcurrentHashMap读写过程\" class=\"headerlink\" title=\"ConcurrentHashMap读写过程\"></a>ConcurrentHashMap读写过程</h2><h3 id=\"Get方法\"><a href=\"#Get方法\" class=\"headerlink\" title=\"Get方法\"></a>Get方法</h3><ol>\n<li>为输入的Key做Hash运算，得到hash值。</li>\n<li>通过hash值，定位到对应的Segment对象</li>\n<li>再次通过hash值，定位到Segment当中数组的具体位置。</li>\n</ol>\n<h3 id=\"Put方法\"><a href=\"#Put方法\" class=\"headerlink\" title=\"Put方法\"></a>Put方法</h3><ol>\n<li>为输入的Key做Hash运算，得到hash值。</li>\n<li>通过hash值，定位到对应的Segment对象</li>\n<li>获取可重入锁</li>\n<li>再次通过hash值，定位到Segment当中数组的具体位置。</li>\n<li>插入或覆盖HashEntry对象。</li>\n<li>释放锁。</li>\n</ol>\n<p><strong>从步骤中可以看出，ConcurrentHashMap在读写时都需要二次定位。首先定位到Segment，然后定位到Segment内的具体数组下标。</strong></p>\n<h2 id=\"ConcurrentHashMap的Size方法\"><a href=\"#ConcurrentHashMap的Size方法\" class=\"headerlink\" title=\"ConcurrentHashMap的Size方法\"></a>ConcurrentHashMap的Size方法</h2><h3 id=\"实现逻辑\"><a href=\"#实现逻辑\" class=\"headerlink\" title=\"实现逻辑\"></a>实现逻辑</h3><p>ConcurrentHashMap的Size方法是一个嵌套循环，大体逻辑如下：</p>\n<ol>\n<li>遍历所有的Segment。</li>\n<li>把Segment的元素数量累加起来。</li>\n<li>把Segment的修改次数累加起来。</li>\n<li>判断所有Segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。</li>\n<li>如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计。</li>\n<li>再次判断所有Segment的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。</li>\n<li>释放锁，统计结束。</li>\n</ol>\n<h3 id=\"官方代码\"><a href=\"#官方代码\" class=\"headerlink\" title=\"官方代码\"></a>官方代码</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Try a few times to get accurate count. On failure due to</span></span><br><span class=\"line\">   <span class=\"comment\">// continuous async changes in table, resort to locking.</span></span><br><span class=\"line\">   <span class=\"keyword\">final</span> Segment&lt;K,V&gt;[] segments = <span class=\"keyword\">this</span>.segments;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> overflow; <span class=\"comment\">// true if size overflows 32 bits</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> sum;         <span class=\"comment\">// sum of modCounts</span></span><br><span class=\"line\">    <span class=\"keyword\">long</span> last = <span class=\"number\">0L</span>;   <span class=\"comment\">// previous sum</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> retries = -<span class=\"number\">1</span>; <span class=\"comment\">// first iteration isn't retry</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j)</span><br><span class=\"line\">                    ensureSegment(j).lock(); <span class=\"comment\">// force creation</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sum = <span class=\"number\">0L</span>;</span><br><span class=\"line\">            size = <span class=\"number\">0</span>;</span><br><span class=\"line\">            overflow = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class=\"line\">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (seg != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    sum += seg.modCount;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> c = seg.count;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (c &lt; <span class=\"number\">0</span> || (size += c) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                        overflow = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum == last)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            last = sum;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; segments.length; ++j)</span><br><span class=\"line\">                segmentAt(segments, j).unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"设计思想\"><a href=\"#设计思想\" class=\"headerlink\" title=\"设计思想\"></a>设计思想</h3><p>这种思想和乐观锁悲观锁的思想如出一辙。</p>\n<p>为了尽量不锁住所有Segment，首先乐观地假设Size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment保证强一致性。</p>\n<h2 id=\"ConcurrentHashMap的扩容机制\"><a href=\"#ConcurrentHashMap的扩容机制\" class=\"headerlink\" title=\"ConcurrentHashMap的扩容机制\"></a>ConcurrentHashMap的扩容机制</h2><p>当ConcurrentHashMap中元素的数量达到cap * loadFactor时，就需要进行扩容。扩容主要通过transfer()方法进行，当有线程进行put操作时，如果正在进行扩容，可以通过helpTransfer()方法加入扩容。也就是说，ConcurrentHashMap支持多线程扩容，多个线程处理不同的节点。</p>\n<h2 id=\"JDK1-8下做了哪些优化\"><a href=\"#JDK1-8下做了哪些优化\" class=\"headerlink\" title=\"JDK1.8下做了哪些优化\"></a>JDK1.8下做了哪些优化</h2><h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>JDK1.8 放弃了分段锁Segment而是用了Node，采用了 CAS + synchronized 来保证并发安全性，降低锁的粒度，提高性能，并使用CAS操作来确保Node的一些操作的原子性，取代了锁。</p>\n<h3 id=\"缺陷\"><a href=\"#缺陷\" class=\"headerlink\" title=\"缺陷\"></a>缺陷</h3><p>ConcurrentHashMap的一些操作使用了synchronized锁，而不是ReentrantLock,虽然说JDK1.8的synchronized的性能进行了优化，但是我觉得还是使用ReentrantLock锁能更多的提高性能。</p>"},{"title":"HashMap底层原理","date":"2019-03-18T13:54:59.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## HashMap的底层原理\n\nHashMap是一个用于存储key-value键值对的集合，每一个键值对也叫做Entry。数组中的每一个Entry元素，又是一个链表的头节点。这些键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。\n\nHashmap不是线程安全的。在高并发环境下做插入操作，有可能出现环形链表。HashMap数组每一个元素的初始值都是Null，最常使用的两个方法是Put和Get。\n\n### Put方法的原理\n\n比如调用 hashMap.put(\"apple\", 0) ，插入一个Key为“apple\"的元素。这时候我们需要利用一个哈希函数：**index = Hash（“apple”）**来确定Entry的插入位置（index），但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。<!-- More -->\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9a1hu4j30ji06fq3g.jpg)\n\n这时我们可以通过**链表**来解决。需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”，因为HashMap的发明者认为：**后插入的Entry被查找的可能性更大**。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9i7blpj30ju06wjrw.jpg)\n\n### Get方法的原理\n\n首先会把需要查询的key做一次Hash映射，得到对应的下标，由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gayreaylimj30jf07tt9n.jpg)\n\n## HashMap的特点\n\n### HashMap的默认初始长度\n\nHashMap的默认初始长度是16，并且每次自动扩展或是手动初始化时，长度必须是2的幂。\n\n### 为什么这样设置？\n\n为了使Hash算法得到的index尽可能均匀分布。例如从Key映射到HashMap数组的对应位置时，会用到一个Hash函数：**index = HashCode（Key） & （Length - 1）**，为了实现高效的Hash算法，采用位运算（与运算）\n\n## 高并发下的HashMap\n\n### Resize\n\nHashMap的容量是有限的，当经过多次元素插入，使得HashMap达到一定饱和度时，key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行**Resize**。\n\n### 影响Resize的两个因素\n\n1. Capacity\n\n   HashMap的当前长度。\n\n2. LoadFactor\n\n   HashMap负载因子，默认值为0.75f。\n\n衡量HashMap是否需要进行Resize的条件如下：\n\n**HashMap.Size  >= Capacity \\* LoadFactor**\n\n### Resize做了什么？\n\n1. 扩容\n\n   创建一个新的Entry空数组，长度是原数组的2倍。\n\n2. Rehash\n\n   遍历原Entry数组，把所有的Entry重新Hash到新数组。\n\n**为什么要重新Hash呢？**\n\n因为长度扩大以后，Hash的规则也随之改变。（16=1111；32=11111）\n\n**ReHash的Java代码如下：**\n\n```java\nvoid transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n    for (Entry<K,V> e : table) {\n        while(null != e) {\n            Entry<K,V> next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n```\n\n### 为什么HashMap会出现死锁\n\n在高并发情况下，如果HashMap正好达到临界点准备扩容，此时正好有两个线程在同时访问，在Rehash时链表可能会产生环形，当调用Get查找一个不存在的key，而这个key的Hash结果恰好位于环形链表处，这时程序将会进入死循环。\n\n## JDK1.8下的HashMap优化\n\n### 引入红黑树\n\n我们知道，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦拉链过长则会严重影响HashMap的性能，所以JDK1.8版本引入了红黑树：当链表长度太长（默认超过8）时，链表就转为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。\n\n### Resize扩容优化\n\n我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。","source":"_posts/HashMap.md","raw":"---\ntitle: HashMap底层原理\ndate: 2019-03-18 21:54:59\ncategories: \n  - Java\n  - 数据结构\ntags: \n  - 数据结构\n  - HashMap\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## HashMap的底层原理\n\nHashMap是一个用于存储key-value键值对的集合，每一个键值对也叫做Entry。数组中的每一个Entry元素，又是一个链表的头节点。这些键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。\n\nHashmap不是线程安全的。在高并发环境下做插入操作，有可能出现环形链表。HashMap数组每一个元素的初始值都是Null，最常使用的两个方法是Put和Get。\n\n### Put方法的原理\n\n比如调用 hashMap.put(\"apple\", 0) ，插入一个Key为“apple\"的元素。这时候我们需要利用一个哈希函数：**index = Hash（“apple”）**来确定Entry的插入位置（index），但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。<!-- More -->\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9a1hu4j30ji06fq3g.jpg)\n\n这时我们可以通过**链表**来解决。需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”，因为HashMap的发明者认为：**后插入的Entry被查找的可能性更大**。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9i7blpj30ju06wjrw.jpg)\n\n### Get方法的原理\n\n首先会把需要查询的key做一次Hash映射，得到对应的下标，由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gayreaylimj30jf07tt9n.jpg)\n\n## HashMap的特点\n\n### HashMap的默认初始长度\n\nHashMap的默认初始长度是16，并且每次自动扩展或是手动初始化时，长度必须是2的幂。\n\n### 为什么这样设置？\n\n为了使Hash算法得到的index尽可能均匀分布。例如从Key映射到HashMap数组的对应位置时，会用到一个Hash函数：**index = HashCode（Key） & （Length - 1）**，为了实现高效的Hash算法，采用位运算（与运算）\n\n## 高并发下的HashMap\n\n### Resize\n\nHashMap的容量是有限的，当经过多次元素插入，使得HashMap达到一定饱和度时，key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行**Resize**。\n\n### 影响Resize的两个因素\n\n1. Capacity\n\n   HashMap的当前长度。\n\n2. LoadFactor\n\n   HashMap负载因子，默认值为0.75f。\n\n衡量HashMap是否需要进行Resize的条件如下：\n\n**HashMap.Size  >= Capacity \\* LoadFactor**\n\n### Resize做了什么？\n\n1. 扩容\n\n   创建一个新的Entry空数组，长度是原数组的2倍。\n\n2. Rehash\n\n   遍历原Entry数组，把所有的Entry重新Hash到新数组。\n\n**为什么要重新Hash呢？**\n\n因为长度扩大以后，Hash的规则也随之改变。（16=1111；32=11111）\n\n**ReHash的Java代码如下：**\n\n```java\nvoid transfer(Entry[] newTable, boolean rehash) {\n    int newCapacity = newTable.length;\n    for (Entry<K,V> e : table) {\n        while(null != e) {\n            Entry<K,V> next = e.next;\n            if (rehash) {\n                e.hash = null == e.key ? 0 : hash(e.key);\n            }\n            int i = indexFor(e.hash, newCapacity);\n            e.next = newTable[i];\n            newTable[i] = e;\n            e = next;\n        }\n    }\n}\n```\n\n### 为什么HashMap会出现死锁\n\n在高并发情况下，如果HashMap正好达到临界点准备扩容，此时正好有两个线程在同时访问，在Rehash时链表可能会产生环形，当调用Get查找一个不存在的key，而这个key的Hash结果恰好位于环形链表处，这时程序将会进入死循环。\n\n## JDK1.8下的HashMap优化\n\n### 引入红黑树\n\n我们知道，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦拉链过长则会严重影响HashMap的性能，所以JDK1.8版本引入了红黑树：当链表长度太长（默认超过8）时，链表就转为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。\n\n### Resize扩容优化\n\n我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。","slug":"HashMap","published":1,"updated":"2020-01-17T05:07:33.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bid0005a6ybbvaxq4lc","content":"<h2 id=\"HashMap的底层原理\"><a href=\"#HashMap的底层原理\" class=\"headerlink\" title=\"HashMap的底层原理\"></a>HashMap的底层原理</h2><p>HashMap是一个用于存储key-value键值对的集合，每一个键值对也叫做Entry。数组中的每一个Entry元素，又是一个链表的头节点。这些键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。</p>\n<p>Hashmap不是线程安全的。在高并发环境下做插入操作，有可能出现环形链表。HashMap数组每一个元素的初始值都是Null，最常使用的两个方法是Put和Get。</p>\n<h3 id=\"Put方法的原理\"><a href=\"#Put方法的原理\" class=\"headerlink\" title=\"Put方法的原理\"></a>Put方法的原理</h3><p>比如调用 hashMap.put(“apple”, 0) ，插入一个Key为“apple”的元素。这时候我们需要利用一个哈希函数：<strong>index = Hash（“apple”）</strong>来确定Entry的插入位置（index），但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。<a id=\"more\"></a></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9a1hu4j30ji06fq3g.jpg\" alt></p>\n<p>这时我们可以通过<strong>链表</strong>来解决。需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”，因为HashMap的发明者认为：<strong>后插入的Entry被查找的可能性更大</strong>。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9i7blpj30ju06wjrw.jpg\" alt></p>\n<h3 id=\"Get方法的原理\"><a href=\"#Get方法的原理\" class=\"headerlink\" title=\"Get方法的原理\"></a>Get方法的原理</h3><p>首先会把需要查询的key做一次Hash映射，得到对应的下标，由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gayreaylimj30jf07tt9n.jpg\" alt></p>\n<h2 id=\"HashMap的特点\"><a href=\"#HashMap的特点\" class=\"headerlink\" title=\"HashMap的特点\"></a>HashMap的特点</h2><h3 id=\"HashMap的默认初始长度\"><a href=\"#HashMap的默认初始长度\" class=\"headerlink\" title=\"HashMap的默认初始长度\"></a>HashMap的默认初始长度</h3><p>HashMap的默认初始长度是16，并且每次自动扩展或是手动初始化时，长度必须是2的幂。</p>\n<h3 id=\"为什么这样设置？\"><a href=\"#为什么这样设置？\" class=\"headerlink\" title=\"为什么这样设置？\"></a>为什么这样设置？</h3><p>为了使Hash算法得到的index尽可能均匀分布。例如从Key映射到HashMap数组的对应位置时，会用到一个Hash函数：<strong>index = HashCode（Key） &amp; （Length - 1）</strong>，为了实现高效的Hash算法，采用位运算（与运算）</p>\n<h2 id=\"高并发下的HashMap\"><a href=\"#高并发下的HashMap\" class=\"headerlink\" title=\"高并发下的HashMap\"></a>高并发下的HashMap</h2><h3 id=\"Resize\"><a href=\"#Resize\" class=\"headerlink\" title=\"Resize\"></a>Resize</h3><p>HashMap的容量是有限的，当经过多次元素插入，使得HashMap达到一定饱和度时，key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行<strong>Resize</strong>。</p>\n<h3 id=\"影响Resize的两个因素\"><a href=\"#影响Resize的两个因素\" class=\"headerlink\" title=\"影响Resize的两个因素\"></a>影响Resize的两个因素</h3><ol>\n<li><p>Capacity</p>\n<p>HashMap的当前长度。</p>\n</li>\n<li><p>LoadFactor</p>\n<p>HashMap负载因子，默认值为0.75f。</p>\n</li>\n</ol>\n<p>衡量HashMap是否需要进行Resize的条件如下：</p>\n<p><strong>HashMap.Size  &gt;= Capacity * LoadFactor</strong></p>\n<h3 id=\"Resize做了什么？\"><a href=\"#Resize做了什么？\" class=\"headerlink\" title=\"Resize做了什么？\"></a>Resize做了什么？</h3><ol>\n<li><p>扩容</p>\n<p>创建一个新的Entry空数组，长度是原数组的2倍。</p>\n</li>\n<li><p>Rehash</p>\n<p>遍历原Entry数组，把所有的Entry重新Hash到新数组。</p>\n</li>\n</ol>\n<p><strong>为什么要重新Hash呢？</strong></p>\n<p>因为长度扩大以后，Hash的规则也随之改变。（16=1111；32=11111）</p>\n<p><strong>ReHash的Java代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable, <span class=\"keyword\">boolean</span> rehash)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = newTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">null</span> != e) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rehash) &#123;</span><br><span class=\"line\">                e.hash = <span class=\"keyword\">null</span> == e.key ? <span class=\"number\">0</span> : hash(e.key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class=\"line\">            e.next = newTable[i];</span><br><span class=\"line\">            newTable[i] = e;</span><br><span class=\"line\">            e = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么HashMap会出现死锁\"><a href=\"#为什么HashMap会出现死锁\" class=\"headerlink\" title=\"为什么HashMap会出现死锁\"></a>为什么HashMap会出现死锁</h3><p>在高并发情况下，如果HashMap正好达到临界点准备扩容，此时正好有两个线程在同时访问，在Rehash时链表可能会产生环形，当调用Get查找一个不存在的key，而这个key的Hash结果恰好位于环形链表处，这时程序将会进入死循环。</p>\n<h2 id=\"JDK1-8下的HashMap优化\"><a href=\"#JDK1-8下的HashMap优化\" class=\"headerlink\" title=\"JDK1.8下的HashMap优化\"></a>JDK1.8下的HashMap优化</h2><h3 id=\"引入红黑树\"><a href=\"#引入红黑树\" class=\"headerlink\" title=\"引入红黑树\"></a>引入红黑树</h3><p>我们知道，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦拉链过长则会严重影响HashMap的性能，所以JDK1.8版本引入了红黑树：当链表长度太长（默认超过8）时，链表就转为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。</p>\n<h3 id=\"Resize扩容优化\"><a href=\"#Resize扩容优化\" class=\"headerlink\" title=\"Resize扩容优化\"></a>Resize扩容优化</h3><p>我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"HashMap的底层原理\"><a href=\"#HashMap的底层原理\" class=\"headerlink\" title=\"HashMap的底层原理\"></a>HashMap的底层原理</h2><p>HashMap是一个用于存储key-value键值对的集合，每一个键值对也叫做Entry。数组中的每一个Entry元素，又是一个链表的头节点。这些键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。</p>\n<p>Hashmap不是线程安全的。在高并发环境下做插入操作，有可能出现环形链表。HashMap数组每一个元素的初始值都是Null，最常使用的两个方法是Put和Get。</p>\n<h3 id=\"Put方法的原理\"><a href=\"#Put方法的原理\" class=\"headerlink\" title=\"Put方法的原理\"></a>Put方法的原理</h3><p>比如调用 hashMap.put(“apple”, 0) ，插入一个Key为“apple”的元素。这时候我们需要利用一个哈希函数：<strong>index = Hash（“apple”）</strong>来确定Entry的插入位置（index），但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。","more":"</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9a1hu4j30ji06fq3g.jpg\" alt></p>\n<p>这时我们可以通过<strong>链表</strong>来解决。需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”，因为HashMap的发明者认为：<strong>后插入的Entry被查找的可能性更大</strong>。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9i7blpj30ju06wjrw.jpg\" alt></p>\n<h3 id=\"Get方法的原理\"><a href=\"#Get方法的原理\" class=\"headerlink\" title=\"Get方法的原理\"></a>Get方法的原理</h3><p>首先会把需要查询的key做一次Hash映射，得到对应的下标，由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gayreaylimj30jf07tt9n.jpg\" alt></p>\n<h2 id=\"HashMap的特点\"><a href=\"#HashMap的特点\" class=\"headerlink\" title=\"HashMap的特点\"></a>HashMap的特点</h2><h3 id=\"HashMap的默认初始长度\"><a href=\"#HashMap的默认初始长度\" class=\"headerlink\" title=\"HashMap的默认初始长度\"></a>HashMap的默认初始长度</h3><p>HashMap的默认初始长度是16，并且每次自动扩展或是手动初始化时，长度必须是2的幂。</p>\n<h3 id=\"为什么这样设置？\"><a href=\"#为什么这样设置？\" class=\"headerlink\" title=\"为什么这样设置？\"></a>为什么这样设置？</h3><p>为了使Hash算法得到的index尽可能均匀分布。例如从Key映射到HashMap数组的对应位置时，会用到一个Hash函数：<strong>index = HashCode（Key） &amp; （Length - 1）</strong>，为了实现高效的Hash算法，采用位运算（与运算）</p>\n<h2 id=\"高并发下的HashMap\"><a href=\"#高并发下的HashMap\" class=\"headerlink\" title=\"高并发下的HashMap\"></a>高并发下的HashMap</h2><h3 id=\"Resize\"><a href=\"#Resize\" class=\"headerlink\" title=\"Resize\"></a>Resize</h3><p>HashMap的容量是有限的，当经过多次元素插入，使得HashMap达到一定饱和度时，key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行<strong>Resize</strong>。</p>\n<h3 id=\"影响Resize的两个因素\"><a href=\"#影响Resize的两个因素\" class=\"headerlink\" title=\"影响Resize的两个因素\"></a>影响Resize的两个因素</h3><ol>\n<li><p>Capacity</p>\n<p>HashMap的当前长度。</p>\n</li>\n<li><p>LoadFactor</p>\n<p>HashMap负载因子，默认值为0.75f。</p>\n</li>\n</ol>\n<p>衡量HashMap是否需要进行Resize的条件如下：</p>\n<p><strong>HashMap.Size  &gt;= Capacity * LoadFactor</strong></p>\n<h3 id=\"Resize做了什么？\"><a href=\"#Resize做了什么？\" class=\"headerlink\" title=\"Resize做了什么？\"></a>Resize做了什么？</h3><ol>\n<li><p>扩容</p>\n<p>创建一个新的Entry空数组，长度是原数组的2倍。</p>\n</li>\n<li><p>Rehash</p>\n<p>遍历原Entry数组，把所有的Entry重新Hash到新数组。</p>\n</li>\n</ol>\n<p><strong>为什么要重新Hash呢？</strong></p>\n<p>因为长度扩大以后，Hash的规则也随之改变。（16=1111；32=11111）</p>\n<p><strong>ReHash的Java代码如下：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">transfer</span><span class=\"params\">(Entry[] newTable, <span class=\"keyword\">boolean</span> rehash)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> newCapacity = newTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"keyword\">null</span> != e) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rehash) &#123;</span><br><span class=\"line\">                e.hash = <span class=\"keyword\">null</span> == e.key ? <span class=\"number\">0</span> : hash(e.key);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class=\"line\">            e.next = newTable[i];</span><br><span class=\"line\">            newTable[i] = e;</span><br><span class=\"line\">            e = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"为什么HashMap会出现死锁\"><a href=\"#为什么HashMap会出现死锁\" class=\"headerlink\" title=\"为什么HashMap会出现死锁\"></a>为什么HashMap会出现死锁</h3><p>在高并发情况下，如果HashMap正好达到临界点准备扩容，此时正好有两个线程在同时访问，在Rehash时链表可能会产生环形，当调用Get查找一个不存在的key，而这个key的Hash结果恰好位于环形链表处，这时程序将会进入死循环。</p>\n<h2 id=\"JDK1-8下的HashMap优化\"><a href=\"#JDK1-8下的HashMap优化\" class=\"headerlink\" title=\"JDK1.8下的HashMap优化\"></a>JDK1.8下的HashMap优化</h2><h3 id=\"引入红黑树\"><a href=\"#引入红黑树\" class=\"headerlink\" title=\"引入红黑树\"></a>引入红黑树</h3><p>我们知道，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦拉链过长则会严重影响HashMap的性能，所以JDK1.8版本引入了红黑树：当链表长度太长（默认超过8）时，链表就转为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。</p>\n<h3 id=\"Resize扩容优化\"><a href=\"#Resize扩容优化\" class=\"headerlink\" title=\"Resize扩容优化\"></a>Resize扩容优化</h3><p>我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p>"},{"title":"链表“逆序”算法","date":"2019-06-18T14:06:48.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## 逆序本质\n\n链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。\n\n## 实现步骤\n\n1. 从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。\n2. 以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。\n3. 三个临时节点的引用分别向后移动一格位置。\n4. 重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。\n5. 重复第3步的工作，三个临时节点分别向后移动一格位置。\n6. 继续这样迭代下去，直到p2是空为止。\n7. 最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。\n\n<!-- More -->\n\n## 代码实现\n\n```java\nprivate static Node head; //这里head是静态成员，其实也可以作为方法参数传入\npublic static void reverseLinkedList(){\n  if(head==null || head.next==null){\n    return;\n  }\n  //算法实现\n  Node p1 = head;\n  Node p2 = head.next;\n  Node p3 = null;\n  while(p2!=null){\n    p3 = p2.next; //给p3赋值\n    p2.next = p1; //p2指向p1\n    p1 = p2; //给p1赋值\n    p2 = p3; //给p2赋值\n  }\n  head.next = null; //head指向null\n  head = p1; //给head赋值\n}\n\n//定义节点\nprivate static class Node{\n  int data;\n  Node next;\n  Node(int data){\n    this.data = data;\n  }\n}\npublic static void main(String[] args){\n  //初始化链表\n  head = new Node(3); //给头节点赋值\n  head.next = new Node(6); //头节点的next指向新节点6\n  \n  Node temp = head.next; //定义临时节点并赋值\n  temp.next = new Node(1); //临时节点的next指向新节点1\n  temp = temp.next; //临时节点指针后移\n  temp.next = new Node(4);\n  temp = temp.next;\n  temp.next = new Node(9);\n  \n  //输出初始化的链表\n  temp = head;\n  while(temp!=null){\n    System.out.println(temp.data);\n    temp = temp.next;\n  }\n  \n  //调用逆序链表的方法\n  reverseLinkedList();\n  \n  //输出逆序后的链表\n  temp = head;\n  while(temp!=null){\n    System.out.println(temp.data);\n    temp = temp.next;\n  }\n}\n```","source":"_posts/LinkedList-Reverse.md","raw":"---\ntitle: 链表“逆序”算法\ndate: 2019-06-18 22:06:48\ncategories: \n  - Java\n  - 算法\ntags:\n  - 算法\n  - 链表逆序算法\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## 逆序本质\n\n链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。\n\n## 实现步骤\n\n1. 从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。\n2. 以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。\n3. 三个临时节点的引用分别向后移动一格位置。\n4. 重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。\n5. 重复第3步的工作，三个临时节点分别向后移动一格位置。\n6. 继续这样迭代下去，直到p2是空为止。\n7. 最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。\n\n<!-- More -->\n\n## 代码实现\n\n```java\nprivate static Node head; //这里head是静态成员，其实也可以作为方法参数传入\npublic static void reverseLinkedList(){\n  if(head==null || head.next==null){\n    return;\n  }\n  //算法实现\n  Node p1 = head;\n  Node p2 = head.next;\n  Node p3 = null;\n  while(p2!=null){\n    p3 = p2.next; //给p3赋值\n    p2.next = p1; //p2指向p1\n    p1 = p2; //给p1赋值\n    p2 = p3; //给p2赋值\n  }\n  head.next = null; //head指向null\n  head = p1; //给head赋值\n}\n\n//定义节点\nprivate static class Node{\n  int data;\n  Node next;\n  Node(int data){\n    this.data = data;\n  }\n}\npublic static void main(String[] args){\n  //初始化链表\n  head = new Node(3); //给头节点赋值\n  head.next = new Node(6); //头节点的next指向新节点6\n  \n  Node temp = head.next; //定义临时节点并赋值\n  temp.next = new Node(1); //临时节点的next指向新节点1\n  temp = temp.next; //临时节点指针后移\n  temp.next = new Node(4);\n  temp = temp.next;\n  temp.next = new Node(9);\n  \n  //输出初始化的链表\n  temp = head;\n  while(temp!=null){\n    System.out.println(temp.data);\n    temp = temp.next;\n  }\n  \n  //调用逆序链表的方法\n  reverseLinkedList();\n  \n  //输出逆序后的链表\n  temp = head;\n  while(temp!=null){\n    System.out.println(temp.data);\n    temp = temp.next;\n  }\n}\n```","slug":"LinkedList-Reverse","published":1,"updated":"2020-01-17T05:59:38.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bie0006a6ybtctnipa3","content":"<h2 id=\"逆序本质\"><a href=\"#逆序本质\" class=\"headerlink\" title=\"逆序本质\"></a>逆序本质</h2><p>链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。</p>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><ol>\n<li>从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。</li>\n<li>以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li>\n<li>三个临时节点的引用分别向后移动一格位置。</li>\n<li>重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li>\n<li>重复第3步的工作，三个临时节点分别向后移动一格位置。</li>\n<li>继续这样迭代下去，直到p2是空为止。</li>\n<li>最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。</li>\n</ol>\n<a id=\"more\"></a>\n\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Node head; <span class=\"comment\">//这里head是静态成员，其实也可以作为方法参数传入</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">reverseLinkedList</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span> || head.next==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//算法实现</span></span><br><span class=\"line\">  Node p1 = head;</span><br><span class=\"line\">  Node p2 = head.next;</span><br><span class=\"line\">  Node p3 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(p2!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    p3 = p2.next; <span class=\"comment\">//给p3赋值</span></span><br><span class=\"line\">    p2.next = p1; <span class=\"comment\">//p2指向p1</span></span><br><span class=\"line\">    p1 = p2; <span class=\"comment\">//给p1赋值</span></span><br><span class=\"line\">    p2 = p3; <span class=\"comment\">//给p2赋值</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  head.next = <span class=\"keyword\">null</span>; <span class=\"comment\">//head指向null</span></span><br><span class=\"line\">  head = p1; <span class=\"comment\">//给head赋值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义节点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">  Node next;</span><br><span class=\"line\">  Node(<span class=\"keyword\">int</span> data)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//初始化链表</span></span><br><span class=\"line\">  head = <span class=\"keyword\">new</span> Node(<span class=\"number\">3</span>); <span class=\"comment\">//给头节点赋值</span></span><br><span class=\"line\">  head.next = <span class=\"keyword\">new</span> Node(<span class=\"number\">6</span>); <span class=\"comment\">//头节点的next指向新节点6</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  Node temp = head.next; <span class=\"comment\">//定义临时节点并赋值</span></span><br><span class=\"line\">  temp.next = <span class=\"keyword\">new</span> Node(<span class=\"number\">1</span>); <span class=\"comment\">//临时节点的next指向新节点1</span></span><br><span class=\"line\">  temp = temp.next; <span class=\"comment\">//临时节点指针后移</span></span><br><span class=\"line\">  temp.next = <span class=\"keyword\">new</span> Node(<span class=\"number\">4</span>);</span><br><span class=\"line\">  temp = temp.next;</span><br><span class=\"line\">  temp.next = <span class=\"keyword\">new</span> Node(<span class=\"number\">9</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//输出初始化的链表</span></span><br><span class=\"line\">  temp = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(temp!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(temp.data);</span><br><span class=\"line\">    temp = temp.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//调用逆序链表的方法</span></span><br><span class=\"line\">  reverseLinkedList();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//输出逆序后的链表</span></span><br><span class=\"line\">  temp = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(temp!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(temp.data);</span><br><span class=\"line\">    temp = temp.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"逆序本质\"><a href=\"#逆序本质\" class=\"headerlink\" title=\"逆序本质\"></a>逆序本质</h2><p>链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。</p>\n<h2 id=\"实现步骤\"><a href=\"#实现步骤\" class=\"headerlink\" title=\"实现步骤\"></a>实现步骤</h2><ol>\n<li>从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。</li>\n<li>以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li>\n<li>三个临时节点的引用分别向后移动一格位置。</li>\n<li>重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li>\n<li>重复第3步的工作，三个临时节点分别向后移动一格位置。</li>\n<li>继续这样迭代下去，直到p2是空为止。</li>\n<li>最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。</li>\n</ol>","more":"<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Node head; <span class=\"comment\">//这里head是静态成员，其实也可以作为方法参数传入</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">reverseLinkedList</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span> || head.next==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//算法实现</span></span><br><span class=\"line\">  Node p1 = head;</span><br><span class=\"line\">  Node p2 = head.next;</span><br><span class=\"line\">  Node p3 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(p2!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    p3 = p2.next; <span class=\"comment\">//给p3赋值</span></span><br><span class=\"line\">    p2.next = p1; <span class=\"comment\">//p2指向p1</span></span><br><span class=\"line\">    p1 = p2; <span class=\"comment\">//给p1赋值</span></span><br><span class=\"line\">    p2 = p3; <span class=\"comment\">//给p2赋值</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  head.next = <span class=\"keyword\">null</span>; <span class=\"comment\">//head指向null</span></span><br><span class=\"line\">  head = p1; <span class=\"comment\">//给head赋值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//定义节点</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Node</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> data;</span><br><span class=\"line\">  Node next;</span><br><span class=\"line\">  Node(<span class=\"keyword\">int</span> data)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.data = data;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//初始化链表</span></span><br><span class=\"line\">  head = <span class=\"keyword\">new</span> Node(<span class=\"number\">3</span>); <span class=\"comment\">//给头节点赋值</span></span><br><span class=\"line\">  head.next = <span class=\"keyword\">new</span> Node(<span class=\"number\">6</span>); <span class=\"comment\">//头节点的next指向新节点6</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  Node temp = head.next; <span class=\"comment\">//定义临时节点并赋值</span></span><br><span class=\"line\">  temp.next = <span class=\"keyword\">new</span> Node(<span class=\"number\">1</span>); <span class=\"comment\">//临时节点的next指向新节点1</span></span><br><span class=\"line\">  temp = temp.next; <span class=\"comment\">//临时节点指针后移</span></span><br><span class=\"line\">  temp.next = <span class=\"keyword\">new</span> Node(<span class=\"number\">4</span>);</span><br><span class=\"line\">  temp = temp.next;</span><br><span class=\"line\">  temp.next = <span class=\"keyword\">new</span> Node(<span class=\"number\">9</span>);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//输出初始化的链表</span></span><br><span class=\"line\">  temp = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(temp!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(temp.data);</span><br><span class=\"line\">    temp = temp.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//调用逆序链表的方法</span></span><br><span class=\"line\">  reverseLinkedList();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">//输出逆序后的链表</span></span><br><span class=\"line\">  temp = head;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(temp!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">    System.out.println(temp.data);</span><br><span class=\"line\">    temp = temp.next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"AES对称加密算法","date":"2019-07-05T15:36:05.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## AES算法的特点\n\nAES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客[《MD5底层实现和解密方法》](http://www.lishaojie.top/2019/07/04/MD5/)所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。\n\n### 密钥\n\n密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用**同一个密钥**。AES支持三种长度的密钥：**128位，192位，256位**。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。\n\n从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。\n\n<!--more-->\n\n### 填充\n\nAES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。\n\n假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行**填充**（Padding）。\n\n#### NoPadding\n\n不做任何填充，但是要求明文必须是16字节的整数倍。\n\n#### PKCS5Padding（默认）\n\n如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。\n\n比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}\n\n#### ISO10126Padding\n\n如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。\n\n比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}\n\n**注意：如果在AES加密时使用了某一种填充方式，解密的时候也必须采用同样的填充方式。**\n\n### 模式\n\nAES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。\n\n#### ECB模式（默认）\n\n电码本模式  Electronic Codebook Book\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazosrcxlxj30j60apdg3.jpg)\n\nECB模式是最简单的工作模式，在该模式下，每一个明文块的加密都是独立完成的，互不干涉。好处是简单，有利于并行计算。缺点也很明显，相同的明文块经过加密会变成相同的密文块，因此安全性较差。\n\n#### CBC模式\n\n密码分组链接模式  Cipher Block Chaining\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazou8zo61j30l40bcdgu.jpg)\n\nCBC模式引入了一个新的概念：初始向量IV（Initialization Vector），它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它**前一个明文块所加密出的密文块**相异或。这样以来，相同的明文块加密出的密文块显然是不一样的。好处是安全性更好，缺点是无法并行计算，性能上不如ECB；引入初始化向量IV，增加复杂度。\n\n#### CTR模式\n\n计算器模式  Counter（实现省略……）\n\n#### CFB模式\n\n密码反馈模式  Cipher FeedBack（实现省略……）\n\n#### OFB模式\n\n输出反馈模式  Output FeedBack（实现省略……）\n\n**注意：如果在AES加密时使用了某一种工作模式，解密的时候也必须采用同样的工作模式。**\n\n在Java代码中，如何修改不同长度的密钥和填充模式？\n\nAES算法在Java的 javax.crypto 包里有很好的封装，调用方式如下：\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazo71c7glj30f90963zq.jpg)\n\n1. kgen.init传入的第一个参数128决定了密钥的长度是**128bit**。\n2. Cipher.getInstance(\"AES/CBC/NoPadding\")决定了AES选择的填充方式是**NoPadding**，工作模式是**CBC**模式。\n\n## 补充\n\n1. 我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。\n2. 填充明文时，如果明文长度原本就是16字节的整数倍，那么除了NoPadding以外，其他的填充方式都会填充一组额外的16字节明文块。\n\n## AES加密算法底层原理\n\n### AES加密步骤\n\n1. 把明文按照128bit拆分成若干个明文块。\n2. 按照选择的填充方式来填充最后一个明文块。\n3. 每一个明文块利用AES加密器和密钥，加密成密文块。\n4. 拼接所有的密文块，成为最终的密文结果。\n\n### AES加密器需要经过多少轮加密\n\n- 初始轮（Initial Round） 1次\n- 普通轮（Rounds）     N次\n- 最终轮（Final Round）  1次\n\n上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。\n\n### 除去初始轮各种Key长度对应的轮数\n\n- AES128：10轮\n- AES192：12轮\n- AES256：14轮\n\n### 不同阶段Round的处理步骤\n\n**初始轮只有一个步骤**\n\n- 加轮密钥（AddRoundKey）\n\n**普通轮有四个步骤**\n\n- 字节代替（SubBytes）\n\n  首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为**S盒**（Subtitution Box）的16X16大小的二维常量数组。假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。\n\n- 行移位（ShiftRows）\n\n  这一步很简单，就像图中所描述的：第一行不变，第二行循环左移**1**个字节，第三行循环左移**2**个字节，第四行循环左移**3**个字节。\n\n- 列混淆（MixColumns）\n\n  这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。\n\n- 加轮密钥（AddRoundKey）\n\n  这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：**扩展密钥**（KeyExpansions）——AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。\n\n**最终轮有三个步骤**\n\n- 字节代替（SubBytes）\n- 行移位（ShiftRows）\n- 加轮密钥（AddRoundKey）\n\n## AES解密流程\n\n解密流程基本是把加密流程倒置过来，顺序变为 最终轮->普通轮->初始轮。扩展密钥的使用顺序也和加密相反。\n\n\n\n\n\n","source":"_posts/AES.md","raw":"---\ntitle: AES对称加密算法\ndate: 2019-07-05 23:36:05\ncategories: \n  - Java\n  - 算法\ntags:\n  - 算法\n  - AES算法\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## AES算法的特点\n\nAES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客[《MD5底层实现和解密方法》](http://www.lishaojie.top/2019/07/04/MD5/)所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。\n\n### 密钥\n\n密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用**同一个密钥**。AES支持三种长度的密钥：**128位，192位，256位**。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。\n\n从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。\n\n<!--more-->\n\n### 填充\n\nAES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。\n\n假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行**填充**（Padding）。\n\n#### NoPadding\n\n不做任何填充，但是要求明文必须是16字节的整数倍。\n\n#### PKCS5Padding（默认）\n\n如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。\n\n比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}\n\n#### ISO10126Padding\n\n如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。\n\n比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}\n\n**注意：如果在AES加密时使用了某一种填充方式，解密的时候也必须采用同样的填充方式。**\n\n### 模式\n\nAES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。\n\n#### ECB模式（默认）\n\n电码本模式  Electronic Codebook Book\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazosrcxlxj30j60apdg3.jpg)\n\nECB模式是最简单的工作模式，在该模式下，每一个明文块的加密都是独立完成的，互不干涉。好处是简单，有利于并行计算。缺点也很明显，相同的明文块经过加密会变成相同的密文块，因此安全性较差。\n\n#### CBC模式\n\n密码分组链接模式  Cipher Block Chaining\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazou8zo61j30l40bcdgu.jpg)\n\nCBC模式引入了一个新的概念：初始向量IV（Initialization Vector），它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它**前一个明文块所加密出的密文块**相异或。这样以来，相同的明文块加密出的密文块显然是不一样的。好处是安全性更好，缺点是无法并行计算，性能上不如ECB；引入初始化向量IV，增加复杂度。\n\n#### CTR模式\n\n计算器模式  Counter（实现省略……）\n\n#### CFB模式\n\n密码反馈模式  Cipher FeedBack（实现省略……）\n\n#### OFB模式\n\n输出反馈模式  Output FeedBack（实现省略……）\n\n**注意：如果在AES加密时使用了某一种工作模式，解密的时候也必须采用同样的工作模式。**\n\n在Java代码中，如何修改不同长度的密钥和填充模式？\n\nAES算法在Java的 javax.crypto 包里有很好的封装，调用方式如下：\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazo71c7glj30f90963zq.jpg)\n\n1. kgen.init传入的第一个参数128决定了密钥的长度是**128bit**。\n2. Cipher.getInstance(\"AES/CBC/NoPadding\")决定了AES选择的填充方式是**NoPadding**，工作模式是**CBC**模式。\n\n## 补充\n\n1. 我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。\n2. 填充明文时，如果明文长度原本就是16字节的整数倍，那么除了NoPadding以外，其他的填充方式都会填充一组额外的16字节明文块。\n\n## AES加密算法底层原理\n\n### AES加密步骤\n\n1. 把明文按照128bit拆分成若干个明文块。\n2. 按照选择的填充方式来填充最后一个明文块。\n3. 每一个明文块利用AES加密器和密钥，加密成密文块。\n4. 拼接所有的密文块，成为最终的密文结果。\n\n### AES加密器需要经过多少轮加密\n\n- 初始轮（Initial Round） 1次\n- 普通轮（Rounds）     N次\n- 最终轮（Final Round）  1次\n\n上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。\n\n### 除去初始轮各种Key长度对应的轮数\n\n- AES128：10轮\n- AES192：12轮\n- AES256：14轮\n\n### 不同阶段Round的处理步骤\n\n**初始轮只有一个步骤**\n\n- 加轮密钥（AddRoundKey）\n\n**普通轮有四个步骤**\n\n- 字节代替（SubBytes）\n\n  首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为**S盒**（Subtitution Box）的16X16大小的二维常量数组。假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。\n\n- 行移位（ShiftRows）\n\n  这一步很简单，就像图中所描述的：第一行不变，第二行循环左移**1**个字节，第三行循环左移**2**个字节，第四行循环左移**3**个字节。\n\n- 列混淆（MixColumns）\n\n  这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。\n\n- 加轮密钥（AddRoundKey）\n\n  这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：**扩展密钥**（KeyExpansions）——AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。\n\n**最终轮有三个步骤**\n\n- 字节代替（SubBytes）\n- 行移位（ShiftRows）\n- 加轮密钥（AddRoundKey）\n\n## AES解密流程\n\n解密流程基本是把加密流程倒置过来，顺序变为 最终轮->普通轮->初始轮。扩展密钥的使用顺序也和加密相反。\n\n\n\n\n\n","slug":"AES","published":1,"updated":"2020-01-17T09:49:24.465Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bif0007a6ybpy2jsvmj","content":"<h2 id=\"AES算法的特点\"><a href=\"#AES算法的特点\" class=\"headerlink\" title=\"AES算法的特点\"></a>AES算法的特点</h2><p>AES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客<a href=\"http://www.lishaojie.top/2019/07/04/MD5/\" target=\"_blank\" rel=\"noopener\">《MD5底层实现和解密方法》</a>所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。</p>\n<h3 id=\"密钥\"><a href=\"#密钥\" class=\"headerlink\" title=\"密钥\"></a>密钥</h3><p>密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用<strong>同一个密钥</strong>。AES支持三种长度的密钥：<strong>128位，192位，256位</strong>。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。</p>\n<p>从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"填充\"><a href=\"#填充\" class=\"headerlink\" title=\"填充\"></a>填充</h3><p>AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。</p>\n<p>假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行<strong>填充</strong>（Padding）。</p>\n<h4 id=\"NoPadding\"><a href=\"#NoPadding\" class=\"headerlink\" title=\"NoPadding\"></a>NoPadding</h4><p>不做任何填充，但是要求明文必须是16字节的整数倍。</p>\n<h4 id=\"PKCS5Padding（默认）\"><a href=\"#PKCS5Padding（默认）\" class=\"headerlink\" title=\"PKCS5Padding（默认）\"></a>PKCS5Padding（默认）</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。</p>\n<p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}</p>\n<h4 id=\"ISO10126Padding\"><a href=\"#ISO10126Padding\" class=\"headerlink\" title=\"ISO10126Padding\"></a>ISO10126Padding</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。</p>\n<p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}</p>\n<p><strong>注意：如果在AES加密时使用了某一种填充方式，解密的时候也必须采用同样的填充方式。</strong></p>\n<h3 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h3><p>AES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。</p>\n<h4 id=\"ECB模式（默认）\"><a href=\"#ECB模式（默认）\" class=\"headerlink\" title=\"ECB模式（默认）\"></a>ECB模式（默认）</h4><p>电码本模式  Electronic Codebook Book</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazosrcxlxj30j60apdg3.jpg\" alt></p>\n<p>ECB模式是最简单的工作模式，在该模式下，每一个明文块的加密都是独立完成的，互不干涉。好处是简单，有利于并行计算。缺点也很明显，相同的明文块经过加密会变成相同的密文块，因此安全性较差。</p>\n<h4 id=\"CBC模式\"><a href=\"#CBC模式\" class=\"headerlink\" title=\"CBC模式\"></a>CBC模式</h4><p>密码分组链接模式  Cipher Block Chaining</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazou8zo61j30l40bcdgu.jpg\" alt></p>\n<p>CBC模式引入了一个新的概念：初始向量IV（Initialization Vector），它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它<strong>前一个明文块所加密出的密文块</strong>相异或。这样以来，相同的明文块加密出的密文块显然是不一样的。好处是安全性更好，缺点是无法并行计算，性能上不如ECB；引入初始化向量IV，增加复杂度。</p>\n<h4 id=\"CTR模式\"><a href=\"#CTR模式\" class=\"headerlink\" title=\"CTR模式\"></a>CTR模式</h4><p>计算器模式  Counter（实现省略……）</p>\n<h4 id=\"CFB模式\"><a href=\"#CFB模式\" class=\"headerlink\" title=\"CFB模式\"></a>CFB模式</h4><p>密码反馈模式  Cipher FeedBack（实现省略……）</p>\n<h4 id=\"OFB模式\"><a href=\"#OFB模式\" class=\"headerlink\" title=\"OFB模式\"></a>OFB模式</h4><p>输出反馈模式  Output FeedBack（实现省略……）</p>\n<p><strong>注意：如果在AES加密时使用了某一种工作模式，解密的时候也必须采用同样的工作模式。</strong></p>\n<p>在Java代码中，如何修改不同长度的密钥和填充模式？</p>\n<p>AES算法在Java的 javax.crypto 包里有很好的封装，调用方式如下：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazo71c7glj30f90963zq.jpg\" alt></p>\n<ol>\n<li>kgen.init传入的第一个参数128决定了密钥的长度是<strong>128bit</strong>。</li>\n<li>Cipher.getInstance(“AES/CBC/NoPadding”)决定了AES选择的填充方式是<strong>NoPadding</strong>，工作模式是<strong>CBC</strong>模式。</li>\n</ol>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><ol>\n<li>我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。</li>\n<li>填充明文时，如果明文长度原本就是16字节的整数倍，那么除了NoPadding以外，其他的填充方式都会填充一组额外的16字节明文块。</li>\n</ol>\n<h2 id=\"AES加密算法底层原理\"><a href=\"#AES加密算法底层原理\" class=\"headerlink\" title=\"AES加密算法底层原理\"></a>AES加密算法底层原理</h2><h3 id=\"AES加密步骤\"><a href=\"#AES加密步骤\" class=\"headerlink\" title=\"AES加密步骤\"></a>AES加密步骤</h3><ol>\n<li>把明文按照128bit拆分成若干个明文块。</li>\n<li>按照选择的填充方式来填充最后一个明文块。</li>\n<li>每一个明文块利用AES加密器和密钥，加密成密文块。</li>\n<li>拼接所有的密文块，成为最终的密文结果。</li>\n</ol>\n<h3 id=\"AES加密器需要经过多少轮加密\"><a href=\"#AES加密器需要经过多少轮加密\" class=\"headerlink\" title=\"AES加密器需要经过多少轮加密\"></a>AES加密器需要经过多少轮加密</h3><ul>\n<li>初始轮（Initial Round） 1次</li>\n<li>普通轮（Rounds）     N次</li>\n<li>最终轮（Final Round）  1次</li>\n</ul>\n<p>上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。</p>\n<h3 id=\"除去初始轮各种Key长度对应的轮数\"><a href=\"#除去初始轮各种Key长度对应的轮数\" class=\"headerlink\" title=\"除去初始轮各种Key长度对应的轮数\"></a>除去初始轮各种Key长度对应的轮数</h3><ul>\n<li>AES128：10轮</li>\n<li>AES192：12轮</li>\n<li>AES256：14轮</li>\n</ul>\n<h3 id=\"不同阶段Round的处理步骤\"><a href=\"#不同阶段Round的处理步骤\" class=\"headerlink\" title=\"不同阶段Round的处理步骤\"></a>不同阶段Round的处理步骤</h3><p><strong>初始轮只有一个步骤</strong></p>\n<ul>\n<li>加轮密钥（AddRoundKey）</li>\n</ul>\n<p><strong>普通轮有四个步骤</strong></p>\n<ul>\n<li><p>字节代替（SubBytes）</p>\n<p>首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为<strong>S盒</strong>（Subtitution Box）的16X16大小的二维常量数组。假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。</p>\n</li>\n<li><p>行移位（ShiftRows）</p>\n<p>这一步很简单，就像图中所描述的：第一行不变，第二行循环左移<strong>1</strong>个字节，第三行循环左移<strong>2</strong>个字节，第四行循环左移<strong>3</strong>个字节。</p>\n</li>\n<li><p>列混淆（MixColumns）</p>\n<p>这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。</p>\n</li>\n<li><p>加轮密钥（AddRoundKey）</p>\n<p>这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：<strong>扩展密钥</strong>（KeyExpansions）——AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ……一直到W{160-175}用于最终轮（第10轮）的处理。</p>\n</li>\n</ul>\n<p><strong>最终轮有三个步骤</strong></p>\n<ul>\n<li>字节代替（SubBytes）</li>\n<li>行移位（ShiftRows）</li>\n<li>加轮密钥（AddRoundKey）</li>\n</ul>\n<h2 id=\"AES解密流程\"><a href=\"#AES解密流程\" class=\"headerlink\" title=\"AES解密流程\"></a>AES解密流程</h2><p>解密流程基本是把加密流程倒置过来，顺序变为 最终轮-&gt;普通轮-&gt;初始轮。扩展密钥的使用顺序也和加密相反。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"AES算法的特点\"><a href=\"#AES算法的特点\" class=\"headerlink\" title=\"AES算法的特点\"></a>AES算法的特点</h2><p>AES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客<a href=\"http://www.lishaojie.top/2019/07/04/MD5/\" target=\"_blank\" rel=\"noopener\">《MD5底层实现和解密方法》</a>所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。</p>\n<h3 id=\"密钥\"><a href=\"#密钥\" class=\"headerlink\" title=\"密钥\"></a>密钥</h3><p>密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用<strong>同一个密钥</strong>。AES支持三种长度的密钥：<strong>128位，192位，256位</strong>。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。</p>\n<p>从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。</p>","more":"<h3 id=\"填充\"><a href=\"#填充\" class=\"headerlink\" title=\"填充\"></a>填充</h3><p>AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。</p>\n<p>假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行<strong>填充</strong>（Padding）。</p>\n<h4 id=\"NoPadding\"><a href=\"#NoPadding\" class=\"headerlink\" title=\"NoPadding\"></a>NoPadding</h4><p>不做任何填充，但是要求明文必须是16字节的整数倍。</p>\n<h4 id=\"PKCS5Padding（默认）\"><a href=\"#PKCS5Padding（默认）\" class=\"headerlink\" title=\"PKCS5Padding（默认）\"></a>PKCS5Padding（默认）</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。</p>\n<p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}</p>\n<h4 id=\"ISO10126Padding\"><a href=\"#ISO10126Padding\" class=\"headerlink\" title=\"ISO10126Padding\"></a>ISO10126Padding</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。</p>\n<p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}</p>\n<p><strong>注意：如果在AES加密时使用了某一种填充方式，解密的时候也必须采用同样的填充方式。</strong></p>\n<h3 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h3><p>AES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。</p>\n<h4 id=\"ECB模式（默认）\"><a href=\"#ECB模式（默认）\" class=\"headerlink\" title=\"ECB模式（默认）\"></a>ECB模式（默认）</h4><p>电码本模式  Electronic Codebook Book</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazosrcxlxj30j60apdg3.jpg\" alt></p>\n<p>ECB模式是最简单的工作模式，在该模式下，每一个明文块的加密都是独立完成的，互不干涉。好处是简单，有利于并行计算。缺点也很明显，相同的明文块经过加密会变成相同的密文块，因此安全性较差。</p>\n<h4 id=\"CBC模式\"><a href=\"#CBC模式\" class=\"headerlink\" title=\"CBC模式\"></a>CBC模式</h4><p>密码分组链接模式  Cipher Block Chaining</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazou8zo61j30l40bcdgu.jpg\" alt></p>\n<p>CBC模式引入了一个新的概念：初始向量IV（Initialization Vector），它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它<strong>前一个明文块所加密出的密文块</strong>相异或。这样以来，相同的明文块加密出的密文块显然是不一样的。好处是安全性更好，缺点是无法并行计算，性能上不如ECB；引入初始化向量IV，增加复杂度。</p>\n<h4 id=\"CTR模式\"><a href=\"#CTR模式\" class=\"headerlink\" title=\"CTR模式\"></a>CTR模式</h4><p>计算器模式  Counter（实现省略……）</p>\n<h4 id=\"CFB模式\"><a href=\"#CFB模式\" class=\"headerlink\" title=\"CFB模式\"></a>CFB模式</h4><p>密码反馈模式  Cipher FeedBack（实现省略……）</p>\n<h4 id=\"OFB模式\"><a href=\"#OFB模式\" class=\"headerlink\" title=\"OFB模式\"></a>OFB模式</h4><p>输出反馈模式  Output FeedBack（实现省略……）</p>\n<p><strong>注意：如果在AES加密时使用了某一种工作模式，解密的时候也必须采用同样的工作模式。</strong></p>\n<p>在Java代码中，如何修改不同长度的密钥和填充模式？</p>\n<p>AES算法在Java的 javax.crypto 包里有很好的封装，调用方式如下：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazo71c7glj30f90963zq.jpg\" alt></p>\n<ol>\n<li>kgen.init传入的第一个参数128决定了密钥的长度是<strong>128bit</strong>。</li>\n<li>Cipher.getInstance(“AES/CBC/NoPadding”)决定了AES选择的填充方式是<strong>NoPadding</strong>，工作模式是<strong>CBC</strong>模式。</li>\n</ol>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><ol>\n<li>我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。</li>\n<li>填充明文时，如果明文长度原本就是16字节的整数倍，那么除了NoPadding以外，其他的填充方式都会填充一组额外的16字节明文块。</li>\n</ol>\n<h2 id=\"AES加密算法底层原理\"><a href=\"#AES加密算法底层原理\" class=\"headerlink\" title=\"AES加密算法底层原理\"></a>AES加密算法底层原理</h2><h3 id=\"AES加密步骤\"><a href=\"#AES加密步骤\" class=\"headerlink\" title=\"AES加密步骤\"></a>AES加密步骤</h3><ol>\n<li>把明文按照128bit拆分成若干个明文块。</li>\n<li>按照选择的填充方式来填充最后一个明文块。</li>\n<li>每一个明文块利用AES加密器和密钥，加密成密文块。</li>\n<li>拼接所有的密文块，成为最终的密文结果。</li>\n</ol>\n<h3 id=\"AES加密器需要经过多少轮加密\"><a href=\"#AES加密器需要经过多少轮加密\" class=\"headerlink\" title=\"AES加密器需要经过多少轮加密\"></a>AES加密器需要经过多少轮加密</h3><ul>\n<li>初始轮（Initial Round） 1次</li>\n<li>普通轮（Rounds）     N次</li>\n<li>最终轮（Final Round）  1次</li>\n</ul>\n<p>上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。</p>\n<h3 id=\"除去初始轮各种Key长度对应的轮数\"><a href=\"#除去初始轮各种Key长度对应的轮数\" class=\"headerlink\" title=\"除去初始轮各种Key长度对应的轮数\"></a>除去初始轮各种Key长度对应的轮数</h3><ul>\n<li>AES128：10轮</li>\n<li>AES192：12轮</li>\n<li>AES256：14轮</li>\n</ul>\n<h3 id=\"不同阶段Round的处理步骤\"><a href=\"#不同阶段Round的处理步骤\" class=\"headerlink\" title=\"不同阶段Round的处理步骤\"></a>不同阶段Round的处理步骤</h3><p><strong>初始轮只有一个步骤</strong></p>\n<ul>\n<li>加轮密钥（AddRoundKey）</li>\n</ul>\n<p><strong>普通轮有四个步骤</strong></p>\n<ul>\n<li><p>字节代替（SubBytes）</p>\n<p>首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为<strong>S盒</strong>（Subtitution Box）的16X16大小的二维常量数组。假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。</p>\n</li>\n<li><p>行移位（ShiftRows）</p>\n<p>这一步很简单，就像图中所描述的：第一行不变，第二行循环左移<strong>1</strong>个字节，第三行循环左移<strong>2</strong>个字节，第四行循环左移<strong>3</strong>个字节。</p>\n</li>\n<li><p>列混淆（MixColumns）</p>\n<p>这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。</p>\n</li>\n<li><p>加轮密钥（AddRoundKey）</p>\n<p>这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：<strong>扩展密钥</strong>（KeyExpansions）——AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ……一直到W{160-175}用于最终轮（第10轮）的处理。</p>\n</li>\n</ul>\n<p><strong>最终轮有三个步骤</strong></p>\n<ul>\n<li>字节代替（SubBytes）</li>\n<li>行移位（ShiftRows）</li>\n<li>加轮密钥（AddRoundKey）</li>\n</ul>\n<h2 id=\"AES解密流程\"><a href=\"#AES解密流程\" class=\"headerlink\" title=\"AES解密流程\"></a>AES解密流程</h2><p>解密流程基本是把加密流程倒置过来，顺序变为 最终轮-&gt;普通轮-&gt;初始轮。扩展密钥的使用顺序也和加密相反。</p>"},{"title":"MD5加密的底层实现和破解方法","date":"2019-07-04T14:07:27.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## 信息摘要技术\n\n信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。\n\nMD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。\n\n## 摘要哈希的生成过程\n\n1. 收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。\n2. 按照规则，把参数名和参数值拼接成一个字符串，同时把给定的**密钥**也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。\n3. 利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。\n\n<!--More-->\n\n## 第三方支付平台验证签名\n\n1. 发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。\n2. 第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。\n3. 用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做**验签**。\n\n## MD5算法底层实现原理\n\n简单概括起来，MD5算法的过程分为四步：\n\n1. 处理原文\n\n   首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512\\*N+448。之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。\n\n2. 设置初始值\n\n   MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）：\n\n   A=0x01234567\n\n   B=0x89ABCDEF\n\n   C=0xFEDCBA98\n\n   D=0x76543210\n\n3. 循环加工\n\n   ![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazpyfvzzgj309s0ae3yq.jpg)\n\n   图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。假设处理后的原文长度是M，主循环次数 = **M / 512**，每个主循环中包含 **512 / 32 \\* 4 = 64** 次 子循环。上面这张图所表达的就是**单次子循环**的流程。下面对图中其他元素一一解释：\n\n   **1.绿色F**\n\n   图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种：\n\n   F(X, Y, Z) =(X&Y) | ((~X) & Z)\n\n   G(X, Y, Z) =(X&Z) | (Y & (~Z))\n\n   H(X, Y, Z) =X^Y^Z\n\n   I(X, Y, Z)=Y^(X|(~Z))\n\n   在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。\n\n   **2.红色“田”字**\n\n   很简单，红色的田字代表相加的意思。\n\n   **3.Mi**\n\n   Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。\n\n   **4.Ki**\n\n   一个常量，在64次子循环中，每一次用到的常量都是不同的。\n\n   **5.黄色的<<**\n\n   左移S位，S的值也是常量。\n\n4. 拼接结果\n\n   这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。\n\n------\n\n## MD5破解\n\n这里要提一点，所谓的MD5破解，并非要把摘要还原成原文，而是通过[碰撞]生成同样的摘要。\n\nMD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，所以我们只需要碰撞出原文的哈希值即可欺骗过应用系统的验签。\n\n### MD5碰撞方法\n\n#### 暴力枚举法\n\n顾名思义，就是简单粗暴的枚举出所有原文，并计算出它们的哈希值，看哪个哈希值和给定的信息摘要一致，这种方法虽简单，但是时间复杂度极高。不过优先尝试生日和有意义的单词可以缩小范围。\n\n#### 字典法\n\n如果说暴力枚举法是用时间换空间，那么字典法则就是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值，每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。不过这样虽然每次破解速度很快，但是生成字典所需要的空间极大。取巧的方式是优先存储常用的密码和摘要。\n\n#### 彩虹表法\n\n彩虹表法可以说是字典法的优化，它采用了一种有趣的数据结构：**彩虹表**。\n\n彩虹表对哈希链进行了改进，把原先的R(X)函数改进成从R1(X)到Rk(X)，一共k个衰减函数。这样一来虽然可能发生碰撞，但是碰撞只会发生在同一级运算，大大减小了存储重复的几率。\n\n#### 差分攻击\n\n2009年，冯登国、谢涛利用差分攻击，将MD5的碰撞算法复杂度进一步降低，想了解的小伙伴可以自行查阅相关资料。\n\n### 补充\n\n对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。","source":"_posts/MD5.md","raw":"---\ntitle: MD5加密的底层实现和破解方法\ndate: 2019-07-04 22:07:27\ncategories: \n  - Java\n  - 算法\ntags:\n  - 算法\n  - MD5算法\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## 信息摘要技术\n\n信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。\n\nMD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。\n\n## 摘要哈希的生成过程\n\n1. 收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。\n2. 按照规则，把参数名和参数值拼接成一个字符串，同时把给定的**密钥**也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。\n3. 利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。\n\n<!--More-->\n\n## 第三方支付平台验证签名\n\n1. 发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。\n2. 第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。\n3. 用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做**验签**。\n\n## MD5算法底层实现原理\n\n简单概括起来，MD5算法的过程分为四步：\n\n1. 处理原文\n\n   首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512\\*N+448。之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。\n\n2. 设置初始值\n\n   MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）：\n\n   A=0x01234567\n\n   B=0x89ABCDEF\n\n   C=0xFEDCBA98\n\n   D=0x76543210\n\n3. 循环加工\n\n   ![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazpyfvzzgj309s0ae3yq.jpg)\n\n   图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。假设处理后的原文长度是M，主循环次数 = **M / 512**，每个主循环中包含 **512 / 32 \\* 4 = 64** 次 子循环。上面这张图所表达的就是**单次子循环**的流程。下面对图中其他元素一一解释：\n\n   **1.绿色F**\n\n   图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种：\n\n   F(X, Y, Z) =(X&Y) | ((~X) & Z)\n\n   G(X, Y, Z) =(X&Z) | (Y & (~Z))\n\n   H(X, Y, Z) =X^Y^Z\n\n   I(X, Y, Z)=Y^(X|(~Z))\n\n   在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。\n\n   **2.红色“田”字**\n\n   很简单，红色的田字代表相加的意思。\n\n   **3.Mi**\n\n   Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。\n\n   **4.Ki**\n\n   一个常量，在64次子循环中，每一次用到的常量都是不同的。\n\n   **5.黄色的<<**\n\n   左移S位，S的值也是常量。\n\n4. 拼接结果\n\n   这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。\n\n------\n\n## MD5破解\n\n这里要提一点，所谓的MD5破解，并非要把摘要还原成原文，而是通过[碰撞]生成同样的摘要。\n\nMD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，所以我们只需要碰撞出原文的哈希值即可欺骗过应用系统的验签。\n\n### MD5碰撞方法\n\n#### 暴力枚举法\n\n顾名思义，就是简单粗暴的枚举出所有原文，并计算出它们的哈希值，看哪个哈希值和给定的信息摘要一致，这种方法虽简单，但是时间复杂度极高。不过优先尝试生日和有意义的单词可以缩小范围。\n\n#### 字典法\n\n如果说暴力枚举法是用时间换空间，那么字典法则就是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值，每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。不过这样虽然每次破解速度很快，但是生成字典所需要的空间极大。取巧的方式是优先存储常用的密码和摘要。\n\n#### 彩虹表法\n\n彩虹表法可以说是字典法的优化，它采用了一种有趣的数据结构：**彩虹表**。\n\n彩虹表对哈希链进行了改进，把原先的R(X)函数改进成从R1(X)到Rk(X)，一共k个衰减函数。这样一来虽然可能发生碰撞，但是碰撞只会发生在同一级运算，大大减小了存储重复的几率。\n\n#### 差分攻击\n\n2009年，冯登国、谢涛利用差分攻击，将MD5的碰撞算法复杂度进一步降低，想了解的小伙伴可以自行查阅相关资料。\n\n### 补充\n\n对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。","slug":"MD5","published":1,"updated":"2020-01-17T10:15:37.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bii000aa6ybf1clbo56","content":"<h2 id=\"信息摘要技术\"><a href=\"#信息摘要技术\" class=\"headerlink\" title=\"信息摘要技术\"></a>信息摘要技术</h2><p>信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。</p>\n<p>MD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。</p>\n<h2 id=\"摘要哈希的生成过程\"><a href=\"#摘要哈希的生成过程\" class=\"headerlink\" title=\"摘要哈希的生成过程\"></a>摘要哈希的生成过程</h2><ol>\n<li>收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。</li>\n<li>按照规则，把参数名和参数值拼接成一个字符串，同时把给定的<strong>密钥</strong>也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。</li>\n<li>利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。</li>\n</ol>\n<a id=\"more\"></a>\n\n<h2 id=\"第三方支付平台验证签名\"><a href=\"#第三方支付平台验证签名\" class=\"headerlink\" title=\"第三方支付平台验证签名\"></a>第三方支付平台验证签名</h2><ol>\n<li>发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。</li>\n<li>第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。</li>\n<li>用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做<strong>验签</strong>。</li>\n</ol>\n<h2 id=\"MD5算法底层实现原理\"><a href=\"#MD5算法底层实现原理\" class=\"headerlink\" title=\"MD5算法底层实现原理\"></a>MD5算法底层实现原理</h2><p>简单概括起来，MD5算法的过程分为四步：</p>\n<ol>\n<li><p>处理原文</p>\n<p>首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512*N+448。之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。</p>\n</li>\n<li><p>设置初始值</p>\n<p>MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）：</p>\n<p>A=0x01234567</p>\n<p>B=0x89ABCDEF</p>\n<p>C=0xFEDCBA98</p>\n<p>D=0x76543210</p>\n</li>\n<li><p>循环加工</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazpyfvzzgj309s0ae3yq.jpg\" alt></p>\n<p>图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。假设处理后的原文长度是M，主循环次数 = <strong>M / 512</strong>，每个主循环中包含 <strong>512 / 32 * 4 = 64</strong> 次 子循环。上面这张图所表达的就是<strong>单次子循环</strong>的流程。下面对图中其他元素一一解释：</p>\n<p><strong>1.绿色F</strong></p>\n<p>图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种：</p>\n<p>F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z)</p>\n<p>G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z))</p>\n<p>H(X, Y, Z) =X^Y^Z</p>\n<p>I(X, Y, Z)=Y^(X|(~Z))</p>\n<p>在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。</p>\n<p><strong>2.红色“田”字</strong></p>\n<p>很简单，红色的田字代表相加的意思。</p>\n<p><strong>3.Mi</strong></p>\n<p>Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0<del>M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1</del>M16之一。</p>\n<p><strong>4.Ki</strong></p>\n<p>一个常量，在64次子循环中，每一次用到的常量都是不同的。</p>\n<p><strong>5.黄色的&lt;&lt;</strong></p>\n<p>左移S位，S的值也是常量。</p>\n</li>\n<li><p>拼接结果</p>\n<p>这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"MD5破解\"><a href=\"#MD5破解\" class=\"headerlink\" title=\"MD5破解\"></a>MD5破解</h2><p>这里要提一点，所谓的MD5破解，并非要把摘要还原成原文，而是通过[碰撞]生成同样的摘要。</p>\n<p>MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，所以我们只需要碰撞出原文的哈希值即可欺骗过应用系统的验签。</p>\n<h3 id=\"MD5碰撞方法\"><a href=\"#MD5碰撞方法\" class=\"headerlink\" title=\"MD5碰撞方法\"></a>MD5碰撞方法</h3><h4 id=\"暴力枚举法\"><a href=\"#暴力枚举法\" class=\"headerlink\" title=\"暴力枚举法\"></a>暴力枚举法</h4><p>顾名思义，就是简单粗暴的枚举出所有原文，并计算出它们的哈希值，看哪个哈希值和给定的信息摘要一致，这种方法虽简单，但是时间复杂度极高。不过优先尝试生日和有意义的单词可以缩小范围。</p>\n<h4 id=\"字典法\"><a href=\"#字典法\" class=\"headerlink\" title=\"字典法\"></a>字典法</h4><p>如果说暴力枚举法是用时间换空间，那么字典法则就是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值，每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。不过这样虽然每次破解速度很快，但是生成字典所需要的空间极大。取巧的方式是优先存储常用的密码和摘要。</p>\n<h4 id=\"彩虹表法\"><a href=\"#彩虹表法\" class=\"headerlink\" title=\"彩虹表法\"></a>彩虹表法</h4><p>彩虹表法可以说是字典法的优化，它采用了一种有趣的数据结构：<strong>彩虹表</strong>。</p>\n<p>彩虹表对哈希链进行了改进，把原先的R(X)函数改进成从R1(X)到Rk(X)，一共k个衰减函数。这样一来虽然可能发生碰撞，但是碰撞只会发生在同一级运算，大大减小了存储重复的几率。</p>\n<h4 id=\"差分攻击\"><a href=\"#差分攻击\" class=\"headerlink\" title=\"差分攻击\"></a>差分攻击</h4><p>2009年，冯登国、谢涛利用差分攻击，将MD5的碰撞算法复杂度进一步降低，想了解的小伙伴可以自行查阅相关资料。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"信息摘要技术\"><a href=\"#信息摘要技术\" class=\"headerlink\" title=\"信息摘要技术\"></a>信息摘要技术</h2><p>信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。</p>\n<p>MD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。</p>\n<h2 id=\"摘要哈希的生成过程\"><a href=\"#摘要哈希的生成过程\" class=\"headerlink\" title=\"摘要哈希的生成过程\"></a>摘要哈希的生成过程</h2><ol>\n<li>收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。</li>\n<li>按照规则，把参数名和参数值拼接成一个字符串，同时把给定的<strong>密钥</strong>也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。</li>\n<li>利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。</li>\n</ol>","more":"<h2 id=\"第三方支付平台验证签名\"><a href=\"#第三方支付平台验证签名\" class=\"headerlink\" title=\"第三方支付平台验证签名\"></a>第三方支付平台验证签名</h2><ol>\n<li>发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。</li>\n<li>第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。</li>\n<li>用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做<strong>验签</strong>。</li>\n</ol>\n<h2 id=\"MD5算法底层实现原理\"><a href=\"#MD5算法底层实现原理\" class=\"headerlink\" title=\"MD5算法底层实现原理\"></a>MD5算法底层实现原理</h2><p>简单概括起来，MD5算法的过程分为四步：</p>\n<ol>\n<li><p>处理原文</p>\n<p>首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512*N+448。之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。</p>\n</li>\n<li><p>设置初始值</p>\n<p>MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）：</p>\n<p>A=0x01234567</p>\n<p>B=0x89ABCDEF</p>\n<p>C=0xFEDCBA98</p>\n<p>D=0x76543210</p>\n</li>\n<li><p>循环加工</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazpyfvzzgj309s0ae3yq.jpg\" alt></p>\n<p>图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。假设处理后的原文长度是M，主循环次数 = <strong>M / 512</strong>，每个主循环中包含 <strong>512 / 32 * 4 = 64</strong> 次 子循环。上面这张图所表达的就是<strong>单次子循环</strong>的流程。下面对图中其他元素一一解释：</p>\n<p><strong>1.绿色F</strong></p>\n<p>图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种：</p>\n<p>F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z)</p>\n<p>G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z))</p>\n<p>H(X, Y, Z) =X^Y^Z</p>\n<p>I(X, Y, Z)=Y^(X|(~Z))</p>\n<p>在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。</p>\n<p><strong>2.红色“田”字</strong></p>\n<p>很简单，红色的田字代表相加的意思。</p>\n<p><strong>3.Mi</strong></p>\n<p>Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0<del>M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1</del>M16之一。</p>\n<p><strong>4.Ki</strong></p>\n<p>一个常量，在64次子循环中，每一次用到的常量都是不同的。</p>\n<p><strong>5.黄色的&lt;&lt;</strong></p>\n<p>左移S位，S的值也是常量。</p>\n</li>\n<li><p>拼接结果</p>\n<p>这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"MD5破解\"><a href=\"#MD5破解\" class=\"headerlink\" title=\"MD5破解\"></a>MD5破解</h2><p>这里要提一点，所谓的MD5破解，并非要把摘要还原成原文，而是通过[碰撞]生成同样的摘要。</p>\n<p>MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，所以我们只需要碰撞出原文的哈希值即可欺骗过应用系统的验签。</p>\n<h3 id=\"MD5碰撞方法\"><a href=\"#MD5碰撞方法\" class=\"headerlink\" title=\"MD5碰撞方法\"></a>MD5碰撞方法</h3><h4 id=\"暴力枚举法\"><a href=\"#暴力枚举法\" class=\"headerlink\" title=\"暴力枚举法\"></a>暴力枚举法</h4><p>顾名思义，就是简单粗暴的枚举出所有原文，并计算出它们的哈希值，看哪个哈希值和给定的信息摘要一致，这种方法虽简单，但是时间复杂度极高。不过优先尝试生日和有意义的单词可以缩小范围。</p>\n<h4 id=\"字典法\"><a href=\"#字典法\" class=\"headerlink\" title=\"字典法\"></a>字典法</h4><p>如果说暴力枚举法是用时间换空间，那么字典法则就是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值，每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。不过这样虽然每次破解速度很快，但是生成字典所需要的空间极大。取巧的方式是优先存储常用的密码和摘要。</p>\n<h4 id=\"彩虹表法\"><a href=\"#彩虹表法\" class=\"headerlink\" title=\"彩虹表法\"></a>彩虹表法</h4><p>彩虹表法可以说是字典法的优化，它采用了一种有趣的数据结构：<strong>彩虹表</strong>。</p>\n<p>彩虹表对哈希链进行了改进，把原先的R(X)函数改进成从R1(X)到Rk(X)，一共k个衰减函数。这样一来虽然可能发生碰撞，但是碰撞只会发生在同一级运算，大大减小了存储重复的几率。</p>\n<h4 id=\"差分攻击\"><a href=\"#差分攻击\" class=\"headerlink\" title=\"差分攻击\"></a>差分攻击</h4><p>2009年，冯登国、谢涛利用差分攻击，将MD5的碰撞算法复杂度进一步降低，想了解的小伙伴可以自行查阅相关资料。</p>\n<h3 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h3><p>对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。</p>"},{"title":"神一样的存在,万能插件-Tampermonkey","date":"2020-01-10T15:35:36.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash3mdauaj31960u04qp.jpg","_content":"\n## 前言\n\n今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！\n\n## 下载安装\n\n既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：[科学上网推荐,谷歌浏览器插件Ghelper](http://www.lishaojie.top/2020/01/09/ghelper)  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg)\n\n<!-- more -->\n\n## 插件介绍\n\n说到这款插件就不得不说一个网址：[Greasy Fork](https://greasyfork.org/zh-CN)\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnhrmut5j316m0u0gye.jpg)\n\n这个网站上可以搜索你想实现的任意功能，比如百度云盘下载不限速、优酷腾讯爱奇艺等各大视频网站的VIP破解、B站以及YouTube视频下载、智能划词翻译等等。该页面还记录了不同浏览器所支持的插件名称，详细介绍了用户脚本的安装和使用。\n\n## 使用说明\n\n根据你想要实现的功能直接在搜索框中搜索，根据安装量以及更新日期进行筛选，选择最佳的用户脚本安装使用，一般安装量很大并且更新时间较近的都没问题。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnt5lrbfj31030u0aji.jpg)\n\n选中用户脚本点击进入，直接安装脚本即可使用，简单粗暴。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqny4zi10j31fo0gu782.jpg)\n\n点击插件进入管理面板，可以直接对下载安装的用户脚本进行管理。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnzslx0dj30m00fw0uf.jpg)\n\n## 脚本推荐\n\n管理面板页面如下所示，可以打开和关闭脚本功能，对脚本进行编辑和删除操作等等。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqo2lzm5uj32480huwj7.jpg)\n\n我比较常用的是这几个，划词翻译真的很方便，下面分享几张使用截图。\n\n划词翻译\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqbf4eyuj31fq0bogo9.jpg)\n\nBiliBili会员站点解析\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqdpljsxj31yh0u07b0.jpg)\n\nYouTube视频下载\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqgr61xqj31850u04qp.jpg)\n\n是不是感觉自己发现了新大陆，更多的功能等待你发掘，赶紧下载体验吧！","source":"_posts/Tampermonkey.md","raw":"---\ntitle: 神一样的存在,万能插件-Tampermonkey\ndate: 2020-01-10 23:35:36\ntags:\n  - Google plugin\n  - Tampermonkey\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash3mdauaj31960u04qp.jpg\n---\n\n## 前言\n\n今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！\n\n## 下载安装\n\n既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：[科学上网推荐,谷歌浏览器插件Ghelper](http://www.lishaojie.top/2020/01/09/ghelper)  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg)\n\n<!-- more -->\n\n## 插件介绍\n\n说到这款插件就不得不说一个网址：[Greasy Fork](https://greasyfork.org/zh-CN)\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnhrmut5j316m0u0gye.jpg)\n\n这个网站上可以搜索你想实现的任意功能，比如百度云盘下载不限速、优酷腾讯爱奇艺等各大视频网站的VIP破解、B站以及YouTube视频下载、智能划词翻译等等。该页面还记录了不同浏览器所支持的插件名称，详细介绍了用户脚本的安装和使用。\n\n## 使用说明\n\n根据你想要实现的功能直接在搜索框中搜索，根据安装量以及更新日期进行筛选，选择最佳的用户脚本安装使用，一般安装量很大并且更新时间较近的都没问题。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnt5lrbfj31030u0aji.jpg)\n\n选中用户脚本点击进入，直接安装脚本即可使用，简单粗暴。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqny4zi10j31fo0gu782.jpg)\n\n点击插件进入管理面板，可以直接对下载安装的用户脚本进行管理。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnzslx0dj30m00fw0uf.jpg)\n\n## 脚本推荐\n\n管理面板页面如下所示，可以打开和关闭脚本功能，对脚本进行编辑和删除操作等等。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqo2lzm5uj32480huwj7.jpg)\n\n我比较常用的是这几个，划词翻译真的很方便，下面分享几张使用截图。\n\n划词翻译\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqbf4eyuj31fq0bogo9.jpg)\n\nBiliBili会员站点解析\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqdpljsxj31yh0u07b0.jpg)\n\nYouTube视频下载\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqgr61xqj31850u04qp.jpg)\n\n是不是感觉自己发现了新大陆，更多的功能等待你发掘，赶紧下载体验吧！","slug":"Tampermonkey","published":1,"updated":"2020-01-12T09:03:20.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bij000ba6ybj7q9l3rx","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！</p>\n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p>既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：<a href=\"http://www.lishaojie.top/2020/01/09/ghelper\" target=\"_blank\" rel=\"noopener\">科学上网推荐,谷歌浏览器插件Ghelper</a>  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg\" alt></p>\n<a id=\"more\"></a>\n\n<h2 id=\"插件介绍\"><a href=\"#插件介绍\" class=\"headerlink\" title=\"插件介绍\"></a>插件介绍</h2><p>说到这款插件就不得不说一个网址：<a href=\"https://greasyfork.org/zh-CN\" target=\"_blank\" rel=\"noopener\">Greasy Fork</a></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnhrmut5j316m0u0gye.jpg\" alt></p>\n<p>这个网站上可以搜索你想实现的任意功能，比如百度云盘下载不限速、优酷腾讯爱奇艺等各大视频网站的VIP破解、B站以及YouTube视频下载、智能划词翻译等等。该页面还记录了不同浏览器所支持的插件名称，详细介绍了用户脚本的安装和使用。</p>\n<h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><p>根据你想要实现的功能直接在搜索框中搜索，根据安装量以及更新日期进行筛选，选择最佳的用户脚本安装使用，一般安装量很大并且更新时间较近的都没问题。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnt5lrbfj31030u0aji.jpg\" alt></p>\n<p>选中用户脚本点击进入，直接安装脚本即可使用，简单粗暴。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqny4zi10j31fo0gu782.jpg\" alt></p>\n<p>点击插件进入管理面板，可以直接对下载安装的用户脚本进行管理。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnzslx0dj30m00fw0uf.jpg\" alt></p>\n<h2 id=\"脚本推荐\"><a href=\"#脚本推荐\" class=\"headerlink\" title=\"脚本推荐\"></a>脚本推荐</h2><p>管理面板页面如下所示，可以打开和关闭脚本功能，对脚本进行编辑和删除操作等等。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqo2lzm5uj32480huwj7.jpg\" alt></p>\n<p>我比较常用的是这几个，划词翻译真的很方便，下面分享几张使用截图。</p>\n<p>划词翻译</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqbf4eyuj31fq0bogo9.jpg\" alt></p>\n<p>BiliBili会员站点解析</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqdpljsxj31yh0u07b0.jpg\" alt></p>\n<p>YouTube视频下载</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqgr61xqj31850u04qp.jpg\" alt></p>\n<p>是不是感觉自己发现了新大陆，更多的功能等待你发掘，赶紧下载体验吧！</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！</p>\n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p>既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：<a href=\"http://www.lishaojie.top/2020/01/09/ghelper\" target=\"_blank\" rel=\"noopener\">科学上网推荐,谷歌浏览器插件Ghelper</a>  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg\" alt></p>","more":"<h2 id=\"插件介绍\"><a href=\"#插件介绍\" class=\"headerlink\" title=\"插件介绍\"></a>插件介绍</h2><p>说到这款插件就不得不说一个网址：<a href=\"https://greasyfork.org/zh-CN\" target=\"_blank\" rel=\"noopener\">Greasy Fork</a></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnhrmut5j316m0u0gye.jpg\" alt></p>\n<p>这个网站上可以搜索你想实现的任意功能，比如百度云盘下载不限速、优酷腾讯爱奇艺等各大视频网站的VIP破解、B站以及YouTube视频下载、智能划词翻译等等。该页面还记录了不同浏览器所支持的插件名称，详细介绍了用户脚本的安装和使用。</p>\n<h2 id=\"使用说明\"><a href=\"#使用说明\" class=\"headerlink\" title=\"使用说明\"></a>使用说明</h2><p>根据你想要实现的功能直接在搜索框中搜索，根据安装量以及更新日期进行筛选，选择最佳的用户脚本安装使用，一般安装量很大并且更新时间较近的都没问题。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnt5lrbfj31030u0aji.jpg\" alt></p>\n<p>选中用户脚本点击进入，直接安装脚本即可使用，简单粗暴。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqny4zi10j31fo0gu782.jpg\" alt></p>\n<p>点击插件进入管理面板，可以直接对下载安装的用户脚本进行管理。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnzslx0dj30m00fw0uf.jpg\" alt></p>\n<h2 id=\"脚本推荐\"><a href=\"#脚本推荐\" class=\"headerlink\" title=\"脚本推荐\"></a>脚本推荐</h2><p>管理面板页面如下所示，可以打开和关闭脚本功能，对脚本进行编辑和删除操作等等。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqo2lzm5uj32480huwj7.jpg\" alt></p>\n<p>我比较常用的是这几个，划词翻译真的很方便，下面分享几张使用截图。</p>\n<p>划词翻译</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqbf4eyuj31fq0bogo9.jpg\" alt></p>\n<p>BiliBili会员站点解析</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqdpljsxj31yh0u07b0.jpg\" alt></p>\n<p>YouTube视频下载</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqgr61xqj31850u04qp.jpg\" alt></p>\n<p>是不是感觉自己发现了新大陆，更多的功能等待你发掘，赶紧下载体验吧！</p>"},{"title":"加密算法","date":"2019-07-03T15:21:25.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## 加密算法的种类\n\n从宏观上来看，加密算法可以归结为三大类：**哈希算法、对称加密算法、非对称加密算法。**\n\n## 哈希算法\n\n从严格意义上来说，**哈希算法并不属于加密算法**，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是**生成信息摘要**，用以验证原信息的完整性和来源的可靠性。\n\n举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，**Hash（1234_100_abc） = 948569CD3466451F**）\n\n<!-- More -->\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazjr47fjuj30fp08d0t4.jpg)\n\n请求方把所有参数，外加双方约定的key拼接起来，并利用哈希算法生成一段信息摘要，而接收方在接收到参数和摘要后，按照同样的规则，也把参数和key拼接起来生成摘要并进行比较，如果完全一致，则证明信息没有被篡改。\n\n生成信息摘要的过程叫做**签名**，验证信息摘要的过程叫做**验签**。\n\n哈希算法最著名的当属**MD5算法**。后来，人们觉得MD5算法生成的信息摘要太短（128位），不够安全，于是又有了**SHA系列算法**。\n\n------\n\n## 对称加密算法\n\n上面提到的哈希算法可以解决验签问题，却不能解决明文加密问题。\n\n### 什么是对称加密？\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazjwvskkzj30gw05c3z0.jpg)\n\n如图所示，一段明文通过密钥进行加密，可以生成一段密文；这段密文通过同样的密钥进行解密，可以还原成明文。这样一来，只要双方事先约定好了密钥，就可以使用密文进行往来通信。\n\n除了通信过程中的加密以外，数据库存储的敏感信息也可以通过这种方式进行加密。这样即使数据泄露到了外界，泄露出去的也都是密文。\n\n### 对称加密包含哪些算法？\n\n在早期，人们使用**DES算法**进行加密解密；后来，人们觉得DES不够安全，发明了**3DES**算法；而如今，最为流行的对称加密算法是**AES算法**。\n\n### 对称加密的优缺点\n\n对称算法的好处是加密解密的效率比较高，缺点是不够安全，因为通信双方约定的密钥是相同的，只要密钥本身被任何一方泄露出去，通信的密文就会被破解；此外，在双方建立通信之初，服务端把密钥告诉给客户端的时候，也有被拦截到的危险。\n\n------\n\n## 非对称加密算法\n\n### 什么是非对称加密？\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazk870sktj30ed09kmyf.jpg)\n\n如图所示，在非对称加密中存在一对密钥，一个叫做**公钥**，另一个叫做**私钥**。在加密解密的过程中，我们既可以使用公钥加密明文，使用私钥解密密文；也可以使用私钥加密明文，使用公钥解密密文。其中最著名的非对称加密当属**RSA算法**。\n\n### 非对称加密的通信过程\n\n1. 在双方建立通信的时候，服务端只把公钥发送给客户端，自己保留私钥。\n2. 客户端利用接受到的公钥，加密另外一个密钥X（可以是对称加密的密钥），发送给服务端。\n3. 服务端获得消息后，利用自己的私钥解密，得到里面隐含的密钥X。\n4. 从此以后，双方可以利用密钥X进行对称加密的通信了。\n\n### 非对称加密的优缺点\n\n好处就是安全性很高，在通信过程中，即使公钥被第三方截获，甚至后续的所有通信都被截获，第三方也无法进行破解。因为第二步利用公钥加密的消息，只有私钥才能解开，所以第三方永远无法知道密钥X是什么。\n\n缺点是性能较差，无法应用于长期的通信。","source":"_posts/encryption.md","raw":"---\ntitle: 加密算法\ndate: 2019-07-03 23:21:25\ncategories: \n  - Java\n  - 算法\ntags:\n  - 算法\n  - 加密算法\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## 加密算法的种类\n\n从宏观上来看，加密算法可以归结为三大类：**哈希算法、对称加密算法、非对称加密算法。**\n\n## 哈希算法\n\n从严格意义上来说，**哈希算法并不属于加密算法**，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是**生成信息摘要**，用以验证原信息的完整性和来源的可靠性。\n\n举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，**Hash（1234_100_abc） = 948569CD3466451F**）\n\n<!-- More -->\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazjr47fjuj30fp08d0t4.jpg)\n\n请求方把所有参数，外加双方约定的key拼接起来，并利用哈希算法生成一段信息摘要，而接收方在接收到参数和摘要后，按照同样的规则，也把参数和key拼接起来生成摘要并进行比较，如果完全一致，则证明信息没有被篡改。\n\n生成信息摘要的过程叫做**签名**，验证信息摘要的过程叫做**验签**。\n\n哈希算法最著名的当属**MD5算法**。后来，人们觉得MD5算法生成的信息摘要太短（128位），不够安全，于是又有了**SHA系列算法**。\n\n------\n\n## 对称加密算法\n\n上面提到的哈希算法可以解决验签问题，却不能解决明文加密问题。\n\n### 什么是对称加密？\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazjwvskkzj30gw05c3z0.jpg)\n\n如图所示，一段明文通过密钥进行加密，可以生成一段密文；这段密文通过同样的密钥进行解密，可以还原成明文。这样一来，只要双方事先约定好了密钥，就可以使用密文进行往来通信。\n\n除了通信过程中的加密以外，数据库存储的敏感信息也可以通过这种方式进行加密。这样即使数据泄露到了外界，泄露出去的也都是密文。\n\n### 对称加密包含哪些算法？\n\n在早期，人们使用**DES算法**进行加密解密；后来，人们觉得DES不够安全，发明了**3DES**算法；而如今，最为流行的对称加密算法是**AES算法**。\n\n### 对称加密的优缺点\n\n对称算法的好处是加密解密的效率比较高，缺点是不够安全，因为通信双方约定的密钥是相同的，只要密钥本身被任何一方泄露出去，通信的密文就会被破解；此外，在双方建立通信之初，服务端把密钥告诉给客户端的时候，也有被拦截到的危险。\n\n------\n\n## 非对称加密算法\n\n### 什么是非对称加密？\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazk870sktj30ed09kmyf.jpg)\n\n如图所示，在非对称加密中存在一对密钥，一个叫做**公钥**，另一个叫做**私钥**。在加密解密的过程中，我们既可以使用公钥加密明文，使用私钥解密密文；也可以使用私钥加密明文，使用公钥解密密文。其中最著名的非对称加密当属**RSA算法**。\n\n### 非对称加密的通信过程\n\n1. 在双方建立通信的时候，服务端只把公钥发送给客户端，自己保留私钥。\n2. 客户端利用接受到的公钥，加密另外一个密钥X（可以是对称加密的密钥），发送给服务端。\n3. 服务端获得消息后，利用自己的私钥解密，得到里面隐含的密钥X。\n4. 从此以后，双方可以利用密钥X进行对称加密的通信了。\n\n### 非对称加密的优缺点\n\n好处就是安全性很高，在通信过程中，即使公钥被第三方截获，甚至后续的所有通信都被截获，第三方也无法进行破解。因为第二步利用公钥加密的消息，只有私钥才能解开，所以第三方永远无法知道密钥X是什么。\n\n缺点是性能较差，无法应用于长期的通信。","slug":"encryption","published":1,"updated":"2020-01-17T07:05:01.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bik000ea6ybb7um2c4d","content":"<h2 id=\"加密算法的种类\"><a href=\"#加密算法的种类\" class=\"headerlink\" title=\"加密算法的种类\"></a>加密算法的种类</h2><p>从宏观上来看，加密算法可以归结为三大类：<strong>哈希算法、对称加密算法、非对称加密算法。</strong></p>\n<h2 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h2><p>从严格意义上来说，<strong>哈希算法并不属于加密算法</strong>，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是<strong>生成信息摘要</strong>，用以验证原信息的完整性和来源的可靠性。</p>\n<p>举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，<strong>Hash（1234_100_abc） = 948569CD3466451F</strong>）</p>\n<a id=\"more\"></a>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazjr47fjuj30fp08d0t4.jpg\" alt></p>\n<p>请求方把所有参数，外加双方约定的key拼接起来，并利用哈希算法生成一段信息摘要，而接收方在接收到参数和摘要后，按照同样的规则，也把参数和key拼接起来生成摘要并进行比较，如果完全一致，则证明信息没有被篡改。</p>\n<p>生成信息摘要的过程叫做<strong>签名</strong>，验证信息摘要的过程叫做<strong>验签</strong>。</p>\n<p>哈希算法最著名的当属<strong>MD5算法</strong>。后来，人们觉得MD5算法生成的信息摘要太短（128位），不够安全，于是又有了<strong>SHA系列算法</strong>。</p>\n<hr>\n<h2 id=\"对称加密算法\"><a href=\"#对称加密算法\" class=\"headerlink\" title=\"对称加密算法\"></a>对称加密算法</h2><p>上面提到的哈希算法可以解决验签问题，却不能解决明文加密问题。</p>\n<h3 id=\"什么是对称加密？\"><a href=\"#什么是对称加密？\" class=\"headerlink\" title=\"什么是对称加密？\"></a>什么是对称加密？</h3><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazjwvskkzj30gw05c3z0.jpg\" alt></p>\n<p>如图所示，一段明文通过密钥进行加密，可以生成一段密文；这段密文通过同样的密钥进行解密，可以还原成明文。这样一来，只要双方事先约定好了密钥，就可以使用密文进行往来通信。</p>\n<p>除了通信过程中的加密以外，数据库存储的敏感信息也可以通过这种方式进行加密。这样即使数据泄露到了外界，泄露出去的也都是密文。</p>\n<h3 id=\"对称加密包含哪些算法？\"><a href=\"#对称加密包含哪些算法？\" class=\"headerlink\" title=\"对称加密包含哪些算法？\"></a>对称加密包含哪些算法？</h3><p>在早期，人们使用<strong>DES算法</strong>进行加密解密；后来，人们觉得DES不够安全，发明了<strong>3DES</strong>算法；而如今，最为流行的对称加密算法是<strong>AES算法</strong>。</p>\n<h3 id=\"对称加密的优缺点\"><a href=\"#对称加密的优缺点\" class=\"headerlink\" title=\"对称加密的优缺点\"></a>对称加密的优缺点</h3><p>对称算法的好处是加密解密的效率比较高，缺点是不够安全，因为通信双方约定的密钥是相同的，只要密钥本身被任何一方泄露出去，通信的密文就会被破解；此外，在双方建立通信之初，服务端把密钥告诉给客户端的时候，也有被拦截到的危险。</p>\n<hr>\n<h2 id=\"非对称加密算法\"><a href=\"#非对称加密算法\" class=\"headerlink\" title=\"非对称加密算法\"></a>非对称加密算法</h2><h3 id=\"什么是非对称加密？\"><a href=\"#什么是非对称加密？\" class=\"headerlink\" title=\"什么是非对称加密？\"></a>什么是非对称加密？</h3><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazk870sktj30ed09kmyf.jpg\" alt></p>\n<p>如图所示，在非对称加密中存在一对密钥，一个叫做<strong>公钥</strong>，另一个叫做<strong>私钥</strong>。在加密解密的过程中，我们既可以使用公钥加密明文，使用私钥解密密文；也可以使用私钥加密明文，使用公钥解密密文。其中最著名的非对称加密当属<strong>RSA算法</strong>。</p>\n<h3 id=\"非对称加密的通信过程\"><a href=\"#非对称加密的通信过程\" class=\"headerlink\" title=\"非对称加密的通信过程\"></a>非对称加密的通信过程</h3><ol>\n<li>在双方建立通信的时候，服务端只把公钥发送给客户端，自己保留私钥。</li>\n<li>客户端利用接受到的公钥，加密另外一个密钥X（可以是对称加密的密钥），发送给服务端。</li>\n<li>服务端获得消息后，利用自己的私钥解密，得到里面隐含的密钥X。</li>\n<li>从此以后，双方可以利用密钥X进行对称加密的通信了。</li>\n</ol>\n<h3 id=\"非对称加密的优缺点\"><a href=\"#非对称加密的优缺点\" class=\"headerlink\" title=\"非对称加密的优缺点\"></a>非对称加密的优缺点</h3><p>好处就是安全性很高，在通信过程中，即使公钥被第三方截获，甚至后续的所有通信都被截获，第三方也无法进行破解。因为第二步利用公钥加密的消息，只有私钥才能解开，所以第三方永远无法知道密钥X是什么。</p>\n<p>缺点是性能较差，无法应用于长期的通信。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"加密算法的种类\"><a href=\"#加密算法的种类\" class=\"headerlink\" title=\"加密算法的种类\"></a>加密算法的种类</h2><p>从宏观上来看，加密算法可以归结为三大类：<strong>哈希算法、对称加密算法、非对称加密算法。</strong></p>\n<h2 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h2><p>从严格意义上来说，<strong>哈希算法并不属于加密算法</strong>，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是<strong>生成信息摘要</strong>，用以验证原信息的完整性和来源的可靠性。</p>\n<p>举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，<strong>Hash（1234_100_abc） = 948569CD3466451F</strong>）</p>","more":"<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazjr47fjuj30fp08d0t4.jpg\" alt></p>\n<p>请求方把所有参数，外加双方约定的key拼接起来，并利用哈希算法生成一段信息摘要，而接收方在接收到参数和摘要后，按照同样的规则，也把参数和key拼接起来生成摘要并进行比较，如果完全一致，则证明信息没有被篡改。</p>\n<p>生成信息摘要的过程叫做<strong>签名</strong>，验证信息摘要的过程叫做<strong>验签</strong>。</p>\n<p>哈希算法最著名的当属<strong>MD5算法</strong>。后来，人们觉得MD5算法生成的信息摘要太短（128位），不够安全，于是又有了<strong>SHA系列算法</strong>。</p>\n<hr>\n<h2 id=\"对称加密算法\"><a href=\"#对称加密算法\" class=\"headerlink\" title=\"对称加密算法\"></a>对称加密算法</h2><p>上面提到的哈希算法可以解决验签问题，却不能解决明文加密问题。</p>\n<h3 id=\"什么是对称加密？\"><a href=\"#什么是对称加密？\" class=\"headerlink\" title=\"什么是对称加密？\"></a>什么是对称加密？</h3><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazjwvskkzj30gw05c3z0.jpg\" alt></p>\n<p>如图所示，一段明文通过密钥进行加密，可以生成一段密文；这段密文通过同样的密钥进行解密，可以还原成明文。这样一来，只要双方事先约定好了密钥，就可以使用密文进行往来通信。</p>\n<p>除了通信过程中的加密以外，数据库存储的敏感信息也可以通过这种方式进行加密。这样即使数据泄露到了外界，泄露出去的也都是密文。</p>\n<h3 id=\"对称加密包含哪些算法？\"><a href=\"#对称加密包含哪些算法？\" class=\"headerlink\" title=\"对称加密包含哪些算法？\"></a>对称加密包含哪些算法？</h3><p>在早期，人们使用<strong>DES算法</strong>进行加密解密；后来，人们觉得DES不够安全，发明了<strong>3DES</strong>算法；而如今，最为流行的对称加密算法是<strong>AES算法</strong>。</p>\n<h3 id=\"对称加密的优缺点\"><a href=\"#对称加密的优缺点\" class=\"headerlink\" title=\"对称加密的优缺点\"></a>对称加密的优缺点</h3><p>对称算法的好处是加密解密的效率比较高，缺点是不够安全，因为通信双方约定的密钥是相同的，只要密钥本身被任何一方泄露出去，通信的密文就会被破解；此外，在双方建立通信之初，服务端把密钥告诉给客户端的时候，也有被拦截到的危险。</p>\n<hr>\n<h2 id=\"非对称加密算法\"><a href=\"#非对称加密算法\" class=\"headerlink\" title=\"非对称加密算法\"></a>非对称加密算法</h2><h3 id=\"什么是非对称加密？\"><a href=\"#什么是非对称加密？\" class=\"headerlink\" title=\"什么是非对称加密？\"></a>什么是非对称加密？</h3><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazk870sktj30ed09kmyf.jpg\" alt></p>\n<p>如图所示，在非对称加密中存在一对密钥，一个叫做<strong>公钥</strong>，另一个叫做<strong>私钥</strong>。在加密解密的过程中，我们既可以使用公钥加密明文，使用私钥解密密文；也可以使用私钥加密明文，使用公钥解密密文。其中最著名的非对称加密当属<strong>RSA算法</strong>。</p>\n<h3 id=\"非对称加密的通信过程\"><a href=\"#非对称加密的通信过程\" class=\"headerlink\" title=\"非对称加密的通信过程\"></a>非对称加密的通信过程</h3><ol>\n<li>在双方建立通信的时候，服务端只把公钥发送给客户端，自己保留私钥。</li>\n<li>客户端利用接受到的公钥，加密另外一个密钥X（可以是对称加密的密钥），发送给服务端。</li>\n<li>服务端获得消息后，利用自己的私钥解密，得到里面隐含的密钥X。</li>\n<li>从此以后，双方可以利用密钥X进行对称加密的通信了。</li>\n</ol>\n<h3 id=\"非对称加密的优缺点\"><a href=\"#非对称加密的优缺点\" class=\"headerlink\" title=\"非对称加密的优缺点\"></a>非对称加密的优缺点</h3><p>好处就是安全性很高，在通信过程中，即使公钥被第三方截获，甚至后续的所有通信都被截获，第三方也无法进行破解。因为第二步利用公钥加密的消息，只有私钥才能解开，所以第三方永远无法知道密钥X是什么。</p>\n<p>缺点是性能较差，无法应用于长期的通信。</p>"},{"title":"工厂模式的特点、适用场景、注意事项以及常见问题","date":"2017-11-10T09:11:23.000Z","_content":"\n## 定义\n\n工厂模式是 Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。\n\n## 工厂模式根据抽象程度分为三种\n\n- 简单工厂模式（也叫静态工厂模式）\n- 工厂方法模式（也叫多形性工厂）\n- 抽象工厂模式（也叫工具箱）\n\n<!-- more -->\n\n### 简单工厂模式\n\n实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。\n\n### 工厂方法模式\n\n工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。 提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。\n\n### 抽象工厂模式\n\n当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。\n\n**工厂方法模式应该在实际中用的较多，我们以工厂方法模式举例（例子来源百度，帮助理解）**\n\n抽象的产品类：定义car 交通工具类\n\n```java\npublic interface Car {    \n    void gotowork();\n}\n```\n\n定义实际的产品类，总共定义两个，bike 和bus 分别表示不同的交通工具类\n\n```java\npublic class Bike implements Car {\n    @Override\n    public void gotowork() {\n        System.out.println(\"骑自行车去上班！\");\n    }\n}\n\npublic class Bus implements Car {\n    @Override\n    public void gotowork() {\n        System.out.println(\"坐公交车去上班！\");\n    }\n}\n```\n\n定义抽象的工厂接口\n\n```java\npublic interface ICarFactory {\n    Car getCar();\n}\n```\n\n具体的工厂子类，分别为每个具体的产品类创建不同的工厂子类\n\n```java\npublic class BikeFactory implements ICarFactory {\n    @Override\n    public Car getCar() {\n        return new Bike();\n    }\n}\n\n\npublic class BusFactory implements ICarFactory {    \n@Override\n    public Car getCar() {        \n        return new Bus();\n    }\n}\n```\n\n简单的测试类，来验证不同的工厂能够产生不同的产品对象\n\n```java\npublic class TestFactory {\n    @Test\n    public void test() {\n        ICarFactory factory = null;\n        // bike\n        factory = new BikeFactory();\n        Car bike = factory.getCar();\n        bike.gotowork();\n\n        // bus\n        factory = new BusFactory();\n        Car bus = factory.getCar();\n        bus.gotowork();\n    }\n}\n```\n\n## 工厂模式的优点\n\n1、一个调用者想创建一个对象，只要知道其名称就可以了，降低了耦合度。\n\n2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。使得代码结构更加清晰。\n\n3、屏蔽产品的具体实现，调用者只关心产品的接口。\n\n## 工厂模式的缺点\n\n每次增加一个产品时，都需要增加一个具体类和对象实现工厂（这里可以使用反射机制来避免），使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。所以对于简单对象来说，使用工厂模式反而增加了复杂度。\n\n## 工厂模式的适用场景\n\n1， 一个对象拥有很多子类。\n\n2， 创建某个对象时需要进行许多额外的操作。\n\n3， 系统后期需要经常扩展，它把对象实例化的任务交由实现类完成，扩展性好。\n\n## 关于工厂模式的一些常见问题\n\n利用父类的向下转型（使用父类类型的引用指向子类的对象）是可以达到类似于工厂模式的效果的，那为什么还要用工厂模式呢？\n\n把指向子类对象的父类引用赋给子类引用叫做向下转型，如：\n\n```java\nClass Student extends Person     \nPerson s = new Student();    \ns = (Student)person ;\n```\n\n使用向下转型在客户端实例化子类的时候，严重依赖具体的子类的名字。当我们需要更改子类的构造方法的时候，比如增加一个参数，或者更改了子类的类名，所有的new出来的子类都需要跟着更改。\n\n但如果我们使用工厂模式，我们仅仅需要在工厂中修改一下new的代码，其余项目中用到此实例的都会跟着改，而不需要我们手动去操作。\n\n## 总结\n\n无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。","source":"_posts/factory.md","raw":"---\ntitle: 工厂模式的特点、适用场景、注意事项以及常见问题\ndate: 2017-11-10 17:11:23\ncategories: \n  - Java\n  - 设计模式\ntags:\n  - 设计模式\n  - factory\n---\n\n## 定义\n\n工厂模式是 Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n\n工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。\n\n## 工厂模式根据抽象程度分为三种\n\n- 简单工厂模式（也叫静态工厂模式）\n- 工厂方法模式（也叫多形性工厂）\n- 抽象工厂模式（也叫工具箱）\n\n<!-- more -->\n\n### 简单工厂模式\n\n实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。\n\n### 工厂方法模式\n\n工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。 提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。\n\n### 抽象工厂模式\n\n当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。\n\n**工厂方法模式应该在实际中用的较多，我们以工厂方法模式举例（例子来源百度，帮助理解）**\n\n抽象的产品类：定义car 交通工具类\n\n```java\npublic interface Car {    \n    void gotowork();\n}\n```\n\n定义实际的产品类，总共定义两个，bike 和bus 分别表示不同的交通工具类\n\n```java\npublic class Bike implements Car {\n    @Override\n    public void gotowork() {\n        System.out.println(\"骑自行车去上班！\");\n    }\n}\n\npublic class Bus implements Car {\n    @Override\n    public void gotowork() {\n        System.out.println(\"坐公交车去上班！\");\n    }\n}\n```\n\n定义抽象的工厂接口\n\n```java\npublic interface ICarFactory {\n    Car getCar();\n}\n```\n\n具体的工厂子类，分别为每个具体的产品类创建不同的工厂子类\n\n```java\npublic class BikeFactory implements ICarFactory {\n    @Override\n    public Car getCar() {\n        return new Bike();\n    }\n}\n\n\npublic class BusFactory implements ICarFactory {    \n@Override\n    public Car getCar() {        \n        return new Bus();\n    }\n}\n```\n\n简单的测试类，来验证不同的工厂能够产生不同的产品对象\n\n```java\npublic class TestFactory {\n    @Test\n    public void test() {\n        ICarFactory factory = null;\n        // bike\n        factory = new BikeFactory();\n        Car bike = factory.getCar();\n        bike.gotowork();\n\n        // bus\n        factory = new BusFactory();\n        Car bus = factory.getCar();\n        bus.gotowork();\n    }\n}\n```\n\n## 工厂模式的优点\n\n1、一个调用者想创建一个对象，只要知道其名称就可以了，降低了耦合度。\n\n2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。使得代码结构更加清晰。\n\n3、屏蔽产品的具体实现，调用者只关心产品的接口。\n\n## 工厂模式的缺点\n\n每次增加一个产品时，都需要增加一个具体类和对象实现工厂（这里可以使用反射机制来避免），使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。所以对于简单对象来说，使用工厂模式反而增加了复杂度。\n\n## 工厂模式的适用场景\n\n1， 一个对象拥有很多子类。\n\n2， 创建某个对象时需要进行许多额外的操作。\n\n3， 系统后期需要经常扩展，它把对象实例化的任务交由实现类完成，扩展性好。\n\n## 关于工厂模式的一些常见问题\n\n利用父类的向下转型（使用父类类型的引用指向子类的对象）是可以达到类似于工厂模式的效果的，那为什么还要用工厂模式呢？\n\n把指向子类对象的父类引用赋给子类引用叫做向下转型，如：\n\n```java\nClass Student extends Person     \nPerson s = new Student();    \ns = (Student)person ;\n```\n\n使用向下转型在客户端实例化子类的时候，严重依赖具体的子类的名字。当我们需要更改子类的构造方法的时候，比如增加一个参数，或者更改了子类的类名，所有的new出来的子类都需要跟着更改。\n\n但如果我们使用工厂模式，我们仅仅需要在工厂中修改一下new的代码，其余项目中用到此实例的都会跟着改，而不需要我们手动去操作。\n\n## 总结\n\n无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。","slug":"factory","published":1,"updated":"2020-01-17T05:10:26.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bil000ga6ybvqvdka2a","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>工厂模式是 Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p>\n<h2 id=\"工厂模式根据抽象程度分为三种\"><a href=\"#工厂模式根据抽象程度分为三种\" class=\"headerlink\" title=\"工厂模式根据抽象程度分为三种\"></a>工厂模式根据抽象程度分为三种</h2><ul>\n<li>简单工厂模式（也叫静态工厂模式）</li>\n<li>工厂方法模式（也叫多形性工厂）</li>\n<li>抽象工厂模式（也叫工具箱）</li>\n</ul>\n<a id=\"more\"></a>\n\n<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><p>实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</p>\n<h3 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h3><p>工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。 提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。</p>\n<h3 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h3><p>当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。</p>\n<p><strong>工厂方法模式应该在实际中用的较多，我们以工厂方法模式举例（例子来源百度，帮助理解）</strong></p>\n<p>抽象的产品类：定义car 交通工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Car</span> </span>&#123;    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">gotowork</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义实际的产品类，总共定义两个，bike 和bus 分别表示不同的交通工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bike</span> <span class=\"keyword\">implements</span> <span class=\"title\">Car</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">gotowork</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"骑自行车去上班！\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">implements</span> <span class=\"title\">Car</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">gotowork</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"坐公交车去上班！\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义抽象的工厂接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ICarFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Car <span class=\"title\">getCar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体的工厂子类，分别为每个具体的产品类创建不同的工厂子类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BikeFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ICarFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Car <span class=\"title\">getCar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Bike();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BusFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ICarFactory</span> </span>&#123;    </span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Car <span class=\"title\">getCar</span><span class=\"params\">()</span> </span>&#123;        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Bus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单的测试类，来验证不同的工厂能够产生不同的产品对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ICarFactory factory = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// bike</span></span><br><span class=\"line\">        factory = <span class=\"keyword\">new</span> BikeFactory();</span><br><span class=\"line\">        Car bike = factory.getCar();</span><br><span class=\"line\">        bike.gotowork();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// bus</span></span><br><span class=\"line\">        factory = <span class=\"keyword\">new</span> BusFactory();</span><br><span class=\"line\">        Car bus = factory.getCar();</span><br><span class=\"line\">        bus.gotowork();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工厂模式的优点\"><a href=\"#工厂模式的优点\" class=\"headerlink\" title=\"工厂模式的优点\"></a>工厂模式的优点</h2><p>1、一个调用者想创建一个对象，只要知道其名称就可以了，降低了耦合度。</p>\n<p>2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。使得代码结构更加清晰。</p>\n<p>3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>\n<h2 id=\"工厂模式的缺点\"><a href=\"#工厂模式的缺点\" class=\"headerlink\" title=\"工厂模式的缺点\"></a>工厂模式的缺点</h2><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂（这里可以使用反射机制来避免），使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。所以对于简单对象来说，使用工厂模式反而增加了复杂度。</p>\n<h2 id=\"工厂模式的适用场景\"><a href=\"#工厂模式的适用场景\" class=\"headerlink\" title=\"工厂模式的适用场景\"></a>工厂模式的适用场景</h2><p>1， 一个对象拥有很多子类。</p>\n<p>2， 创建某个对象时需要进行许多额外的操作。</p>\n<p>3， 系统后期需要经常扩展，它把对象实例化的任务交由实现类完成，扩展性好。</p>\n<h2 id=\"关于工厂模式的一些常见问题\"><a href=\"#关于工厂模式的一些常见问题\" class=\"headerlink\" title=\"关于工厂模式的一些常见问题\"></a>关于工厂模式的一些常见问题</h2><p>利用父类的向下转型（使用父类类型的引用指向子类的对象）是可以达到类似于工厂模式的效果的，那为什么还要用工厂模式呢？</p>\n<p>把指向子类对象的父类引用赋给子类引用叫做向下转型，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Student extends Person     </span><br><span class=\"line\">Person s = <span class=\"keyword\">new</span> Student();    </span><br><span class=\"line\">s = (Student)person ;</span><br></pre></td></tr></table></figure>\n\n<p>使用向下转型在客户端实例化子类的时候，严重依赖具体的子类的名字。当我们需要更改子类的构造方法的时候，比如增加一个参数，或者更改了子类的类名，所有的new出来的子类都需要跟着更改。</p>\n<p>但如果我们使用工厂模式，我们仅仅需要在工厂中修改一下new的代码，其余项目中用到此实例的都会跟着改，而不需要我们手动去操作。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>工厂模式是 Java中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>\n<p>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p>\n<h2 id=\"工厂模式根据抽象程度分为三种\"><a href=\"#工厂模式根据抽象程度分为三种\" class=\"headerlink\" title=\"工厂模式根据抽象程度分为三种\"></a>工厂模式根据抽象程度分为三种</h2><ul>\n<li>简单工厂模式（也叫静态工厂模式）</li>\n<li>工厂方法模式（也叫多形性工厂）</li>\n<li>抽象工厂模式（也叫工具箱）</li>\n</ul>","more":"<h3 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h3><p>实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。</p>\n<h3 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h3><p>工厂方法是粒度很小的设计模式，因为模式的表现只是一个抽象的方法。 提前定义用于创建对象的接口，让子类决定实例化具体的某一个类，即在工厂和产品中间增加接口，工厂不再负责产品的创建，由接口针对不同条件返回具体的类实例，由具体类实例去实现。</p>\n<h3 id=\"抽象工厂模式\"><a href=\"#抽象工厂模式\" class=\"headerlink\" title=\"抽象工厂模式\"></a>抽象工厂模式</h3><p>当有多个抽象角色时使用的一种工厂模式。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品对象。它有多个抽象产品类，每个抽象产品类可以派生出多个具体产品类，一个抽象工厂类，可以派生出多个具体工厂类，每个具体工厂类可以创建多个具体产品类的实例。</p>\n<p><strong>工厂方法模式应该在实际中用的较多，我们以工厂方法模式举例（例子来源百度，帮助理解）</strong></p>\n<p>抽象的产品类：定义car 交通工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Car</span> </span>&#123;    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">gotowork</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义实际的产品类，总共定义两个，bike 和bus 分别表示不同的交通工具类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bike</span> <span class=\"keyword\">implements</span> <span class=\"title\">Car</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">gotowork</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"骑自行车去上班！\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bus</span> <span class=\"keyword\">implements</span> <span class=\"title\">Car</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">gotowork</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"坐公交车去上班！\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>定义抽象的工厂接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ICarFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">Car <span class=\"title\">getCar</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>具体的工厂子类，分别为每个具体的产品类创建不同的工厂子类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BikeFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ICarFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Car <span class=\"title\">getCar</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Bike();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BusFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ICarFactory</span> </span>&#123;    </span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Car <span class=\"title\">getCar</span><span class=\"params\">()</span> </span>&#123;        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Bus();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>简单的测试类，来验证不同的工厂能够产生不同的产品对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestFactory</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ICarFactory factory = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// bike</span></span><br><span class=\"line\">        factory = <span class=\"keyword\">new</span> BikeFactory();</span><br><span class=\"line\">        Car bike = factory.getCar();</span><br><span class=\"line\">        bike.gotowork();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// bus</span></span><br><span class=\"line\">        factory = <span class=\"keyword\">new</span> BusFactory();</span><br><span class=\"line\">        Car bus = factory.getCar();</span><br><span class=\"line\">        bus.gotowork();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"工厂模式的优点\"><a href=\"#工厂模式的优点\" class=\"headerlink\" title=\"工厂模式的优点\"></a>工厂模式的优点</h2><p>1、一个调用者想创建一个对象，只要知道其名称就可以了，降低了耦合度。</p>\n<p>2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。使得代码结构更加清晰。</p>\n<p>3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>\n<h2 id=\"工厂模式的缺点\"><a href=\"#工厂模式的缺点\" class=\"headerlink\" title=\"工厂模式的缺点\"></a>工厂模式的缺点</h2><p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂（这里可以使用反射机制来避免），使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。所以对于简单对象来说，使用工厂模式反而增加了复杂度。</p>\n<h2 id=\"工厂模式的适用场景\"><a href=\"#工厂模式的适用场景\" class=\"headerlink\" title=\"工厂模式的适用场景\"></a>工厂模式的适用场景</h2><p>1， 一个对象拥有很多子类。</p>\n<p>2， 创建某个对象时需要进行许多额外的操作。</p>\n<p>3， 系统后期需要经常扩展，它把对象实例化的任务交由实现类完成，扩展性好。</p>\n<h2 id=\"关于工厂模式的一些常见问题\"><a href=\"#关于工厂模式的一些常见问题\" class=\"headerlink\" title=\"关于工厂模式的一些常见问题\"></a>关于工厂模式的一些常见问题</h2><p>利用父类的向下转型（使用父类类型的引用指向子类的对象）是可以达到类似于工厂模式的效果的，那为什么还要用工厂模式呢？</p>\n<p>把指向子类对象的父类引用赋给子类引用叫做向下转型，如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Student extends Person     </span><br><span class=\"line\">Person s = <span class=\"keyword\">new</span> Student();    </span><br><span class=\"line\">s = (Student)person ;</span><br></pre></td></tr></table></figure>\n\n<p>使用向下转型在客户端实例化子类的时候，严重依赖具体的子类的名字。当我们需要更改子类的构造方法的时候，比如增加一个参数，或者更改了子类的类名，所有的new出来的子类都需要跟着更改。</p>\n<p>但如果我们使用工厂模式，我们仅仅需要在工厂中修改一下new的代码，其余项目中用到此实例的都会跟着改，而不需要我们手动去操作。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的部分提取出来，将可变的部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。</p>"},{"title":"CentOS 7防火墙设置-iptables","date":"2020-02-17T07:29:48.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash3mdauaj31960u04qp.jpg","_content":"\n### 关闭默认防火墙\n\nCentOS 7默认使用的防火墙是firewall，需要将其关闭\n\n- systemctl stop firewalld.service #停止firewall\n- systemctl disable firewalld.service #禁止firewall开机启动\n\n### 安装 iptables service\n\nyum -y install iptables-services\n\n### 编辑配置文件\n\nvi /etc/sysconfig/iptables <!--more-->\n\n### 在配置文件中增加规则\n\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\n\n### 保存退出，重启防火墙\n\n- systemctl restart iptables.service #重启防火墙使配置生效\n- systemctl enable iptables.service #设置防火墙开机启动\n\n### iptables防火墙常用命令\n\n- systemctl start iptables.service #打开防火墙\n- systemctl stop iptables.service #关闭防火墙\n- systemctl restart iptables.service #重启防火墙","source":"_posts/firewall.md","raw":"---\ntitle: CentOS 7防火墙设置-iptables\ndate: 2020-02-17 15:29:48\ncategories: System\ntags: \n  - CentOS\n  - FireWall\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash3mdauaj31960u04qp.jpg\n---\n\n### 关闭默认防火墙\n\nCentOS 7默认使用的防火墙是firewall，需要将其关闭\n\n- systemctl stop firewalld.service #停止firewall\n- systemctl disable firewalld.service #禁止firewall开机启动\n\n### 安装 iptables service\n\nyum -y install iptables-services\n\n### 编辑配置文件\n\nvi /etc/sysconfig/iptables <!--more-->\n\n### 在配置文件中增加规则\n\n-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT\n\n### 保存退出，重启防火墙\n\n- systemctl restart iptables.service #重启防火墙使配置生效\n- systemctl enable iptables.service #设置防火墙开机启动\n\n### iptables防火墙常用命令\n\n- systemctl start iptables.service #打开防火墙\n- systemctl stop iptables.service #关闭防火墙\n- systemctl restart iptables.service #重启防火墙","slug":"firewall","published":1,"updated":"2020-02-17T07:56:54.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bio000ka6ybraxtcqaw","content":"<h3 id=\"关闭默认防火墙\"><a href=\"#关闭默认防火墙\" class=\"headerlink\" title=\"关闭默认防火墙\"></a>关闭默认防火墙</h3><p>CentOS 7默认使用的防火墙是firewall，需要将其关闭</p>\n<ul>\n<li>systemctl stop firewalld.service #停止firewall</li>\n<li>systemctl disable firewalld.service #禁止firewall开机启动</li>\n</ul>\n<h3 id=\"安装-iptables-service\"><a href=\"#安装-iptables-service\" class=\"headerlink\" title=\"安装 iptables service\"></a>安装 iptables service</h3><p>yum -y install iptables-services</p>\n<h3 id=\"编辑配置文件\"><a href=\"#编辑配置文件\" class=\"headerlink\" title=\"编辑配置文件\"></a>编辑配置文件</h3><p>vi /etc/sysconfig/iptables <a id=\"more\"></a></p>\n<h3 id=\"在配置文件中增加规则\"><a href=\"#在配置文件中增加规则\" class=\"headerlink\" title=\"在配置文件中增加规则\"></a>在配置文件中增加规则</h3><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT</p>\n<h3 id=\"保存退出，重启防火墙\"><a href=\"#保存退出，重启防火墙\" class=\"headerlink\" title=\"保存退出，重启防火墙\"></a>保存退出，重启防火墙</h3><ul>\n<li>systemctl restart iptables.service #重启防火墙使配置生效</li>\n<li>systemctl enable iptables.service #设置防火墙开机启动</li>\n</ul>\n<h3 id=\"iptables防火墙常用命令\"><a href=\"#iptables防火墙常用命令\" class=\"headerlink\" title=\"iptables防火墙常用命令\"></a>iptables防火墙常用命令</h3><ul>\n<li>systemctl start iptables.service #打开防火墙</li>\n<li>systemctl stop iptables.service #关闭防火墙</li>\n<li>systemctl restart iptables.service #重启防火墙</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h3 id=\"关闭默认防火墙\"><a href=\"#关闭默认防火墙\" class=\"headerlink\" title=\"关闭默认防火墙\"></a>关闭默认防火墙</h3><p>CentOS 7默认使用的防火墙是firewall，需要将其关闭</p>\n<ul>\n<li>systemctl stop firewalld.service #停止firewall</li>\n<li>systemctl disable firewalld.service #禁止firewall开机启动</li>\n</ul>\n<h3 id=\"安装-iptables-service\"><a href=\"#安装-iptables-service\" class=\"headerlink\" title=\"安装 iptables service\"></a>安装 iptables service</h3><p>yum -y install iptables-services</p>\n<h3 id=\"编辑配置文件\"><a href=\"#编辑配置文件\" class=\"headerlink\" title=\"编辑配置文件\"></a>编辑配置文件</h3><p>vi /etc/sysconfig/iptables","more":"</p>\n<h3 id=\"在配置文件中增加规则\"><a href=\"#在配置文件中增加规则\" class=\"headerlink\" title=\"在配置文件中增加规则\"></a>在配置文件中增加规则</h3><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT</p>\n<h3 id=\"保存退出，重启防火墙\"><a href=\"#保存退出，重启防火墙\" class=\"headerlink\" title=\"保存退出，重启防火墙\"></a>保存退出，重启防火墙</h3><ul>\n<li>systemctl restart iptables.service #重启防火墙使配置生效</li>\n<li>systemctl enable iptables.service #设置防火墙开机启动</li>\n</ul>\n<h3 id=\"iptables防火墙常用命令\"><a href=\"#iptables防火墙常用命令\" class=\"headerlink\" title=\"iptables防火墙常用命令\"></a>iptables防火墙常用命令</h3><ul>\n<li>systemctl start iptables.service #打开防火墙</li>\n<li>systemctl stop iptables.service #关闭防火墙</li>\n<li>systemctl restart iptables.service #重启防火墙</li>\n</ul>"},{"title":"macOS 超实用的「免费」软件推荐,使用经验分享！","date":"2020-01-06T14:34:14.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash3mdauaj31960u04qp.jpg","_content":"\n## iTerm2\n\n概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它\n\n功能介绍：https://iterm2.com/features.html\n\n官方下载地址：https://iterm2.com/downloads.html\n\n推荐指数：★★★★★\n\n<!-- more -->\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapj5io7l5j30wo0oqtxl.jpg)\n\n## IINA\n\n概括：强大的本地视频播放器，解析能力稍逊于Movist Pro，优点是启动快\n\n功能介绍：https://zhuanlan.zhihu.com/p/24700324\n\n官方下载地址：https://iina.io/\n\n推荐指数：★★★★☆（Movist Pro 是满分😄）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapjhaq2s3j31100n87wh.jpg)\n\n\n\n## Typora\n\n概括：支持实时预览的Markdown文本编辑器\n\n功能介绍：https://sspai.com/post/54912\n\n官方下载地址：https://www.typora.io/\n\n推荐指数：★★★★★（我的博文都是用Typora编辑的，功不可没，必须满分💯）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapjq9ocukj31140u07wh.jpg)\n\n\n\n## iPic\n\n概括：Markdown 图床、文件上传工具，免费版足够用\n\n功能介绍：https://toolinbox.net/iPic/\n\n官方下载地址：已经上架 App Store，搜索下载即可\n\n推荐指数：★★★★★（博文中使用到的图片都是通过 iPic 实现加载的）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapkz2l0nbj30kr0eswxg.jpg)\n\n\n\n## Visual Studio Code\n\n概括：简称 VS Code，非常强大的代码文本编辑器，支持大量插件\n\n功能介绍：https://www.cnblogs.com/clwydjgs/p/10078065.html\n\n官方下载地址：https://code.visualstudio.com/\n\n推荐指数：★★★★★（相较于 Sublime Text 来说，我更倾向于 VS Code）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapjujriamj315s0u0qte.jpg)\n\n\n\n## Better And Better\n\n概括：简称BAB，这是一款非常全能的软件，有了它基本可以替代一堆应用\n\n功能介绍：https://www.better365.cn/tv.html\n\n官方下载地址：https://www.better365.cn/bab.html\n\n推荐指数：★★★☆☆（偶尔有软件冲突，导致系统运行缓慢）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapk8a5vs6j31450u07wh.jpg)\n\n\n\n## iShot\n\n概括：强大的截图工具，与BAB同属一个开发团队，旗下还有Better Menubar和自动切换输入法\n\n功能介绍：https://sspai.com/post/57302\n\n官方下载地址：已经上架 App Store，搜索下载即可\n\n推荐指数：★★★★★（支持截图和录屏，使用下来个人觉得要优于Xnip和Snip）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapk4hc4b2j30u00vbb1l.jpg)\n\n\n\n## Final Shell\n\n概括：Mac上的 shell 工具，用于连接远程服务器，支持sftp\n\n功能介绍：https://blog.csdn.net/sinat_25838589/article/details/79781241\n\n官方下载地址：http://www.hostbuf.com/t/988.html\n\n推荐指数：★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapkzesnj7j30w40sswi2.jpg)","source":"_posts/macappfree.md","raw":"---\ntitle: macOS 超实用的「免费」软件推荐,使用经验分享！\ndate: 2020-01-06 22:34:14\ncategories: System\ntags:\n  - macOS\n  - free apps\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash3mdauaj31960u04qp.jpg\n---\n\n## iTerm2\n\n概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它\n\n功能介绍：https://iterm2.com/features.html\n\n官方下载地址：https://iterm2.com/downloads.html\n\n推荐指数：★★★★★\n\n<!-- more -->\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapj5io7l5j30wo0oqtxl.jpg)\n\n## IINA\n\n概括：强大的本地视频播放器，解析能力稍逊于Movist Pro，优点是启动快\n\n功能介绍：https://zhuanlan.zhihu.com/p/24700324\n\n官方下载地址：https://iina.io/\n\n推荐指数：★★★★☆（Movist Pro 是满分😄）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapjhaq2s3j31100n87wh.jpg)\n\n\n\n## Typora\n\n概括：支持实时预览的Markdown文本编辑器\n\n功能介绍：https://sspai.com/post/54912\n\n官方下载地址：https://www.typora.io/\n\n推荐指数：★★★★★（我的博文都是用Typora编辑的，功不可没，必须满分💯）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapjq9ocukj31140u07wh.jpg)\n\n\n\n## iPic\n\n概括：Markdown 图床、文件上传工具，免费版足够用\n\n功能介绍：https://toolinbox.net/iPic/\n\n官方下载地址：已经上架 App Store，搜索下载即可\n\n推荐指数：★★★★★（博文中使用到的图片都是通过 iPic 实现加载的）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapkz2l0nbj30kr0eswxg.jpg)\n\n\n\n## Visual Studio Code\n\n概括：简称 VS Code，非常强大的代码文本编辑器，支持大量插件\n\n功能介绍：https://www.cnblogs.com/clwydjgs/p/10078065.html\n\n官方下载地址：https://code.visualstudio.com/\n\n推荐指数：★★★★★（相较于 Sublime Text 来说，我更倾向于 VS Code）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapjujriamj315s0u0qte.jpg)\n\n\n\n## Better And Better\n\n概括：简称BAB，这是一款非常全能的软件，有了它基本可以替代一堆应用\n\n功能介绍：https://www.better365.cn/tv.html\n\n官方下载地址：https://www.better365.cn/bab.html\n\n推荐指数：★★★☆☆（偶尔有软件冲突，导致系统运行缓慢）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapk8a5vs6j31450u07wh.jpg)\n\n\n\n## iShot\n\n概括：强大的截图工具，与BAB同属一个开发团队，旗下还有Better Menubar和自动切换输入法\n\n功能介绍：https://sspai.com/post/57302\n\n官方下载地址：已经上架 App Store，搜索下载即可\n\n推荐指数：★★★★★（支持截图和录屏，使用下来个人觉得要优于Xnip和Snip）\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapk4hc4b2j30u00vbb1l.jpg)\n\n\n\n## Final Shell\n\n概括：Mac上的 shell 工具，用于连接远程服务器，支持sftp\n\n功能介绍：https://blog.csdn.net/sinat_25838589/article/details/79781241\n\n官方下载地址：http://www.hostbuf.com/t/988.html\n\n推荐指数：★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gapkzesnj7j30w40sswi2.jpg)","slug":"macappfree","published":1,"updated":"2020-01-13T02:30:21.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61biq000la6ybc0kua0yz","content":"<h2 id=\"iTerm2\"><a href=\"#iTerm2\" class=\"headerlink\" title=\"iTerm2\"></a>iTerm2</h2><p>概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它</p>\n<p>功能介绍：<a href=\"https://iterm2.com/features.html\" target=\"_blank\" rel=\"noopener\">https://iterm2.com/features.html</a></p>\n<p>官方下载地址：<a href=\"https://iterm2.com/downloads.html\" target=\"_blank\" rel=\"noopener\">https://iterm2.com/downloads.html</a></p>\n<p>推荐指数：★★★★★</p>\n<a id=\"more\"></a>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapj5io7l5j30wo0oqtxl.jpg\" alt></p>\n<h2 id=\"IINA\"><a href=\"#IINA\" class=\"headerlink\" title=\"IINA\"></a>IINA</h2><p>概括：强大的本地视频播放器，解析能力稍逊于Movist Pro，优点是启动快</p>\n<p>功能介绍：<a href=\"https://zhuanlan.zhihu.com/p/24700324\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/24700324</a></p>\n<p>官方下载地址：<a href=\"https://iina.io/\" target=\"_blank\" rel=\"noopener\">https://iina.io/</a></p>\n<p>推荐指数：★★★★☆（Movist Pro 是满分😄）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapjhaq2s3j31100n87wh.jpg\" alt></p>\n<h2 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h2><p>概括：支持实时预览的Markdown文本编辑器</p>\n<p>功能介绍：<a href=\"https://sspai.com/post/54912\" target=\"_blank\" rel=\"noopener\">https://sspai.com/post/54912</a></p>\n<p>官方下载地址：<a href=\"https://www.typora.io/\" target=\"_blank\" rel=\"noopener\">https://www.typora.io/</a></p>\n<p>推荐指数：★★★★★（我的博文都是用Typora编辑的，功不可没，必须满分💯）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapjq9ocukj31140u07wh.jpg\" alt></p>\n<h2 id=\"iPic\"><a href=\"#iPic\" class=\"headerlink\" title=\"iPic\"></a>iPic</h2><p>概括：Markdown 图床、文件上传工具，免费版足够用</p>\n<p>功能介绍：<a href=\"https://toolinbox.net/iPic/\" target=\"_blank\" rel=\"noopener\">https://toolinbox.net/iPic/</a></p>\n<p>官方下载地址：已经上架 App Store，搜索下载即可</p>\n<p>推荐指数：★★★★★（博文中使用到的图片都是通过 iPic 实现加载的）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapkz2l0nbj30kr0eswxg.jpg\" alt></p>\n<h2 id=\"Visual-Studio-Code\"><a href=\"#Visual-Studio-Code\" class=\"headerlink\" title=\"Visual Studio Code\"></a>Visual Studio Code</h2><p>概括：简称 VS Code，非常强大的代码文本编辑器，支持大量插件</p>\n<p>功能介绍：<a href=\"https://www.cnblogs.com/clwydjgs/p/10078065.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/clwydjgs/p/10078065.html</a></p>\n<p>官方下载地址：<a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">https://code.visualstudio.com/</a></p>\n<p>推荐指数：★★★★★（相较于 Sublime Text 来说，我更倾向于 VS Code）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapjujriamj315s0u0qte.jpg\" alt></p>\n<h2 id=\"Better-And-Better\"><a href=\"#Better-And-Better\" class=\"headerlink\" title=\"Better And Better\"></a>Better And Better</h2><p>概括：简称BAB，这是一款非常全能的软件，有了它基本可以替代一堆应用</p>\n<p>功能介绍：<a href=\"https://www.better365.cn/tv.html\" target=\"_blank\" rel=\"noopener\">https://www.better365.cn/tv.html</a></p>\n<p>官方下载地址：<a href=\"https://www.better365.cn/bab.html\" target=\"_blank\" rel=\"noopener\">https://www.better365.cn/bab.html</a></p>\n<p>推荐指数：★★★☆☆（偶尔有软件冲突，导致系统运行缓慢）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapk8a5vs6j31450u07wh.jpg\" alt></p>\n<h2 id=\"iShot\"><a href=\"#iShot\" class=\"headerlink\" title=\"iShot\"></a>iShot</h2><p>概括：强大的截图工具，与BAB同属一个开发团队，旗下还有Better Menubar和自动切换输入法</p>\n<p>功能介绍：<a href=\"https://sspai.com/post/57302\" target=\"_blank\" rel=\"noopener\">https://sspai.com/post/57302</a></p>\n<p>官方下载地址：已经上架 App Store，搜索下载即可</p>\n<p>推荐指数：★★★★★（支持截图和录屏，使用下来个人觉得要优于Xnip和Snip）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapk4hc4b2j30u00vbb1l.jpg\" alt></p>\n<h2 id=\"Final-Shell\"><a href=\"#Final-Shell\" class=\"headerlink\" title=\"Final Shell\"></a>Final Shell</h2><p>概括：Mac上的 shell 工具，用于连接远程服务器，支持sftp</p>\n<p>功能介绍：<a href=\"https://blog.csdn.net/sinat_25838589/article/details/79781241\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sinat_25838589/article/details/79781241</a></p>\n<p>官方下载地址：<a href=\"http://www.hostbuf.com/t/988.html\" target=\"_blank\" rel=\"noopener\">http://www.hostbuf.com/t/988.html</a></p>\n<p>推荐指数：★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapkzesnj7j30w40sswi2.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"iTerm2\"><a href=\"#iTerm2\" class=\"headerlink\" title=\"iTerm2\"></a>iTerm2</h2><p>概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它</p>\n<p>功能介绍：<a href=\"https://iterm2.com/features.html\" target=\"_blank\" rel=\"noopener\">https://iterm2.com/features.html</a></p>\n<p>官方下载地址：<a href=\"https://iterm2.com/downloads.html\" target=\"_blank\" rel=\"noopener\">https://iterm2.com/downloads.html</a></p>\n<p>推荐指数：★★★★★</p>","more":"<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapj5io7l5j30wo0oqtxl.jpg\" alt></p>\n<h2 id=\"IINA\"><a href=\"#IINA\" class=\"headerlink\" title=\"IINA\"></a>IINA</h2><p>概括：强大的本地视频播放器，解析能力稍逊于Movist Pro，优点是启动快</p>\n<p>功能介绍：<a href=\"https://zhuanlan.zhihu.com/p/24700324\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/24700324</a></p>\n<p>官方下载地址：<a href=\"https://iina.io/\" target=\"_blank\" rel=\"noopener\">https://iina.io/</a></p>\n<p>推荐指数：★★★★☆（Movist Pro 是满分😄）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapjhaq2s3j31100n87wh.jpg\" alt></p>\n<h2 id=\"Typora\"><a href=\"#Typora\" class=\"headerlink\" title=\"Typora\"></a>Typora</h2><p>概括：支持实时预览的Markdown文本编辑器</p>\n<p>功能介绍：<a href=\"https://sspai.com/post/54912\" target=\"_blank\" rel=\"noopener\">https://sspai.com/post/54912</a></p>\n<p>官方下载地址：<a href=\"https://www.typora.io/\" target=\"_blank\" rel=\"noopener\">https://www.typora.io/</a></p>\n<p>推荐指数：★★★★★（我的博文都是用Typora编辑的，功不可没，必须满分💯）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapjq9ocukj31140u07wh.jpg\" alt></p>\n<h2 id=\"iPic\"><a href=\"#iPic\" class=\"headerlink\" title=\"iPic\"></a>iPic</h2><p>概括：Markdown 图床、文件上传工具，免费版足够用</p>\n<p>功能介绍：<a href=\"https://toolinbox.net/iPic/\" target=\"_blank\" rel=\"noopener\">https://toolinbox.net/iPic/</a></p>\n<p>官方下载地址：已经上架 App Store，搜索下载即可</p>\n<p>推荐指数：★★★★★（博文中使用到的图片都是通过 iPic 实现加载的）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapkz2l0nbj30kr0eswxg.jpg\" alt></p>\n<h2 id=\"Visual-Studio-Code\"><a href=\"#Visual-Studio-Code\" class=\"headerlink\" title=\"Visual Studio Code\"></a>Visual Studio Code</h2><p>概括：简称 VS Code，非常强大的代码文本编辑器，支持大量插件</p>\n<p>功能介绍：<a href=\"https://www.cnblogs.com/clwydjgs/p/10078065.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/clwydjgs/p/10078065.html</a></p>\n<p>官方下载地址：<a href=\"https://code.visualstudio.com/\" target=\"_blank\" rel=\"noopener\">https://code.visualstudio.com/</a></p>\n<p>推荐指数：★★★★★（相较于 Sublime Text 来说，我更倾向于 VS Code）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapjujriamj315s0u0qte.jpg\" alt></p>\n<h2 id=\"Better-And-Better\"><a href=\"#Better-And-Better\" class=\"headerlink\" title=\"Better And Better\"></a>Better And Better</h2><p>概括：简称BAB，这是一款非常全能的软件，有了它基本可以替代一堆应用</p>\n<p>功能介绍：<a href=\"https://www.better365.cn/tv.html\" target=\"_blank\" rel=\"noopener\">https://www.better365.cn/tv.html</a></p>\n<p>官方下载地址：<a href=\"https://www.better365.cn/bab.html\" target=\"_blank\" rel=\"noopener\">https://www.better365.cn/bab.html</a></p>\n<p>推荐指数：★★★☆☆（偶尔有软件冲突，导致系统运行缓慢）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapk8a5vs6j31450u07wh.jpg\" alt></p>\n<h2 id=\"iShot\"><a href=\"#iShot\" class=\"headerlink\" title=\"iShot\"></a>iShot</h2><p>概括：强大的截图工具，与BAB同属一个开发团队，旗下还有Better Menubar和自动切换输入法</p>\n<p>功能介绍：<a href=\"https://sspai.com/post/57302\" target=\"_blank\" rel=\"noopener\">https://sspai.com/post/57302</a></p>\n<p>官方下载地址：已经上架 App Store，搜索下载即可</p>\n<p>推荐指数：★★★★★（支持截图和录屏，使用下来个人觉得要优于Xnip和Snip）</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapk4hc4b2j30u00vbb1l.jpg\" alt></p>\n<h2 id=\"Final-Shell\"><a href=\"#Final-Shell\" class=\"headerlink\" title=\"Final Shell\"></a>Final Shell</h2><p>概括：Mac上的 shell 工具，用于连接远程服务器，支持sftp</p>\n<p>功能介绍：<a href=\"https://blog.csdn.net/sinat_25838589/article/details/79781241\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/sinat_25838589/article/details/79781241</a></p>\n<p>官方下载地址：<a href=\"http://www.hostbuf.com/t/988.html\" target=\"_blank\" rel=\"noopener\">http://www.hostbuf.com/t/988.html</a></p>\n<p>推荐指数：★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gapkzesnj7j30w40sswi2.jpg\" alt></p>"},{"title":"科学上网推荐,谷歌浏览器插件Ghelper","date":"2020-01-09T14:18:05.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gashd8fvkgj30p00godhc.jpg","_content":"\n## 前言\n\n今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）\n\n## 下载安装\n\n直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg)\n\n<!-- more -->\n\n不能打开谷歌应用商店的小伙伴可以在网上随便找个免费的翻墙软件试用一下，蓝灯或者SSR机场都可以，这里推荐一个免费的网站，速度慢些 [SSR工具](https://usky.ml/tool/free_ssr)\n\n把Ghelper插件添加到Chrome浏览器，免费试用3天，由于网速受地域的影响，这期间正好可以测试下你的网络环境适不适合购买这款插件。\n\n## 插件介绍\n\n安装成功后就是下图的样子，简洁的外观，不需要繁杂的设置，快速上手。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqkuh644nj30uk0lcwh2.jpg)\n\n点击Settings，设置页面显示如下，标志1显示的是到期时间，标志2是你的账户，标志3是用户等级，这里要说明一下，只有VIP达到3级以后才能使用手机代理，等级在1，2级时侧栏的手机代理V2是不显示的，不过个人感觉手机翻墙没啥用。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqlos1mdkj31vw0u0dmv.jpg)\n\n## 资费详情\n\n介绍一下费用情况，一个月是15.99元，一次性购买3个月可以直达VIP3，享受手机代理服务，选择套餐后直接跳转到支付宝扫码付款页面，即时生效。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmpb00pzj30um0ec75z.jpg)\n\n## 手机代理\n\n页面中提供代理软件下载，点击二维码扫描添加到手机代理中即可翻墙。其他的设置我没有修改，感兴趣的小伙伴可以自行下载体验。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmnnv0fbj31pp0u0n7r.jpg)\n\n## 使用感受\n\nYouTube可以秒开，播放很少有卡顿现象，如果本身网络环境比较好的情况下，上网速度还是很理想的，这里不鼓励大家购买，凡事都要根据自己的需求来判断，以保证物有所值！\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqm8jedszj31lk0u0b2a.jpg)","source":"_posts/ghelper.md","raw":"---\ntitle: 科学上网推荐,谷歌浏览器插件Ghelper\ndate: 2020-01-09 22:18:05\ntags:\n  - Google plugin\n  - Ghelper\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gashd8fvkgj30p00godhc.jpg\n---\n\n## 前言\n\n今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）\n\n## 下载安装\n\n直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg)\n\n<!-- more -->\n\n不能打开谷歌应用商店的小伙伴可以在网上随便找个免费的翻墙软件试用一下，蓝灯或者SSR机场都可以，这里推荐一个免费的网站，速度慢些 [SSR工具](https://usky.ml/tool/free_ssr)\n\n把Ghelper插件添加到Chrome浏览器，免费试用3天，由于网速受地域的影响，这期间正好可以测试下你的网络环境适不适合购买这款插件。\n\n## 插件介绍\n\n安装成功后就是下图的样子，简洁的外观，不需要繁杂的设置，快速上手。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqkuh644nj30uk0lcwh2.jpg)\n\n点击Settings，设置页面显示如下，标志1显示的是到期时间，标志2是你的账户，标志3是用户等级，这里要说明一下，只有VIP达到3级以后才能使用手机代理，等级在1，2级时侧栏的手机代理V2是不显示的，不过个人感觉手机翻墙没啥用。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqlos1mdkj31vw0u0dmv.jpg)\n\n## 资费详情\n\n介绍一下费用情况，一个月是15.99元，一次性购买3个月可以直达VIP3，享受手机代理服务，选择套餐后直接跳转到支付宝扫码付款页面，即时生效。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmpb00pzj30um0ec75z.jpg)\n\n## 手机代理\n\n页面中提供代理软件下载，点击二维码扫描添加到手机代理中即可翻墙。其他的设置我没有修改，感兴趣的小伙伴可以自行下载体验。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmnnv0fbj31pp0u0n7r.jpg)\n\n## 使用感受\n\nYouTube可以秒开，播放很少有卡顿现象，如果本身网络环境比较好的情况下，上网速度还是很理想的，这里不鼓励大家购买，凡事都要根据自己的需求来判断，以保证物有所值！\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaqm8jedszj31lk0u0b2a.jpg)","slug":"ghelper","published":1,"updated":"2020-01-12T09:06:58.908Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bir000oa6yb1u4zku5r","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）</p>\n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p>直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg\" alt></p>\n<a id=\"more\"></a>\n\n<p>不能打开谷歌应用商店的小伙伴可以在网上随便找个免费的翻墙软件试用一下，蓝灯或者SSR机场都可以，这里推荐一个免费的网站，速度慢些 <a href=\"https://usky.ml/tool/free_ssr\" target=\"_blank\" rel=\"noopener\">SSR工具</a></p>\n<p>把Ghelper插件添加到Chrome浏览器，免费试用3天，由于网速受地域的影响，这期间正好可以测试下你的网络环境适不适合购买这款插件。</p>\n<h2 id=\"插件介绍\"><a href=\"#插件介绍\" class=\"headerlink\" title=\"插件介绍\"></a>插件介绍</h2><p>安装成功后就是下图的样子，简洁的外观，不需要繁杂的设置，快速上手。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqkuh644nj30uk0lcwh2.jpg\" alt></p>\n<p>点击Settings，设置页面显示如下，标志1显示的是到期时间，标志2是你的账户，标志3是用户等级，这里要说明一下，只有VIP达到3级以后才能使用手机代理，等级在1，2级时侧栏的手机代理V2是不显示的，不过个人感觉手机翻墙没啥用。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqlos1mdkj31vw0u0dmv.jpg\" alt></p>\n<h2 id=\"资费详情\"><a href=\"#资费详情\" class=\"headerlink\" title=\"资费详情\"></a>资费详情</h2><p>介绍一下费用情况，一个月是15.99元，一次性购买3个月可以直达VIP3，享受手机代理服务，选择套餐后直接跳转到支付宝扫码付款页面，即时生效。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmpb00pzj30um0ec75z.jpg\" alt></p>\n<h2 id=\"手机代理\"><a href=\"#手机代理\" class=\"headerlink\" title=\"手机代理\"></a>手机代理</h2><p>页面中提供代理软件下载，点击二维码扫描添加到手机代理中即可翻墙。其他的设置我没有修改，感兴趣的小伙伴可以自行下载体验。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmnnv0fbj31pp0u0n7r.jpg\" alt></p>\n<h2 id=\"使用感受\"><a href=\"#使用感受\" class=\"headerlink\" title=\"使用感受\"></a>使用感受</h2><p>YouTube可以秒开，播放很少有卡顿现象，如果本身网络环境比较好的情况下，上网速度还是很理想的，这里不鼓励大家购买，凡事都要根据自己的需求来判断，以保证物有所值！</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqm8jedszj31lk0u0b2a.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）</p>\n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p>直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg\" alt></p>","more":"<p>不能打开谷歌应用商店的小伙伴可以在网上随便找个免费的翻墙软件试用一下，蓝灯或者SSR机场都可以，这里推荐一个免费的网站，速度慢些 <a href=\"https://usky.ml/tool/free_ssr\" target=\"_blank\" rel=\"noopener\">SSR工具</a></p>\n<p>把Ghelper插件添加到Chrome浏览器，免费试用3天，由于网速受地域的影响，这期间正好可以测试下你的网络环境适不适合购买这款插件。</p>\n<h2 id=\"插件介绍\"><a href=\"#插件介绍\" class=\"headerlink\" title=\"插件介绍\"></a>插件介绍</h2><p>安装成功后就是下图的样子，简洁的外观，不需要繁杂的设置，快速上手。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqkuh644nj30uk0lcwh2.jpg\" alt></p>\n<p>点击Settings，设置页面显示如下，标志1显示的是到期时间，标志2是你的账户，标志3是用户等级，这里要说明一下，只有VIP达到3级以后才能使用手机代理，等级在1，2级时侧栏的手机代理V2是不显示的，不过个人感觉手机翻墙没啥用。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqlos1mdkj31vw0u0dmv.jpg\" alt></p>\n<h2 id=\"资费详情\"><a href=\"#资费详情\" class=\"headerlink\" title=\"资费详情\"></a>资费详情</h2><p>介绍一下费用情况，一个月是15.99元，一次性购买3个月可以直达VIP3，享受手机代理服务，选择套餐后直接跳转到支付宝扫码付款页面，即时生效。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmpb00pzj30um0ec75z.jpg\" alt></p>\n<h2 id=\"手机代理\"><a href=\"#手机代理\" class=\"headerlink\" title=\"手机代理\"></a>手机代理</h2><p>页面中提供代理软件下载，点击二维码扫描添加到手机代理中即可翻墙。其他的设置我没有修改，感兴趣的小伙伴可以自行下载体验。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmnnv0fbj31pp0u0n7r.jpg\" alt></p>\n<h2 id=\"使用感受\"><a href=\"#使用感受\" class=\"headerlink\" title=\"使用感受\"></a>使用感受</h2><p>YouTube可以秒开，播放很少有卡顿现象，如果本身网络环境比较好的情况下，上网速度还是很理想的，这里不鼓励大家购买，凡事都要根据自己的需求来判断，以保证物有所值！</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaqm8jedszj31lk0u0b2a.jpg\" alt></p>"},{"title":"Hexo","date":"2017-09-02T03:17:15.000Z","_content":"Welcome to the Hexo documentation. If you encounter any problems when using Hexo, have a look at the [troubleshooting guide](https://hexo.io/docs/troubleshooting), raise an issue on [GitHub](https://github.com/hexojs/hexo/issues) or start a topic on the [Google Group](https://groups.google.com/group/hexo).\n\n## What is Hexo?\n\nHexo is a fast, simple and powerful blog framework. You write posts in [Markdown](http://daringfireball.net/projects/markdown/) (or other markup languages) and Hexo generates static files with a beautiful theme in seconds.\n\n<!-- more -->\n\n## Installation\n\nIt only takes a few minutes to set up Hexo. If you encounter a problem and can’t find the solution here, please [submit a GitHub issue](https://github.com/hexojs/hexo/issues) and we’ll help.\n\n### Requirements\n\nInstalling Hexo is quite easy and only requires the following beforehand:\n\n- [Node.js](http://nodejs.org/) (Should be at least Node.js 8.10, recommends 10.0 or higher)\n- [Git](http://git-scm.com/)\n\nIf your computer already has these, congratulations! You can skip to the [Hexo installation](https://hexo.io/docs/index.html#Install-Hexo) step.\n\nIf not, please follow the following instructions to install all the requirements.\n\n### Install Git\n\n- Windows: Download & install [git](https://git-scm.com/download/win).\n- Mac: Install it with [Homebrew](https://brew.sh/), [MacPorts](http://www.macports.org/) or [installer](http://sourceforge.net/projects/git-osx-installer/).\n- Linux (Ubuntu, Debian): `sudo apt-get install git-core`\n- Linux (Fedora, Red Hat, CentOS): `sudo yum install git-core`\n\n> For Mac users\n>\n> You may encounter some problems when compiling. Please install Xcode from App Store first. After Xcode is installed, open Xcode and go to **Preferences -> Download -> Command Line Tools -> Install** to install command line tools.\n\n### Install Node.js\n\nNode.js provides [official installer](https://nodejs.org/en/download/) for most platforms.\n\nAlternative installation methods:\n\n- Windows: Install it with [nvs](https://github.com/jasongin/nvs/) (recommended) or [nvm](https://github.com/nvm-sh/nvm).\n- Mac: Install it with [Homebrew](https://brew.sh/) or [MacPorts](http://www.macports.org/).\n- Linux (DEB/RPM-based): Install it with [NodeSource](https://github.com/nodesource/distributions).\n- Others: Install it through respective package manager. Refer to [the guide](https://nodejs.org/en/download/package-manager/) provided by Node.js.\n\nnvs is also recommended for Mac and Linux to avoid possible permission issue.\n\n> Windows\n>\n> If you use the official installer, make sure **Add to PATH** is checked (it’s checked by default).\n\n> Mac / Linux\n>\n> If you encounter `EACCES` permission error when trying to install Hexo, please follow [the workaround](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally) provided by npmjs; overriding with root/sudo is highly discouraged.\n\n### Install Hexo\n\nOnce all the requirements are installed, you can install Hexo with npm:\n\n```\n$ npm install -g hexo-cli\n```\n\n### Advanced installation and usage\n\nAdvanced users may prefer to install and use `hexo` package instead.\n\n```\n$ npm install hexo\n```\n\nOnce installed, you can run Hexo in two ways:\n\n1. `npx hexo <command>`\n\n2. Linux users can set relative path of `node_modules/` folder:\n\n   ```\n   echo 'PATH=\"$PATH:./node_modules/.bin\"' >> ~/.profile\n   ```","source":"_posts/hello-world.md","raw":"---\ntitle: Hexo\ndate: 2017-09-02 11:17:15\ntags: \n---\nWelcome to the Hexo documentation. If you encounter any problems when using Hexo, have a look at the [troubleshooting guide](https://hexo.io/docs/troubleshooting), raise an issue on [GitHub](https://github.com/hexojs/hexo/issues) or start a topic on the [Google Group](https://groups.google.com/group/hexo).\n\n## What is Hexo?\n\nHexo is a fast, simple and powerful blog framework. You write posts in [Markdown](http://daringfireball.net/projects/markdown/) (or other markup languages) and Hexo generates static files with a beautiful theme in seconds.\n\n<!-- more -->\n\n## Installation\n\nIt only takes a few minutes to set up Hexo. If you encounter a problem and can’t find the solution here, please [submit a GitHub issue](https://github.com/hexojs/hexo/issues) and we’ll help.\n\n### Requirements\n\nInstalling Hexo is quite easy and only requires the following beforehand:\n\n- [Node.js](http://nodejs.org/) (Should be at least Node.js 8.10, recommends 10.0 or higher)\n- [Git](http://git-scm.com/)\n\nIf your computer already has these, congratulations! You can skip to the [Hexo installation](https://hexo.io/docs/index.html#Install-Hexo) step.\n\nIf not, please follow the following instructions to install all the requirements.\n\n### Install Git\n\n- Windows: Download & install [git](https://git-scm.com/download/win).\n- Mac: Install it with [Homebrew](https://brew.sh/), [MacPorts](http://www.macports.org/) or [installer](http://sourceforge.net/projects/git-osx-installer/).\n- Linux (Ubuntu, Debian): `sudo apt-get install git-core`\n- Linux (Fedora, Red Hat, CentOS): `sudo yum install git-core`\n\n> For Mac users\n>\n> You may encounter some problems when compiling. Please install Xcode from App Store first. After Xcode is installed, open Xcode and go to **Preferences -> Download -> Command Line Tools -> Install** to install command line tools.\n\n### Install Node.js\n\nNode.js provides [official installer](https://nodejs.org/en/download/) for most platforms.\n\nAlternative installation methods:\n\n- Windows: Install it with [nvs](https://github.com/jasongin/nvs/) (recommended) or [nvm](https://github.com/nvm-sh/nvm).\n- Mac: Install it with [Homebrew](https://brew.sh/) or [MacPorts](http://www.macports.org/).\n- Linux (DEB/RPM-based): Install it with [NodeSource](https://github.com/nodesource/distributions).\n- Others: Install it through respective package manager. Refer to [the guide](https://nodejs.org/en/download/package-manager/) provided by Node.js.\n\nnvs is also recommended for Mac and Linux to avoid possible permission issue.\n\n> Windows\n>\n> If you use the official installer, make sure **Add to PATH** is checked (it’s checked by default).\n\n> Mac / Linux\n>\n> If you encounter `EACCES` permission error when trying to install Hexo, please follow [the workaround](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally) provided by npmjs; overriding with root/sudo is highly discouraged.\n\n### Install Hexo\n\nOnce all the requirements are installed, you can install Hexo with npm:\n\n```\n$ npm install -g hexo-cli\n```\n\n### Advanced installation and usage\n\nAdvanced users may prefer to install and use `hexo` package instead.\n\n```\n$ npm install hexo\n```\n\nOnce installed, you can run Hexo in two ways:\n\n1. `npx hexo <command>`\n\n2. Linux users can set relative path of `node_modules/` folder:\n\n   ```\n   echo 'PATH=\"$PATH:./node_modules/.bin\"' >> ~/.profile\n   ```","slug":"hello-world","published":1,"updated":"2020-01-11T05:25:44.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bis000pa6ybswdisdee","content":"<p>Welcome to the Hexo documentation. If you encounter any problems when using Hexo, have a look at the <a href=\"https://hexo.io/docs/troubleshooting\" target=\"_blank\" rel=\"noopener\">troubleshooting guide</a>, raise an issue on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a> or start a topic on the <a href=\"https://groups.google.com/group/hexo\" target=\"_blank\" rel=\"noopener\">Google Group</a>.</p>\n<h2 id=\"What-is-Hexo\"><a href=\"#What-is-Hexo\" class=\"headerlink\" title=\"What is Hexo?\"></a>What is Hexo?</h2><p>Hexo is a fast, simple and powerful blog framework. You write posts in <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown</a> (or other markup languages) and Hexo generates static files with a beautiful theme in seconds.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>It only takes a few minutes to set up Hexo. If you encounter a problem and can’t find the solution here, please <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">submit a GitHub issue</a> and we’ll help.</p>\n<h3 id=\"Requirements\"><a href=\"#Requirements\" class=\"headerlink\" title=\"Requirements\"></a>Requirements</h3><p>Installing Hexo is quite easy and only requires the following beforehand:</p>\n<ul>\n<li><a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a> (Should be at least Node.js 8.10, recommends 10.0 or higher)</li>\n<li><a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a></li>\n</ul>\n<p>If your computer already has these, congratulations! You can skip to the <a href=\"https://hexo.io/docs/index.html#Install-Hexo\" target=\"_blank\" rel=\"noopener\">Hexo installation</a> step.</p>\n<p>If not, please follow the following instructions to install all the requirements.</p>\n<h3 id=\"Install-Git\"><a href=\"#Install-Git\" class=\"headerlink\" title=\"Install Git\"></a>Install Git</h3><ul>\n<li>Windows: Download &amp; install <a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"noopener\">git</a>.</li>\n<li>Mac: Install it with <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">Homebrew</a>, <a href=\"http://www.macports.org/\" target=\"_blank\" rel=\"noopener\">MacPorts</a> or <a href=\"http://sourceforge.net/projects/git-osx-installer/\" target=\"_blank\" rel=\"noopener\">installer</a>.</li>\n<li>Linux (Ubuntu, Debian): <code>sudo apt-get install git-core</code></li>\n<li>Linux (Fedora, Red Hat, CentOS): <code>sudo yum install git-core</code></li>\n</ul>\n<blockquote>\n<p>For Mac users</p>\n<p>You may encounter some problems when compiling. Please install Xcode from App Store first. After Xcode is installed, open Xcode and go to <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> to install command line tools.</p>\n</blockquote>\n<h3 id=\"Install-Node-js\"><a href=\"#Install-Node-js\" class=\"headerlink\" title=\"Install Node.js\"></a>Install Node.js</h3><p>Node.js provides <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">official installer</a> for most platforms.</p>\n<p>Alternative installation methods:</p>\n<ul>\n<li>Windows: Install it with <a href=\"https://github.com/jasongin/nvs/\" target=\"_blank\" rel=\"noopener\">nvs</a> (recommended) or <a href=\"https://github.com/nvm-sh/nvm\" target=\"_blank\" rel=\"noopener\">nvm</a>.</li>\n<li>Mac: Install it with <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">Homebrew</a> or <a href=\"http://www.macports.org/\" target=\"_blank\" rel=\"noopener\">MacPorts</a>.</li>\n<li>Linux (DEB/RPM-based): Install it with <a href=\"https://github.com/nodesource/distributions\" target=\"_blank\" rel=\"noopener\">NodeSource</a>.</li>\n<li>Others: Install it through respective package manager. Refer to <a href=\"https://nodejs.org/en/download/package-manager/\" target=\"_blank\" rel=\"noopener\">the guide</a> provided by Node.js.</li>\n</ul>\n<p>nvs is also recommended for Mac and Linux to avoid possible permission issue.</p>\n<blockquote>\n<p>Windows</p>\n<p>If you use the official installer, make sure <strong>Add to PATH</strong> is checked (it’s checked by default).</p>\n</blockquote>\n<blockquote>\n<p>Mac / Linux</p>\n<p>If you encounter <code>EACCES</code> permission error when trying to install Hexo, please follow <a href=\"https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally\" target=\"_blank\" rel=\"noopener\">the workaround</a> provided by npmjs; overriding with root/sudo is highly discouraged.</p>\n</blockquote>\n<h3 id=\"Install-Hexo\"><a href=\"#Install-Hexo\" class=\"headerlink\" title=\"Install Hexo\"></a>Install Hexo</h3><p>Once all the requirements are installed, you can install Hexo with npm:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Advanced-installation-and-usage\"><a href=\"#Advanced-installation-and-usage\" class=\"headerlink\" title=\"Advanced installation and usage\"></a>Advanced installation and usage</h3><p>Advanced users may prefer to install and use <code>hexo</code> package instead.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo</span><br></pre></td></tr></table></figure>\n\n<p>Once installed, you can run Hexo in two ways:</p>\n<ol>\n<li><p><code>npx hexo &lt;command&gt;</code></p>\n</li>\n<li><p>Linux users can set relative path of <code>node_modules/</code> folder:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &apos;PATH=&quot;$PATH:./node_modules/.bin&quot;&apos; &gt;&gt; ~/.profile</span><br></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Welcome to the Hexo documentation. If you encounter any problems when using Hexo, have a look at the <a href=\"https://hexo.io/docs/troubleshooting\" target=\"_blank\" rel=\"noopener\">troubleshooting guide</a>, raise an issue on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a> or start a topic on the <a href=\"https://groups.google.com/group/hexo\" target=\"_blank\" rel=\"noopener\">Google Group</a>.</p>\n<h2 id=\"What-is-Hexo\"><a href=\"#What-is-Hexo\" class=\"headerlink\" title=\"What is Hexo?\"></a>What is Hexo?</h2><p>Hexo is a fast, simple and powerful blog framework. You write posts in <a href=\"http://daringfireball.net/projects/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown</a> (or other markup languages) and Hexo generates static files with a beautiful theme in seconds.</p>","more":"<h2 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"></a>Installation</h2><p>It only takes a few minutes to set up Hexo. If you encounter a problem and can’t find the solution here, please <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">submit a GitHub issue</a> and we’ll help.</p>\n<h3 id=\"Requirements\"><a href=\"#Requirements\" class=\"headerlink\" title=\"Requirements\"></a>Requirements</h3><p>Installing Hexo is quite easy and only requires the following beforehand:</p>\n<ul>\n<li><a href=\"http://nodejs.org/\" target=\"_blank\" rel=\"noopener\">Node.js</a> (Should be at least Node.js 8.10, recommends 10.0 or higher)</li>\n<li><a href=\"http://git-scm.com/\" target=\"_blank\" rel=\"noopener\">Git</a></li>\n</ul>\n<p>If your computer already has these, congratulations! You can skip to the <a href=\"https://hexo.io/docs/index.html#Install-Hexo\" target=\"_blank\" rel=\"noopener\">Hexo installation</a> step.</p>\n<p>If not, please follow the following instructions to install all the requirements.</p>\n<h3 id=\"Install-Git\"><a href=\"#Install-Git\" class=\"headerlink\" title=\"Install Git\"></a>Install Git</h3><ul>\n<li>Windows: Download &amp; install <a href=\"https://git-scm.com/download/win\" target=\"_blank\" rel=\"noopener\">git</a>.</li>\n<li>Mac: Install it with <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">Homebrew</a>, <a href=\"http://www.macports.org/\" target=\"_blank\" rel=\"noopener\">MacPorts</a> or <a href=\"http://sourceforge.net/projects/git-osx-installer/\" target=\"_blank\" rel=\"noopener\">installer</a>.</li>\n<li>Linux (Ubuntu, Debian): <code>sudo apt-get install git-core</code></li>\n<li>Linux (Fedora, Red Hat, CentOS): <code>sudo yum install git-core</code></li>\n</ul>\n<blockquote>\n<p>For Mac users</p>\n<p>You may encounter some problems when compiling. Please install Xcode from App Store first. After Xcode is installed, open Xcode and go to <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> to install command line tools.</p>\n</blockquote>\n<h3 id=\"Install-Node-js\"><a href=\"#Install-Node-js\" class=\"headerlink\" title=\"Install Node.js\"></a>Install Node.js</h3><p>Node.js provides <a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">official installer</a> for most platforms.</p>\n<p>Alternative installation methods:</p>\n<ul>\n<li>Windows: Install it with <a href=\"https://github.com/jasongin/nvs/\" target=\"_blank\" rel=\"noopener\">nvs</a> (recommended) or <a href=\"https://github.com/nvm-sh/nvm\" target=\"_blank\" rel=\"noopener\">nvm</a>.</li>\n<li>Mac: Install it with <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">Homebrew</a> or <a href=\"http://www.macports.org/\" target=\"_blank\" rel=\"noopener\">MacPorts</a>.</li>\n<li>Linux (DEB/RPM-based): Install it with <a href=\"https://github.com/nodesource/distributions\" target=\"_blank\" rel=\"noopener\">NodeSource</a>.</li>\n<li>Others: Install it through respective package manager. Refer to <a href=\"https://nodejs.org/en/download/package-manager/\" target=\"_blank\" rel=\"noopener\">the guide</a> provided by Node.js.</li>\n</ul>\n<p>nvs is also recommended for Mac and Linux to avoid possible permission issue.</p>\n<blockquote>\n<p>Windows</p>\n<p>If you use the official installer, make sure <strong>Add to PATH</strong> is checked (it’s checked by default).</p>\n</blockquote>\n<blockquote>\n<p>Mac / Linux</p>\n<p>If you encounter <code>EACCES</code> permission error when trying to install Hexo, please follow <a href=\"https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally\" target=\"_blank\" rel=\"noopener\">the workaround</a> provided by npmjs; overriding with root/sudo is highly discouraged.</p>\n</blockquote>\n<h3 id=\"Install-Hexo\"><a href=\"#Install-Hexo\" class=\"headerlink\" title=\"Install Hexo\"></a>Install Hexo</h3><p>Once all the requirements are installed, you can install Hexo with npm:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Advanced-installation-and-usage\"><a href=\"#Advanced-installation-and-usage\" class=\"headerlink\" title=\"Advanced installation and usage\"></a>Advanced installation and usage</h3><p>Advanced users may prefer to install and use <code>hexo</code> package instead.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install hexo</span><br></pre></td></tr></table></figure>\n\n<p>Once installed, you can run Hexo in two ways:</p>\n<ol>\n<li><p><code>npx hexo &lt;command&gt;</code></p>\n</li>\n<li><p>Linux users can set relative path of <code>node_modules/</code> folder:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo &apos;PATH=&quot;$PATH:./node_modules/.bin&quot;&apos; &gt;&gt; ~/.profile</span><br></pre></td></tr></table></figure></li>\n</ol>"},{"title":"Maven相关","date":"2018-05-12T15:22:27.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## Maven简介\n\nMaven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。\n\nMaven是跨平台的项目管理工具。主要服务于基于Java平台的**项目构建**，**依赖管理**和项目信息管理。\n\n## 下载安装\n\n官方网站：http://maven.apache.org  \n\n要求 jdk 为1.6及以上版本。\n\n解压缩，解压目录最好不要有中文。\n\n配置环境变量MAVEN_HOME和path。\n\n验证是否安装成功，打开cmd窗口，输入mvn –v。\n\n<!-- more -->\n\n## 配置Maven\n\n**%MAVEN_HOME%/conf/settings.xml** 是maven全局的配置文件。\n\n该配置文件中配置了本地仓库的路径，默认就是：~/.m2/repository。\n\n用户配置：复制maven的全局配置文件settings.xml到~/.m2目录下，即创建用户配置文件。\n\n注意：用户级别的仓库在全局配置中一旦设置，全局配置将不再生效，转用用户所设置的仓库。\n\n## 常用命令\n\n### Mvn compile\n\n执行 mvn compile命令，完成编译操作。\n\n执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。\n\n### Mvn clean\n\n执行 mvn clean命令。\n\n执行完毕后，会将target目录删除。\n\n### Mvn test\n\n执行 mvn test命令，完成单元测试操作。\n\n执行完毕后，会在target目录中生成三个文件夹：surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）。\n\n### Mvn package\n\n执行 mvn package命令，完成打包操作。\n\n执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war。\n\n### Mvn install\n\n执行 mvn install命令，完成将打好的jar包安装到本地仓库的操作。\n\n执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用。\n\n## 组合命令\n\n### mvn clean compile\n\ncmd 中录入 mvn clean compile命令。\n\n组合指令，先执行clean，再执行compile，通常应用于上线前执行，清除测试类。\n\n### mvn clean test\n\ncmd 中录入 mvn clean test命令。\n\n组合指令，先执行clean，再执行test，通常应用于测试环节。\n\n### mvn clean package\n\ncmd 中录入 mvn clean package命令。\n\n组合指令，先执行clean，再执行package，将项目打包，通常应用于发布前。\n\n执行过程：\n\n- 清理————清空环境\n- 编译————编译源码\n- 测试————测试源码\n- 打包————将编译的非测试类打包\n\n### mvn clean install\n\ncmd 中录入 mvn clean install 查看仓库，当前项目被发布到仓库中。\n\n组合指令，先执行clean，再执行install，将项目打包，通常应用于发布前。\n\n执行过程：\n\n- 清理————清空环境\n- 编译————编译源码\n- 测试————测试源码\n- 打包————将编译的非测试类打包\n- 部署————将打好的包发布到资源仓库中","source":"_posts/maven.md","raw":"---\ntitle: Maven相关\ndate: 2018-05-12 23:22:27\ncategories: Java\ntags:\n  - version control\n  - maven\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## Maven简介\n\nMaven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。\n\nMaven是跨平台的项目管理工具。主要服务于基于Java平台的**项目构建**，**依赖管理**和项目信息管理。\n\n## 下载安装\n\n官方网站：http://maven.apache.org  \n\n要求 jdk 为1.6及以上版本。\n\n解压缩，解压目录最好不要有中文。\n\n配置环境变量MAVEN_HOME和path。\n\n验证是否安装成功，打开cmd窗口，输入mvn –v。\n\n<!-- more -->\n\n## 配置Maven\n\n**%MAVEN_HOME%/conf/settings.xml** 是maven全局的配置文件。\n\n该配置文件中配置了本地仓库的路径，默认就是：~/.m2/repository。\n\n用户配置：复制maven的全局配置文件settings.xml到~/.m2目录下，即创建用户配置文件。\n\n注意：用户级别的仓库在全局配置中一旦设置，全局配置将不再生效，转用用户所设置的仓库。\n\n## 常用命令\n\n### Mvn compile\n\n执行 mvn compile命令，完成编译操作。\n\n执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。\n\n### Mvn clean\n\n执行 mvn clean命令。\n\n执行完毕后，会将target目录删除。\n\n### Mvn test\n\n执行 mvn test命令，完成单元测试操作。\n\n执行完毕后，会在target目录中生成三个文件夹：surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）。\n\n### Mvn package\n\n执行 mvn package命令，完成打包操作。\n\n执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war。\n\n### Mvn install\n\n执行 mvn install命令，完成将打好的jar包安装到本地仓库的操作。\n\n执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用。\n\n## 组合命令\n\n### mvn clean compile\n\ncmd 中录入 mvn clean compile命令。\n\n组合指令，先执行clean，再执行compile，通常应用于上线前执行，清除测试类。\n\n### mvn clean test\n\ncmd 中录入 mvn clean test命令。\n\n组合指令，先执行clean，再执行test，通常应用于测试环节。\n\n### mvn clean package\n\ncmd 中录入 mvn clean package命令。\n\n组合指令，先执行clean，再执行package，将项目打包，通常应用于发布前。\n\n执行过程：\n\n- 清理————清空环境\n- 编译————编译源码\n- 测试————测试源码\n- 打包————将编译的非测试类打包\n\n### mvn clean install\n\ncmd 中录入 mvn clean install 查看仓库，当前项目被发布到仓库中。\n\n组合指令，先执行clean，再执行install，将项目打包，通常应用于发布前。\n\n执行过程：\n\n- 清理————清空环境\n- 编译————编译源码\n- 测试————测试源码\n- 打包————将编译的非测试类打包\n- 部署————将打好的包发布到资源仓库中","slug":"maven","published":1,"updated":"2020-01-15T06:03:30.082Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bit000ta6ybxp4nqhox","content":"<h2 id=\"Maven简介\"><a href=\"#Maven简介\" class=\"headerlink\" title=\"Maven简介\"></a>Maven简介</h2><p>Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</p>\n<p>Maven是跨平台的项目管理工具。主要服务于基于Java平台的<strong>项目构建</strong>，<strong>依赖管理</strong>和项目信息管理。</p>\n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p>官方网站：<a href=\"http://maven.apache.org\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org</a>  </p>\n<p>要求 jdk 为1.6及以上版本。</p>\n<p>解压缩，解压目录最好不要有中文。</p>\n<p>配置环境变量MAVEN_HOME和path。</p>\n<p>验证是否安装成功，打开cmd窗口，输入mvn –v。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"配置Maven\"><a href=\"#配置Maven\" class=\"headerlink\" title=\"配置Maven\"></a>配置Maven</h2><p><strong>%MAVEN_HOME%/conf/settings.xml</strong> 是maven全局的配置文件。</p>\n<p>该配置文件中配置了本地仓库的路径，默认就是：~/.m2/repository。</p>\n<p>用户配置：复制maven的全局配置文件settings.xml到~/.m2目录下，即创建用户配置文件。</p>\n<p>注意：用户级别的仓库在全局配置中一旦设置，全局配置将不再生效，转用用户所设置的仓库。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><h3 id=\"Mvn-compile\"><a href=\"#Mvn-compile\" class=\"headerlink\" title=\"Mvn compile\"></a>Mvn compile</h3><p>执行 mvn compile命令，完成编译操作。</p>\n<p>执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。</p>\n<h3 id=\"Mvn-clean\"><a href=\"#Mvn-clean\" class=\"headerlink\" title=\"Mvn clean\"></a>Mvn clean</h3><p>执行 mvn clean命令。</p>\n<p>执行完毕后，会将target目录删除。</p>\n<h3 id=\"Mvn-test\"><a href=\"#Mvn-test\" class=\"headerlink\" title=\"Mvn test\"></a>Mvn test</h3><p>执行 mvn test命令，完成单元测试操作。</p>\n<p>执行完毕后，会在target目录中生成三个文件夹：surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）。</p>\n<h3 id=\"Mvn-package\"><a href=\"#Mvn-package\" class=\"headerlink\" title=\"Mvn package\"></a>Mvn package</h3><p>执行 mvn package命令，完成打包操作。</p>\n<p>执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war。</p>\n<h3 id=\"Mvn-install\"><a href=\"#Mvn-install\" class=\"headerlink\" title=\"Mvn install\"></a>Mvn install</h3><p>执行 mvn install命令，完成将打好的jar包安装到本地仓库的操作。</p>\n<p>执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用。</p>\n<h2 id=\"组合命令\"><a href=\"#组合命令\" class=\"headerlink\" title=\"组合命令\"></a>组合命令</h2><h3 id=\"mvn-clean-compile\"><a href=\"#mvn-clean-compile\" class=\"headerlink\" title=\"mvn clean compile\"></a>mvn clean compile</h3><p>cmd 中录入 mvn clean compile命令。</p>\n<p>组合指令，先执行clean，再执行compile，通常应用于上线前执行，清除测试类。</p>\n<h3 id=\"mvn-clean-test\"><a href=\"#mvn-clean-test\" class=\"headerlink\" title=\"mvn clean test\"></a>mvn clean test</h3><p>cmd 中录入 mvn clean test命令。</p>\n<p>组合指令，先执行clean，再执行test，通常应用于测试环节。</p>\n<h3 id=\"mvn-clean-package\"><a href=\"#mvn-clean-package\" class=\"headerlink\" title=\"mvn clean package\"></a>mvn clean package</h3><p>cmd 中录入 mvn clean package命令。</p>\n<p>组合指令，先执行clean，再执行package，将项目打包，通常应用于发布前。</p>\n<p>执行过程：</p>\n<ul>\n<li>清理————清空环境</li>\n<li>编译————编译源码</li>\n<li>测试————测试源码</li>\n<li>打包————将编译的非测试类打包</li>\n</ul>\n<h3 id=\"mvn-clean-install\"><a href=\"#mvn-clean-install\" class=\"headerlink\" title=\"mvn clean install\"></a>mvn clean install</h3><p>cmd 中录入 mvn clean install 查看仓库，当前项目被发布到仓库中。</p>\n<p>组合指令，先执行clean，再执行install，将项目打包，通常应用于发布前。</p>\n<p>执行过程：</p>\n<ul>\n<li>清理————清空环境</li>\n<li>编译————编译源码</li>\n<li>测试————测试源码</li>\n<li>打包————将编译的非测试类打包</li>\n<li>部署————将打好的包发布到资源仓库中</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Maven简介\"><a href=\"#Maven简介\" class=\"headerlink\" title=\"Maven简介\"></a>Maven简介</h2><p>Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。</p>\n<p>Maven是跨平台的项目管理工具。主要服务于基于Java平台的<strong>项目构建</strong>，<strong>依赖管理</strong>和项目信息管理。</p>\n<h2 id=\"下载安装\"><a href=\"#下载安装\" class=\"headerlink\" title=\"下载安装\"></a>下载安装</h2><p>官方网站：<a href=\"http://maven.apache.org\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org</a>  </p>\n<p>要求 jdk 为1.6及以上版本。</p>\n<p>解压缩，解压目录最好不要有中文。</p>\n<p>配置环境变量MAVEN_HOME和path。</p>\n<p>验证是否安装成功，打开cmd窗口，输入mvn –v。</p>","more":"<h2 id=\"配置Maven\"><a href=\"#配置Maven\" class=\"headerlink\" title=\"配置Maven\"></a>配置Maven</h2><p><strong>%MAVEN_HOME%/conf/settings.xml</strong> 是maven全局的配置文件。</p>\n<p>该配置文件中配置了本地仓库的路径，默认就是：~/.m2/repository。</p>\n<p>用户配置：复制maven的全局配置文件settings.xml到~/.m2目录下，即创建用户配置文件。</p>\n<p>注意：用户级别的仓库在全局配置中一旦设置，全局配置将不再生效，转用用户所设置的仓库。</p>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><h3 id=\"Mvn-compile\"><a href=\"#Mvn-compile\" class=\"headerlink\" title=\"Mvn compile\"></a>Mvn compile</h3><p>执行 mvn compile命令，完成编译操作。</p>\n<p>执行完毕后，会生成target目录，该目录中存放了编译后的字节码文件。</p>\n<h3 id=\"Mvn-clean\"><a href=\"#Mvn-clean\" class=\"headerlink\" title=\"Mvn clean\"></a>Mvn clean</h3><p>执行 mvn clean命令。</p>\n<p>执行完毕后，会将target目录删除。</p>\n<h3 id=\"Mvn-test\"><a href=\"#Mvn-test\" class=\"headerlink\" title=\"Mvn test\"></a>Mvn test</h3><p>执行 mvn test命令，完成单元测试操作。</p>\n<p>执行完毕后，会在target目录中生成三个文件夹：surefire、surefire-reports（测试报告）、test-classes（测试的字节码文件）。</p>\n<h3 id=\"Mvn-package\"><a href=\"#Mvn-package\" class=\"headerlink\" title=\"Mvn package\"></a>Mvn package</h3><p>执行 mvn package命令，完成打包操作。</p>\n<p>执行完毕后，会在target目录中生成一个文件，该文件可能是jar、war。</p>\n<h3 id=\"Mvn-install\"><a href=\"#Mvn-install\" class=\"headerlink\" title=\"Mvn install\"></a>Mvn install</h3><p>执行 mvn install命令，完成将打好的jar包安装到本地仓库的操作。</p>\n<p>执行完毕后，会在本地仓库中出现安装后的jar包，方便其他工程引用。</p>\n<h2 id=\"组合命令\"><a href=\"#组合命令\" class=\"headerlink\" title=\"组合命令\"></a>组合命令</h2><h3 id=\"mvn-clean-compile\"><a href=\"#mvn-clean-compile\" class=\"headerlink\" title=\"mvn clean compile\"></a>mvn clean compile</h3><p>cmd 中录入 mvn clean compile命令。</p>\n<p>组合指令，先执行clean，再执行compile，通常应用于上线前执行，清除测试类。</p>\n<h3 id=\"mvn-clean-test\"><a href=\"#mvn-clean-test\" class=\"headerlink\" title=\"mvn clean test\"></a>mvn clean test</h3><p>cmd 中录入 mvn clean test命令。</p>\n<p>组合指令，先执行clean，再执行test，通常应用于测试环节。</p>\n<h3 id=\"mvn-clean-package\"><a href=\"#mvn-clean-package\" class=\"headerlink\" title=\"mvn clean package\"></a>mvn clean package</h3><p>cmd 中录入 mvn clean package命令。</p>\n<p>组合指令，先执行clean，再执行package，将项目打包，通常应用于发布前。</p>\n<p>执行过程：</p>\n<ul>\n<li>清理————清空环境</li>\n<li>编译————编译源码</li>\n<li>测试————测试源码</li>\n<li>打包————将编译的非测试类打包</li>\n</ul>\n<h3 id=\"mvn-clean-install\"><a href=\"#mvn-clean-install\" class=\"headerlink\" title=\"mvn clean install\"></a>mvn clean install</h3><p>cmd 中录入 mvn clean install 查看仓库，当前项目被发布到仓库中。</p>\n<p>组合指令，先执行clean，再执行install，将项目打包，通常应用于发布前。</p>\n<p>执行过程：</p>\n<ul>\n<li>清理————清空环境</li>\n<li>编译————编译源码</li>\n<li>测试————测试源码</li>\n<li>打包————将编译的非测试类打包</li>\n<li>部署————将打好的包发布到资源仓库中</li>\n</ul>"},{"title":"macOS 超实用的「付费」软件推荐,分享一波福利！","date":"2020-01-08T03:17:15.000Z","_content":"\n## Alfred 4\n\n版本号: 4.0.6\n\n功能介绍: https://www.alfredapp.com/whats-new/\n\n破解版下载链接:https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA  密码:9onb\n\n推荐指数: ★★★★★\n\n<!-- more -->\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8z0whdj31a70u0q6x.jpg)\n\n## CleanMyMac X\n\n版本号: 4.4.6\n\n功能介绍: https://macpaw.com/cleanmymac\n\n破解版下载链接:https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA  密码:mslx\n\n推荐指数: ★★★★☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8yp8etj31e80u0go2.jpg)\n\n\n\n## Movist Pro\n\n版本号: 2.2.13\n\n功能介绍: https://movistprime.com/\n\n破解版下载链接:https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg  密码:8ocb\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xhyx8j30rs0frabv.jpg)\n\n\n\n## Final Cut Pro X\n\n版本号: 10.4.5\n\n功能介绍: https://www.apple.com/final-cut-pro/\n\n破解版下载链接:https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ  密码:wqdk\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y1fq5j31gs0u0jti.jpg)\n\n\n\n## Compressor\n\n版本号: 4.4.3\n\n功能介绍: https://www.apple.com.cn/cn/final-cut-pro/compressor/\n\n破解版下载链接:https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA  密码:8mng\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gauscey8r0j319x0u0gnq.jpg)\n\n\n\n## iStat Menus 6\n\n版本号: 6.31\n\n功能介绍: https://bjango.com/mac/istatmenus/\n\n破解版下载链接:https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ  密码:r8yx\n\n推荐指数: ★★★★☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xrx3hj319e0u0tca.jpg)\n\n\n\n## Parallels Desktop 15\n\n版本号: 15.1.2\n\n功能介绍: https://www.parallels.com/cn/landingpage/pd/general/\n\n破解版下载链接:https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA  密码:xfxi\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wjkifj319y0u00u6.jpg)\n\n\n\n## XMind 8 Pro\n\n版本号: 3.7.7\n\n功能介绍: https://www.xmind.cn/xmind8-pro/\n\n破解版下载链接:https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA  密码:3dio\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vmmwaj31cv0u0wfn.jpg)\n\n\n\n## PDF Expert\n\n版本号: 2.4.23\n\n功能介绍: https://pdfexpert.com/\n\n破解版下载链接:https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow  密码:gkyo\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8w7qu7j31g20u0myq.jpg)\n\n\n\n## Things 3\n\n版本号: 3.11\n\n功能介绍: https://culturedcode.com/things/\n\n破解版下载链接:https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ  密码:ddv6\n\n推荐指数: ★★★☆☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vwlmgj311q0u0js9.jpg)\n\n\n\n## Downie 3\n\n版本号: 3.9.4\n\n功能介绍: https://software.charliemonroe.net/downie/\n\n破解版下载链接:https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA  密码:cqma\n\n推荐指数: ★★★★☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y7letj31ck0l0mxq.jpg)\n\n\n\n## Paste\n\n版本号: 2.4.4\n\n功能介绍: https://pasteapp.me/\n\n破解版下载链接:https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g  密码:4bxn\n\n推荐指数: ★★★★☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wqkbxj30vk0mu3zl.jpg)\n\n\n\n## Bartender 3\n\n版本号: 3.1.1\n\n功能介绍: https://www.macbartender.com/\n\n破解版下载链接:https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q  密码:b00n\n\n推荐指数: ★★★☆☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxotf6egj30q106wgmk.jpg)\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxpip1rej30q106wgm1.jpg)\n\n## MWeb\n\n版本号: 3.2.2\n\n功能介绍: https://zh.mweb.im/\n\n破解版下载链接:https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw  密码:87dx\n\n推荐指数: ★★★☆☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8x805fj31fl0u0juk.jpg)\n\n\n\n## Smooze\n\n版本号: 1.8.6\n\n功能介绍: https://smooze.co/\n\n破解版下载链接:https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw  密码:upjo\n\n推荐指数: ★★☆☆☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxu7eqksj31el0u0x6p.jpg)\n\n\n\n## Keka\n\n版本号: 1.1.5\n\n功能介绍: https://www.keka.io/en/\n\n破解版下载链接:https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ  密码:7sdf\n\n推荐指数: ★★★☆☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaoy9qvhhfj30jo0oa43j.jpg)\n\n\n\n## 写在最后\n\n正版软件比破解版更稳定,且可以享受持续更新,在资金能力允许的范围内,呼吁大家支持正版!\n\n本站所有软件仅供学习使用,请在24小时内删除,本人不承担任何相关责任!","source":"_posts/macapp.md","raw":"---\ntitle: macOS 超实用的「付费」软件推荐,分享一波福利！\ndate: 2020-01-08 11:17:15\ncategories: System\ntags:\n  - macOS\n  - paid apps\n---\n\n## Alfred 4\n\n版本号: 4.0.6\n\n功能介绍: https://www.alfredapp.com/whats-new/\n\n破解版下载链接:https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA  密码:9onb\n\n推荐指数: ★★★★★\n\n<!-- more -->\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8z0whdj31a70u0q6x.jpg)\n\n## CleanMyMac X\n\n版本号: 4.4.6\n\n功能介绍: https://macpaw.com/cleanmymac\n\n破解版下载链接:https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA  密码:mslx\n\n推荐指数: ★★★★☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8yp8etj31e80u0go2.jpg)\n\n\n\n## Movist Pro\n\n版本号: 2.2.13\n\n功能介绍: https://movistprime.com/\n\n破解版下载链接:https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg  密码:8ocb\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xhyx8j30rs0frabv.jpg)\n\n\n\n## Final Cut Pro X\n\n版本号: 10.4.5\n\n功能介绍: https://www.apple.com/final-cut-pro/\n\n破解版下载链接:https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ  密码:wqdk\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y1fq5j31gs0u0jti.jpg)\n\n\n\n## Compressor\n\n版本号: 4.4.3\n\n功能介绍: https://www.apple.com.cn/cn/final-cut-pro/compressor/\n\n破解版下载链接:https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA  密码:8mng\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gauscey8r0j319x0u0gnq.jpg)\n\n\n\n## iStat Menus 6\n\n版本号: 6.31\n\n功能介绍: https://bjango.com/mac/istatmenus/\n\n破解版下载链接:https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ  密码:r8yx\n\n推荐指数: ★★★★☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xrx3hj319e0u0tca.jpg)\n\n\n\n## Parallels Desktop 15\n\n版本号: 15.1.2\n\n功能介绍: https://www.parallels.com/cn/landingpage/pd/general/\n\n破解版下载链接:https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA  密码:xfxi\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wjkifj319y0u00u6.jpg)\n\n\n\n## XMind 8 Pro\n\n版本号: 3.7.7\n\n功能介绍: https://www.xmind.cn/xmind8-pro/\n\n破解版下载链接:https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA  密码:3dio\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vmmwaj31cv0u0wfn.jpg)\n\n\n\n## PDF Expert\n\n版本号: 2.4.23\n\n功能介绍: https://pdfexpert.com/\n\n破解版下载链接:https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow  密码:gkyo\n\n推荐指数: ★★★★★\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8w7qu7j31g20u0myq.jpg)\n\n\n\n## Things 3\n\n版本号: 3.11\n\n功能介绍: https://culturedcode.com/things/\n\n破解版下载链接:https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ  密码:ddv6\n\n推荐指数: ★★★☆☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vwlmgj311q0u0js9.jpg)\n\n\n\n## Downie 3\n\n版本号: 3.9.4\n\n功能介绍: https://software.charliemonroe.net/downie/\n\n破解版下载链接:https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA  密码:cqma\n\n推荐指数: ★★★★☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y7letj31ck0l0mxq.jpg)\n\n\n\n## Paste\n\n版本号: 2.4.4\n\n功能介绍: https://pasteapp.me/\n\n破解版下载链接:https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g  密码:4bxn\n\n推荐指数: ★★★★☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wqkbxj30vk0mu3zl.jpg)\n\n\n\n## Bartender 3\n\n版本号: 3.1.1\n\n功能介绍: https://www.macbartender.com/\n\n破解版下载链接:https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q  密码:b00n\n\n推荐指数: ★★★☆☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxotf6egj30q106wgmk.jpg)\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxpip1rej30q106wgm1.jpg)\n\n## MWeb\n\n版本号: 3.2.2\n\n功能介绍: https://zh.mweb.im/\n\n破解版下载链接:https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw  密码:87dx\n\n推荐指数: ★★★☆☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8x805fj31fl0u0juk.jpg)\n\n\n\n## Smooze\n\n版本号: 1.8.6\n\n功能介绍: https://smooze.co/\n\n破解版下载链接:https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw  密码:upjo\n\n推荐指数: ★★☆☆☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxu7eqksj31el0u0x6p.jpg)\n\n\n\n## Keka\n\n版本号: 1.1.5\n\n功能介绍: https://www.keka.io/en/\n\n破解版下载链接:https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ  密码:7sdf\n\n推荐指数: ★★★☆☆\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaoy9qvhhfj30jo0oa43j.jpg)\n\n\n\n## 写在最后\n\n正版软件比破解版更稳定,且可以享受持续更新,在资金能力允许的范围内,呼吁大家支持正版!\n\n本站所有软件仅供学习使用,请在24小时内删除,本人不承担任何相关责任!","slug":"macapp","published":1,"updated":"2020-01-13T03:46:12.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61biv000wa6yb8mlvt8cq","content":"<h2 id=\"Alfred-4\"><a href=\"#Alfred-4\" class=\"headerlink\" title=\"Alfred 4\"></a>Alfred 4</h2><p>版本号: 4.0.6</p>\n<p>功能介绍: <a href=\"https://www.alfredapp.com/whats-new/\" target=\"_blank\" rel=\"noopener\">https://www.alfredapp.com/whats-new/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA</a>  密码:9onb</p>\n<p>推荐指数: ★★★★★</p>\n<a id=\"more\"></a>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8z0whdj31a70u0q6x.jpg\" alt></p>\n<h2 id=\"CleanMyMac-X\"><a href=\"#CleanMyMac-X\" class=\"headerlink\" title=\"CleanMyMac X\"></a>CleanMyMac X</h2><p>版本号: 4.4.6</p>\n<p>功能介绍: <a href=\"https://macpaw.com/cleanmymac\" target=\"_blank\" rel=\"noopener\">https://macpaw.com/cleanmymac</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA</a>  密码:mslx</p>\n<p>推荐指数: ★★★★☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8yp8etj31e80u0go2.jpg\" alt></p>\n<h2 id=\"Movist-Pro\"><a href=\"#Movist-Pro\" class=\"headerlink\" title=\"Movist Pro\"></a>Movist Pro</h2><p>版本号: 2.2.13</p>\n<p>功能介绍: <a href=\"https://movistprime.com/\" target=\"_blank\" rel=\"noopener\">https://movistprime.com/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg</a>  密码:8ocb</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xhyx8j30rs0frabv.jpg\" alt></p>\n<h2 id=\"Final-Cut-Pro-X\"><a href=\"#Final-Cut-Pro-X\" class=\"headerlink\" title=\"Final Cut Pro X\"></a>Final Cut Pro X</h2><p>版本号: 10.4.5</p>\n<p>功能介绍: <a href=\"https://www.apple.com/final-cut-pro/\" target=\"_blank\" rel=\"noopener\">https://www.apple.com/final-cut-pro/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ</a>  密码:wqdk</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y1fq5j31gs0u0jti.jpg\" alt></p>\n<h2 id=\"Compressor\"><a href=\"#Compressor\" class=\"headerlink\" title=\"Compressor\"></a>Compressor</h2><p>版本号: 4.4.3</p>\n<p>功能介绍: <a href=\"https://www.apple.com.cn/cn/final-cut-pro/compressor/\" target=\"_blank\" rel=\"noopener\">https://www.apple.com.cn/cn/final-cut-pro/compressor/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA</a>  密码:8mng</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gauscey8r0j319x0u0gnq.jpg\" alt></p>\n<h2 id=\"iStat-Menus-6\"><a href=\"#iStat-Menus-6\" class=\"headerlink\" title=\"iStat Menus 6\"></a>iStat Menus 6</h2><p>版本号: 6.31</p>\n<p>功能介绍: <a href=\"https://bjango.com/mac/istatmenus/\" target=\"_blank\" rel=\"noopener\">https://bjango.com/mac/istatmenus/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ</a>  密码:r8yx</p>\n<p>推荐指数: ★★★★☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xrx3hj319e0u0tca.jpg\" alt></p>\n<h2 id=\"Parallels-Desktop-15\"><a href=\"#Parallels-Desktop-15\" class=\"headerlink\" title=\"Parallels Desktop 15\"></a>Parallels Desktop 15</h2><p>版本号: 15.1.2</p>\n<p>功能介绍: <a href=\"https://www.parallels.com/cn/landingpage/pd/general/\" target=\"_blank\" rel=\"noopener\">https://www.parallels.com/cn/landingpage/pd/general/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA</a>  密码:xfxi</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wjkifj319y0u00u6.jpg\" alt></p>\n<h2 id=\"XMind-8-Pro\"><a href=\"#XMind-8-Pro\" class=\"headerlink\" title=\"XMind 8 Pro\"></a>XMind 8 Pro</h2><p>版本号: 3.7.7</p>\n<p>功能介绍: <a href=\"https://www.xmind.cn/xmind8-pro/\" target=\"_blank\" rel=\"noopener\">https://www.xmind.cn/xmind8-pro/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA</a>  密码:3dio</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vmmwaj31cv0u0wfn.jpg\" alt></p>\n<h2 id=\"PDF-Expert\"><a href=\"#PDF-Expert\" class=\"headerlink\" title=\"PDF Expert\"></a>PDF Expert</h2><p>版本号: 2.4.23</p>\n<p>功能介绍: <a href=\"https://pdfexpert.com/\" target=\"_blank\" rel=\"noopener\">https://pdfexpert.com/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow</a>  密码:gkyo</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8w7qu7j31g20u0myq.jpg\" alt></p>\n<h2 id=\"Things-3\"><a href=\"#Things-3\" class=\"headerlink\" title=\"Things 3\"></a>Things 3</h2><p>版本号: 3.11</p>\n<p>功能介绍: <a href=\"https://culturedcode.com/things/\" target=\"_blank\" rel=\"noopener\">https://culturedcode.com/things/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ</a>  密码:ddv6</p>\n<p>推荐指数: ★★★☆☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vwlmgj311q0u0js9.jpg\" alt></p>\n<h2 id=\"Downie-3\"><a href=\"#Downie-3\" class=\"headerlink\" title=\"Downie 3\"></a>Downie 3</h2><p>版本号: 3.9.4</p>\n<p>功能介绍: <a href=\"https://software.charliemonroe.net/downie/\" target=\"_blank\" rel=\"noopener\">https://software.charliemonroe.net/downie/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA</a>  密码:cqma</p>\n<p>推荐指数: ★★★★☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y7letj31ck0l0mxq.jpg\" alt></p>\n<h2 id=\"Paste\"><a href=\"#Paste\" class=\"headerlink\" title=\"Paste\"></a>Paste</h2><p>版本号: 2.4.4</p>\n<p>功能介绍: <a href=\"https://pasteapp.me/\" target=\"_blank\" rel=\"noopener\">https://pasteapp.me/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g</a>  密码:4bxn</p>\n<p>推荐指数: ★★★★☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wqkbxj30vk0mu3zl.jpg\" alt></p>\n<h2 id=\"Bartender-3\"><a href=\"#Bartender-3\" class=\"headerlink\" title=\"Bartender 3\"></a>Bartender 3</h2><p>版本号: 3.1.1</p>\n<p>功能介绍: <a href=\"https://www.macbartender.com/\" target=\"_blank\" rel=\"noopener\">https://www.macbartender.com/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q</a>  密码:b00n</p>\n<p>推荐指数: ★★★☆☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxotf6egj30q106wgmk.jpg\" alt></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxpip1rej30q106wgm1.jpg\" alt></p>\n<h2 id=\"MWeb\"><a href=\"#MWeb\" class=\"headerlink\" title=\"MWeb\"></a>MWeb</h2><p>版本号: 3.2.2</p>\n<p>功能介绍: <a href=\"https://zh.mweb.im/\" target=\"_blank\" rel=\"noopener\">https://zh.mweb.im/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw</a>  密码:87dx</p>\n<p>推荐指数: ★★★☆☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8x805fj31fl0u0juk.jpg\" alt></p>\n<h2 id=\"Smooze\"><a href=\"#Smooze\" class=\"headerlink\" title=\"Smooze\"></a>Smooze</h2><p>版本号: 1.8.6</p>\n<p>功能介绍: <a href=\"https://smooze.co/\" target=\"_blank\" rel=\"noopener\">https://smooze.co/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw</a>  密码:upjo</p>\n<p>推荐指数: ★★☆☆☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxu7eqksj31el0u0x6p.jpg\" alt></p>\n<h2 id=\"Keka\"><a href=\"#Keka\" class=\"headerlink\" title=\"Keka\"></a>Keka</h2><p>版本号: 1.1.5</p>\n<p>功能介绍: <a href=\"https://www.keka.io/en/\" target=\"_blank\" rel=\"noopener\">https://www.keka.io/en/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ</a>  密码:7sdf</p>\n<p>推荐指数: ★★★☆☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaoy9qvhhfj30jo0oa43j.jpg\" alt></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>正版软件比破解版更稳定,且可以享受持续更新,在资金能力允许的范围内,呼吁大家支持正版!</p>\n<p>本站所有软件仅供学习使用,请在24小时内删除,本人不承担任何相关责任!</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Alfred-4\"><a href=\"#Alfred-4\" class=\"headerlink\" title=\"Alfred 4\"></a>Alfred 4</h2><p>版本号: 4.0.6</p>\n<p>功能介绍: <a href=\"https://www.alfredapp.com/whats-new/\" target=\"_blank\" rel=\"noopener\">https://www.alfredapp.com/whats-new/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA</a>  密码:9onb</p>\n<p>推荐指数: ★★★★★</p>","more":"<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8z0whdj31a70u0q6x.jpg\" alt></p>\n<h2 id=\"CleanMyMac-X\"><a href=\"#CleanMyMac-X\" class=\"headerlink\" title=\"CleanMyMac X\"></a>CleanMyMac X</h2><p>版本号: 4.4.6</p>\n<p>功能介绍: <a href=\"https://macpaw.com/cleanmymac\" target=\"_blank\" rel=\"noopener\">https://macpaw.com/cleanmymac</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA</a>  密码:mslx</p>\n<p>推荐指数: ★★★★☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8yp8etj31e80u0go2.jpg\" alt></p>\n<h2 id=\"Movist-Pro\"><a href=\"#Movist-Pro\" class=\"headerlink\" title=\"Movist Pro\"></a>Movist Pro</h2><p>版本号: 2.2.13</p>\n<p>功能介绍: <a href=\"https://movistprime.com/\" target=\"_blank\" rel=\"noopener\">https://movistprime.com/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg</a>  密码:8ocb</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xhyx8j30rs0frabv.jpg\" alt></p>\n<h2 id=\"Final-Cut-Pro-X\"><a href=\"#Final-Cut-Pro-X\" class=\"headerlink\" title=\"Final Cut Pro X\"></a>Final Cut Pro X</h2><p>版本号: 10.4.5</p>\n<p>功能介绍: <a href=\"https://www.apple.com/final-cut-pro/\" target=\"_blank\" rel=\"noopener\">https://www.apple.com/final-cut-pro/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ</a>  密码:wqdk</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y1fq5j31gs0u0jti.jpg\" alt></p>\n<h2 id=\"Compressor\"><a href=\"#Compressor\" class=\"headerlink\" title=\"Compressor\"></a>Compressor</h2><p>版本号: 4.4.3</p>\n<p>功能介绍: <a href=\"https://www.apple.com.cn/cn/final-cut-pro/compressor/\" target=\"_blank\" rel=\"noopener\">https://www.apple.com.cn/cn/final-cut-pro/compressor/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA</a>  密码:8mng</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gauscey8r0j319x0u0gnq.jpg\" alt></p>\n<h2 id=\"iStat-Menus-6\"><a href=\"#iStat-Menus-6\" class=\"headerlink\" title=\"iStat Menus 6\"></a>iStat Menus 6</h2><p>版本号: 6.31</p>\n<p>功能介绍: <a href=\"https://bjango.com/mac/istatmenus/\" target=\"_blank\" rel=\"noopener\">https://bjango.com/mac/istatmenus/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ</a>  密码:r8yx</p>\n<p>推荐指数: ★★★★☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xrx3hj319e0u0tca.jpg\" alt></p>\n<h2 id=\"Parallels-Desktop-15\"><a href=\"#Parallels-Desktop-15\" class=\"headerlink\" title=\"Parallels Desktop 15\"></a>Parallels Desktop 15</h2><p>版本号: 15.1.2</p>\n<p>功能介绍: <a href=\"https://www.parallels.com/cn/landingpage/pd/general/\" target=\"_blank\" rel=\"noopener\">https://www.parallels.com/cn/landingpage/pd/general/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA</a>  密码:xfxi</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wjkifj319y0u00u6.jpg\" alt></p>\n<h2 id=\"XMind-8-Pro\"><a href=\"#XMind-8-Pro\" class=\"headerlink\" title=\"XMind 8 Pro\"></a>XMind 8 Pro</h2><p>版本号: 3.7.7</p>\n<p>功能介绍: <a href=\"https://www.xmind.cn/xmind8-pro/\" target=\"_blank\" rel=\"noopener\">https://www.xmind.cn/xmind8-pro/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA</a>  密码:3dio</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vmmwaj31cv0u0wfn.jpg\" alt></p>\n<h2 id=\"PDF-Expert\"><a href=\"#PDF-Expert\" class=\"headerlink\" title=\"PDF Expert\"></a>PDF Expert</h2><p>版本号: 2.4.23</p>\n<p>功能介绍: <a href=\"https://pdfexpert.com/\" target=\"_blank\" rel=\"noopener\">https://pdfexpert.com/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow</a>  密码:gkyo</p>\n<p>推荐指数: ★★★★★</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8w7qu7j31g20u0myq.jpg\" alt></p>\n<h2 id=\"Things-3\"><a href=\"#Things-3\" class=\"headerlink\" title=\"Things 3\"></a>Things 3</h2><p>版本号: 3.11</p>\n<p>功能介绍: <a href=\"https://culturedcode.com/things/\" target=\"_blank\" rel=\"noopener\">https://culturedcode.com/things/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ</a>  密码:ddv6</p>\n<p>推荐指数: ★★★☆☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vwlmgj311q0u0js9.jpg\" alt></p>\n<h2 id=\"Downie-3\"><a href=\"#Downie-3\" class=\"headerlink\" title=\"Downie 3\"></a>Downie 3</h2><p>版本号: 3.9.4</p>\n<p>功能介绍: <a href=\"https://software.charliemonroe.net/downie/\" target=\"_blank\" rel=\"noopener\">https://software.charliemonroe.net/downie/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA</a>  密码:cqma</p>\n<p>推荐指数: ★★★★☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y7letj31ck0l0mxq.jpg\" alt></p>\n<h2 id=\"Paste\"><a href=\"#Paste\" class=\"headerlink\" title=\"Paste\"></a>Paste</h2><p>版本号: 2.4.4</p>\n<p>功能介绍: <a href=\"https://pasteapp.me/\" target=\"_blank\" rel=\"noopener\">https://pasteapp.me/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g</a>  密码:4bxn</p>\n<p>推荐指数: ★★★★☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wqkbxj30vk0mu3zl.jpg\" alt></p>\n<h2 id=\"Bartender-3\"><a href=\"#Bartender-3\" class=\"headerlink\" title=\"Bartender 3\"></a>Bartender 3</h2><p>版本号: 3.1.1</p>\n<p>功能介绍: <a href=\"https://www.macbartender.com/\" target=\"_blank\" rel=\"noopener\">https://www.macbartender.com/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q</a>  密码:b00n</p>\n<p>推荐指数: ★★★☆☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxotf6egj30q106wgmk.jpg\" alt></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxpip1rej30q106wgm1.jpg\" alt></p>\n<h2 id=\"MWeb\"><a href=\"#MWeb\" class=\"headerlink\" title=\"MWeb\"></a>MWeb</h2><p>版本号: 3.2.2</p>\n<p>功能介绍: <a href=\"https://zh.mweb.im/\" target=\"_blank\" rel=\"noopener\">https://zh.mweb.im/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw</a>  密码:87dx</p>\n<p>推荐指数: ★★★☆☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8x805fj31fl0u0juk.jpg\" alt></p>\n<h2 id=\"Smooze\"><a href=\"#Smooze\" class=\"headerlink\" title=\"Smooze\"></a>Smooze</h2><p>版本号: 1.8.6</p>\n<p>功能介绍: <a href=\"https://smooze.co/\" target=\"_blank\" rel=\"noopener\">https://smooze.co/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw</a>  密码:upjo</p>\n<p>推荐指数: ★★☆☆☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxu7eqksj31el0u0x6p.jpg\" alt></p>\n<h2 id=\"Keka\"><a href=\"#Keka\" class=\"headerlink\" title=\"Keka\"></a>Keka</h2><p>版本号: 1.1.5</p>\n<p>功能介绍: <a href=\"https://www.keka.io/en/\" target=\"_blank\" rel=\"noopener\">https://www.keka.io/en/</a></p>\n<p>破解版下载链接:<a href=\"https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ</a>  密码:7sdf</p>\n<p>推荐指数: ★★★☆☆</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaoy9qvhhfj30jo0oa43j.jpg\" alt></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>正版软件比破解版更稳定,且可以享受持续更新,在资金能力允许的范围内,呼吁大家支持正版!</p>\n<p>本站所有软件仅供学习使用,请在24小时内删除,本人不承担任何相关责任!</p>"},{"title":"单例模式的特点、适用场景、注意事项以及常见问题","date":"2017-11-10T08:40:22.000Z","_content":"\n## 定义\n\n单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。\n\n## 特点\n\n1. 单例类只能有一个实例。\n2. 单例类必须自己创建自己的唯一实例。\n3. 单例类必须给所有其他对象提供这一实例。\n\n<!-- more -->\n\n## 单例模式的要点\n\n1. 私有的构造方法\n2. 指向自己实例的私有静态引用\n3. 以自己实例为返回值的静态的公有的方法\n\n**单例模式根据实例化对象时机的不同分为两种**\n\n**一种是饿汉式单例，一种是懒汉式单例。**\n\n饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；\n\n而懒汉式在调用取得实例方法的时候才会实例化对象。\n\n代码如下：\n\n饿汉式单例\n\n```java\npublic class Singleton {  \n    private static Singleton singleton = new Singleton();  \n    private Singleton(){}  \n    public static Singleton getInstance(){  \n        return singleton;  \n    }  \n}\n```\n\n懒汉式单例\n\n```java\npublic class Singleton {\n    private static Singleton singleton;\n    private Singleton(){}\n\n    public static synchronized Singleton getInstance(){\n        if(singleton==null){\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n```\n\n单例模式还有一种比较常见的形式：**双重锁的形式**\n\n```java\npublic class Singleton{\n    private static volatile Singleton instance=null;    \n    private Singleton(){}    \n    public static Singleton getInstance(){\n        if(instance==null){\n            synchronized(SingletonClass.class){\n                if(instance==null){\n                    instance=new Singleton();\n                }\n            }\n        }\n    return instance;\n     }\n}\n```\n\n这个模式将同步内容下方到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。\n\n这种模式中双重判断加同步的方式，比第一个例子中的效率大大提升，因为如果单层if判断，在服务器允许的情况下，假设有一百个线程，耗费的时间为100*（同步判断时间+if判断时间），而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。\n\n所以如果面对高并发的情况，而且采用的是懒汉模式，最好的选择就是双重判断加同步的方式。\n\n## 单例模式的优点\n\n```html\n1，在内存中只有一个对象，节省内存空间。\n\n2，避免频繁的创建销毁对象，可以提高性能。\n\n3，避免对共享资源的多重占用。\n\n4，可以全局访问。\n```\n\n## 单例模式的缺点\n\n```html\n1，扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。\n\n2，隐式使用引起类结构不清晰。\n\n3，导致程序内存泄露的问题。\n```\n\n## 适用场景\n\n```html\n由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：\n\n1，需要频繁实例化然后销毁的对象。\n\n2，创建对象时耗时过多或者耗资源过多，但又经常用到的对象。\n\n3，资源共享的情况下，避免由于资源操作时导致的性能或损耗等\n\n4，控制资源的情况下，方便资源之间的互相通信。\n```\n\n## 单例模式注意事项\n\n只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。\n\n不要做断开单例类对象与类中静态引用的危险操作。\n\n多线程使用单例使用共享资源时，注意线程安全问题。\n\n\n\n## 关于Java中单例模式的一些常见问题\n\n#### 单例模式的对象长时间不用会被jvm垃圾收集器收集吗?\n\n```html\n除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。\n```\n\njvm卸载类的判定条件如下：\n\n```html\n1，该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。\n\n2，加载该类的ClassLoader已经被回收。\n\n3，该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。\n```\n\n#### 在一个jvm中会出现多个单例吗?\n\n在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。\n\n代码如下：\n\n```java\nClass c = Class.forName(Singleton.class.getName());  \nConstructor ct = c.getDeclaredConstructor();  \nct.setAccessible(true);  \nSingleton singleton = (Singleton)ct.newInstance();\n```\n\n这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。\n\n#### 在getInstance()方法上同步有优势还是仅同步必要的块更优优势？\n\n因为锁定仅仅在创建实例时才有意义，然后其他时候实例仅仅是只读访问的，因此只同步必要的块的性能更优，并且是更好的选择。\n\n缺点：只有在第一次调用的时候，才会出现生成2个对象，才必须要求同步。而一旦singleton 不为null，系统依旧花费同步锁开销，有点得不偿失。\n\n#### 单例类可以被继承吗?\n\n根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。\n\n这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：登记式单例，来使得单例对继承开放。","source":"_posts/singleton.md","raw":"---\ntitle: 单例模式的特点、适用场景、注意事项以及常见问题\ndate: 2017-11-10 16:40:22\ncategories: \n  - Java\n  - 设计模式\ntags:\n  - 设计模式\n  - singleton\n---\n\n## 定义\n\n单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。\n\n## 特点\n\n1. 单例类只能有一个实例。\n2. 单例类必须自己创建自己的唯一实例。\n3. 单例类必须给所有其他对象提供这一实例。\n\n<!-- more -->\n\n## 单例模式的要点\n\n1. 私有的构造方法\n2. 指向自己实例的私有静态引用\n3. 以自己实例为返回值的静态的公有的方法\n\n**单例模式根据实例化对象时机的不同分为两种**\n\n**一种是饿汉式单例，一种是懒汉式单例。**\n\n饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；\n\n而懒汉式在调用取得实例方法的时候才会实例化对象。\n\n代码如下：\n\n饿汉式单例\n\n```java\npublic class Singleton {  \n    private static Singleton singleton = new Singleton();  \n    private Singleton(){}  \n    public static Singleton getInstance(){  \n        return singleton;  \n    }  \n}\n```\n\n懒汉式单例\n\n```java\npublic class Singleton {\n    private static Singleton singleton;\n    private Singleton(){}\n\n    public static synchronized Singleton getInstance(){\n        if(singleton==null){\n            singleton = new Singleton();\n        }\n        return singleton;\n    }\n}\n```\n\n单例模式还有一种比较常见的形式：**双重锁的形式**\n\n```java\npublic class Singleton{\n    private static volatile Singleton instance=null;    \n    private Singleton(){}    \n    public static Singleton getInstance(){\n        if(instance==null){\n            synchronized(SingletonClass.class){\n                if(instance==null){\n                    instance=new Singleton();\n                }\n            }\n        }\n    return instance;\n     }\n}\n```\n\n这个模式将同步内容下方到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。\n\n这种模式中双重判断加同步的方式，比第一个例子中的效率大大提升，因为如果单层if判断，在服务器允许的情况下，假设有一百个线程，耗费的时间为100*（同步判断时间+if判断时间），而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。\n\n所以如果面对高并发的情况，而且采用的是懒汉模式，最好的选择就是双重判断加同步的方式。\n\n## 单例模式的优点\n\n```html\n1，在内存中只有一个对象，节省内存空间。\n\n2，避免频繁的创建销毁对象，可以提高性能。\n\n3，避免对共享资源的多重占用。\n\n4，可以全局访问。\n```\n\n## 单例模式的缺点\n\n```html\n1，扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。\n\n2，隐式使用引起类结构不清晰。\n\n3，导致程序内存泄露的问题。\n```\n\n## 适用场景\n\n```html\n由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：\n\n1，需要频繁实例化然后销毁的对象。\n\n2，创建对象时耗时过多或者耗资源过多，但又经常用到的对象。\n\n3，资源共享的情况下，避免由于资源操作时导致的性能或损耗等\n\n4，控制资源的情况下，方便资源之间的互相通信。\n```\n\n## 单例模式注意事项\n\n只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。\n\n不要做断开单例类对象与类中静态引用的危险操作。\n\n多线程使用单例使用共享资源时，注意线程安全问题。\n\n\n\n## 关于Java中单例模式的一些常见问题\n\n#### 单例模式的对象长时间不用会被jvm垃圾收集器收集吗?\n\n```html\n除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。\n```\n\njvm卸载类的判定条件如下：\n\n```html\n1，该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。\n\n2，加载该类的ClassLoader已经被回收。\n\n3，该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\n只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。\n```\n\n#### 在一个jvm中会出现多个单例吗?\n\n在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。\n\n代码如下：\n\n```java\nClass c = Class.forName(Singleton.class.getName());  \nConstructor ct = c.getDeclaredConstructor();  \nct.setAccessible(true);  \nSingleton singleton = (Singleton)ct.newInstance();\n```\n\n这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。\n\n#### 在getInstance()方法上同步有优势还是仅同步必要的块更优优势？\n\n因为锁定仅仅在创建实例时才有意义，然后其他时候实例仅仅是只读访问的，因此只同步必要的块的性能更优，并且是更好的选择。\n\n缺点：只有在第一次调用的时候，才会出现生成2个对象，才必须要求同步。而一旦singleton 不为null，系统依旧花费同步锁开销，有点得不偿失。\n\n#### 单例类可以被继承吗?\n\n根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。\n\n这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：登记式单例，来使得单例对继承开放。","slug":"singleton","published":1,"updated":"2020-01-17T05:10:55.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61biw0011a6ybwkcddtcf","content":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>单例类只能有一个实例。</li>\n<li>单例类必须自己创建自己的唯一实例。</li>\n<li>单例类必须给所有其他对象提供这一实例。</li>\n</ol>\n<a id=\"more\"></a>\n\n<h2 id=\"单例模式的要点\"><a href=\"#单例模式的要点\" class=\"headerlink\" title=\"单例模式的要点\"></a>单例模式的要点</h2><ol>\n<li>私有的构造方法</li>\n<li>指向自己实例的私有静态引用</li>\n<li>以自己实例为返回值的静态的公有的方法</li>\n</ol>\n<p><strong>单例模式根据实例化对象时机的不同分为两种</strong></p>\n<p><strong>一种是饿汉式单例，一种是懒汉式单例。</strong></p>\n<p>饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；</p>\n<p>而懒汉式在调用取得实例方法的时候才会实例化对象。</p>\n<p>代码如下：</p>\n<p>饿汉式单例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>懒汉式单例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(singleton==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单例模式还有一种比较常见的形式：<strong>双重锁的形式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"keyword\">null</span>;    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(SingletonClass.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    instance=<span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个模式将同步内容下方到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。</p>\n<p>这种模式中双重判断加同步的方式，比第一个例子中的效率大大提升，因为如果单层if判断，在服务器允许的情况下，假设有一百个线程，耗费的时间为100*（同步判断时间+if判断时间），而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。</p>\n<p>所以如果面对高并发的情况，而且采用的是懒汉模式，最好的选择就是双重判断加同步的方式。</p>\n<h2 id=\"单例模式的优点\"><a href=\"#单例模式的优点\" class=\"headerlink\" title=\"单例模式的优点\"></a>单例模式的优点</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1，在内存中只有一个对象，节省内存空间。</span><br><span class=\"line\"></span><br><span class=\"line\">2，避免频繁的创建销毁对象，可以提高性能。</span><br><span class=\"line\"></span><br><span class=\"line\">3，避免对共享资源的多重占用。</span><br><span class=\"line\"></span><br><span class=\"line\">4，可以全局访问。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单例模式的缺点\"><a href=\"#单例模式的缺点\" class=\"headerlink\" title=\"单例模式的缺点\"></a>单例模式的缺点</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1，扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。</span><br><span class=\"line\"></span><br><span class=\"line\">2，隐式使用引起类结构不清晰。</span><br><span class=\"line\"></span><br><span class=\"line\">3，导致程序内存泄露的问题。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：</span><br><span class=\"line\"></span><br><span class=\"line\">1，需要频繁实例化然后销毁的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">2，创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">3，资源共享的情况下，避免由于资源操作时导致的性能或损耗等</span><br><span class=\"line\"></span><br><span class=\"line\">4，控制资源的情况下，方便资源之间的互相通信。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单例模式注意事项\"><a href=\"#单例模式注意事项\" class=\"headerlink\" title=\"单例模式注意事项\"></a>单例模式注意事项</h2><p>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</p>\n<p>不要做断开单例类对象与类中静态引用的危险操作。</p>\n<p>多线程使用单例使用共享资源时，注意线程安全问题。</p>\n<h2 id=\"关于Java中单例模式的一些常见问题\"><a href=\"#关于Java中单例模式的一些常见问题\" class=\"headerlink\" title=\"关于Java中单例模式的一些常见问题\"></a>关于Java中单例模式的一些常见问题</h2><h4 id=\"单例模式的对象长时间不用会被jvm垃圾收集器收集吗\"><a href=\"#单例模式的对象长时间不用会被jvm垃圾收集器收集吗\" class=\"headerlink\" title=\"单例模式的对象长时间不用会被jvm垃圾收集器收集吗?\"></a>单例模式的对象长时间不用会被jvm垃圾收集器收集吗?</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。</span><br></pre></td></tr></table></figure>\n\n<p>jvm卸载类的判定条件如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1，该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</span><br><span class=\"line\"></span><br><span class=\"line\">2，加载该类的ClassLoader已经被回收。</span><br><span class=\"line\"></span><br><span class=\"line\">3，该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在一个jvm中会出现多个单例吗\"><a href=\"#在一个jvm中会出现多个单例吗\" class=\"headerlink\" title=\"在一个jvm中会出现多个单例吗?\"></a>在一个jvm中会出现多个单例吗?</h4><p>在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c = Class.forName(Singleton.class.getName());  </span><br><span class=\"line\">Constructor ct = c.getDeclaredConstructor();  </span><br><span class=\"line\">ct.setAccessible(<span class=\"keyword\">true</span>);  </span><br><span class=\"line\">Singleton singleton = (Singleton)ct.newInstance();</span><br></pre></td></tr></table></figure>\n\n<p>这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。</p>\n<h4 id=\"在getInstance-方法上同步有优势还是仅同步必要的块更优优势？\"><a href=\"#在getInstance-方法上同步有优势还是仅同步必要的块更优优势？\" class=\"headerlink\" title=\"在getInstance()方法上同步有优势还是仅同步必要的块更优优势？\"></a>在getInstance()方法上同步有优势还是仅同步必要的块更优优势？</h4><p>因为锁定仅仅在创建实例时才有意义，然后其他时候实例仅仅是只读访问的，因此只同步必要的块的性能更优，并且是更好的选择。</p>\n<p>缺点：只有在第一次调用的时候，才会出现生成2个对象，才必须要求同步。而一旦singleton 不为null，系统依旧花费同步锁开销，有点得不偿失。</p>\n<h4 id=\"单例类可以被继承吗\"><a href=\"#单例类可以被继承吗\" class=\"headerlink\" title=\"单例类可以被继承吗?\"></a>单例类可以被继承吗?</h4><p>根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。</p>\n<p>这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：登记式单例，来使得单例对继承开放。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p>单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例。即一个类只有一个对象实例。</p>\n<h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><ol>\n<li>单例类只能有一个实例。</li>\n<li>单例类必须自己创建自己的唯一实例。</li>\n<li>单例类必须给所有其他对象提供这一实例。</li>\n</ol>","more":"<h2 id=\"单例模式的要点\"><a href=\"#单例模式的要点\" class=\"headerlink\" title=\"单例模式的要点\"></a>单例模式的要点</h2><ol>\n<li>私有的构造方法</li>\n<li>指向自己实例的私有静态引用</li>\n<li>以自己实例为返回值的静态的公有的方法</li>\n</ol>\n<p><strong>单例模式根据实例化对象时机的不同分为两种</strong></p>\n<p><strong>一种是饿汉式单例，一种是懒汉式单例。</strong></p>\n<p>饿汉式单例在单例类被加载时候，就实例化一个对象交给自己的引用；</p>\n<p>而懒汉式在调用取得实例方法的时候才会实例化对象。</p>\n<p>代码如下：</p>\n<p>饿汉式单例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton = <span class=\"keyword\">new</span> Singleton();  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>懒汉式单例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton singleton;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(singleton==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>单例模式还有一种比较常见的形式：<strong>双重锁的形式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton instance=<span class=\"keyword\">null</span>;    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span>(SingletonClass.class)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(instance==<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                    instance=<span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个模式将同步内容下方到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。</p>\n<p>这种模式中双重判断加同步的方式，比第一个例子中的效率大大提升，因为如果单层if判断，在服务器允许的情况下，假设有一百个线程，耗费的时间为100*（同步判断时间+if判断时间），而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。</p>\n<p>所以如果面对高并发的情况，而且采用的是懒汉模式，最好的选择就是双重判断加同步的方式。</p>\n<h2 id=\"单例模式的优点\"><a href=\"#单例模式的优点\" class=\"headerlink\" title=\"单例模式的优点\"></a>单例模式的优点</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1，在内存中只有一个对象，节省内存空间。</span><br><span class=\"line\"></span><br><span class=\"line\">2，避免频繁的创建销毁对象，可以提高性能。</span><br><span class=\"line\"></span><br><span class=\"line\">3，避免对共享资源的多重占用。</span><br><span class=\"line\"></span><br><span class=\"line\">4，可以全局访问。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单例模式的缺点\"><a href=\"#单例模式的缺点\" class=\"headerlink\" title=\"单例模式的缺点\"></a>单例模式的缺点</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1，扩展困难，由于getInstance静态函数没有办法生成子类的实例。如果要拓展，只有重写那个类。</span><br><span class=\"line\"></span><br><span class=\"line\">2，隐式使用引起类结构不清晰。</span><br><span class=\"line\"></span><br><span class=\"line\">3，导致程序内存泄露的问题。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">由于单例模式的以上优点，所以是编程中用的比较多的一种设计模式。以下为使用单例模式的场景：</span><br><span class=\"line\"></span><br><span class=\"line\">1，需要频繁实例化然后销毁的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">2，创建对象时耗时过多或者耗资源过多，但又经常用到的对象。</span><br><span class=\"line\"></span><br><span class=\"line\">3，资源共享的情况下，避免由于资源操作时导致的性能或损耗等</span><br><span class=\"line\"></span><br><span class=\"line\">4，控制资源的情况下，方便资源之间的互相通信。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"单例模式注意事项\"><a href=\"#单例模式注意事项\" class=\"headerlink\" title=\"单例模式注意事项\"></a>单例模式注意事项</h2><p>只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。</p>\n<p>不要做断开单例类对象与类中静态引用的危险操作。</p>\n<p>多线程使用单例使用共享资源时，注意线程安全问题。</p>\n<h2 id=\"关于Java中单例模式的一些常见问题\"><a href=\"#关于Java中单例模式的一些常见问题\" class=\"headerlink\" title=\"关于Java中单例模式的一些常见问题\"></a>关于Java中单例模式的一些常见问题</h2><h4 id=\"单例模式的对象长时间不用会被jvm垃圾收集器收集吗\"><a href=\"#单例模式的对象长时间不用会被jvm垃圾收集器收集吗\" class=\"headerlink\" title=\"单例模式的对象长时间不用会被jvm垃圾收集器收集吗?\"></a>单例模式的对象长时间不用会被jvm垃圾收集器收集吗?</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。</span><br></pre></td></tr></table></figure>\n\n<p>jvm卸载类的判定条件如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1，该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</span><br><span class=\"line\"></span><br><span class=\"line\">2，加载该类的ClassLoader已经被回收。</span><br><span class=\"line\"></span><br><span class=\"line\">3，该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</span><br><span class=\"line\"></span><br><span class=\"line\">只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被回收。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在一个jvm中会出现多个单例吗\"><a href=\"#在一个jvm中会出现多个单例吗\" class=\"headerlink\" title=\"在一个jvm中会出现多个单例吗?\"></a>在一个jvm中会出现多个单例吗?</h4><p>在分布式系统、多个类加载器、以及序列化的的情况下，会产生多个单例，这一点是无庸置疑的。那么在同一个jvm中，会不会产生单例呢？使用单例提供的getInstance()方法只能得到同一个单例，除非是使用反射方式，将会得到新的单例。</p>\n<p>代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class c = Class.forName(Singleton.class.getName());  </span><br><span class=\"line\">Constructor ct = c.getDeclaredConstructor();  </span><br><span class=\"line\">ct.setAccessible(<span class=\"keyword\">true</span>);  </span><br><span class=\"line\">Singleton singleton = (Singleton)ct.newInstance();</span><br></pre></td></tr></table></figure>\n\n<p>这样，每次运行都会产生新的单例对象。所以运用单例模式时，一定注意不要使用反射产生新的单例对象。</p>\n<h4 id=\"在getInstance-方法上同步有优势还是仅同步必要的块更优优势？\"><a href=\"#在getInstance-方法上同步有优势还是仅同步必要的块更优优势？\" class=\"headerlink\" title=\"在getInstance()方法上同步有优势还是仅同步必要的块更优优势？\"></a>在getInstance()方法上同步有优势还是仅同步必要的块更优优势？</h4><p>因为锁定仅仅在创建实例时才有意义，然后其他时候实例仅仅是只读访问的，因此只同步必要的块的性能更优，并且是更好的选择。</p>\n<p>缺点：只有在第一次调用的时候，才会出现生成2个对象，才必须要求同步。而一旦singleton 不为null，系统依旧花费同步锁开销，有点得不偿失。</p>\n<h4 id=\"单例类可以被继承吗\"><a href=\"#单例类可以被继承吗\" class=\"headerlink\" title=\"单例类可以被继承吗?\"></a>单例类可以被继承吗?</h4><p>根据单例实例构造的时机和方式不同，单例模式还可以分成几种。但对于这种通过私有化构造函数，静态方法提供实例的单例类而言，是不支持继承的。</p>\n<p>这种模式的单例实现要求每个具体的单例类自身来维护单例实例和限制多个实例的生成。但可以采用另外一种实现单例的思路：登记式单例，来使得单例对继承开放。</p>"},{"title":"win10系统激活，内附激活码和激活软件","date":"2019-03-10T14:45:30.000Z","_content":"\n## 本文提供两种激活方式，随意选择\n\n### 方式一\n\n1. 启动win10点击桌面左下角的开始菜单，点击“设置”图标，选择“更新和安全”，并切换到“激活”选项卡，在此就可以查看到当前系统的激活状态。![](https://tva1.sinaimg.cn/large/006tNbRwgy1gausj7rd5jj30s40hlabi.jpg)\n\n   <!-- more -->\n\n2. 在开始菜单处点击鼠标右键，选择Windows PowerShell（管理员）。![](https://tva1.sinaimg.cn/large/006tNbRwgy1gara1vmqssj30aq0icaau.jpg)\n\n3. 此时将“以管理员身份”打开“MSDOS”窗口，在此界面中输入：slmgr.vbs /upk，按回车进行确定。![](https://tva1.sinaimg.cn/large/006tNbRwgy1gara4r1m07j30cd040dft.jpg)\n\n4. 此时弹出窗口显未“已成功卸载了产品密钥”\n\n5. 接着输入以下命令：slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX\n\n6. 弹出窗口提示：“成功的安装了产品密钥”。\n\n7. 继续输入以下命令：slmgr /skms zh.us.to\n\n8. 弹出窗口提示：“密钥管理服务计算机名成功的设置为zh.us.to”。\n\n9. 接下来输入以下命令：slmgr /ato此时将弹出窗口提示：“成功的激活了产品”。\n\n10. 最后就可以再次查看当前Win10专业版系统的激活状态啦。\n\n以上只演示了Win10专业版系统的激活方法，如果大家拥有Win10正式版其它系统版本的密钥，也可以利用类似的操作方法进行激活。\n\n### 方式二\n\n激活软件下载链接:https://pan.baidu.com/s/19D-n_3S4Ulqx5VZhbcB6fQ  密码:md2f\n\n此软件还附带激活Office功能，在我的电脑上右键查看属性，就可以看到系统的激活状态了。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1garaedv33mj30ol0gg75z.jpg)","source":"_posts/win-activation.md","raw":"---\ntitle: win10系统激活，内附激活码和激活软件\ndate: 2019-03-10 22:45:30\ncategories: System\ntags:\n  - Windows\n  - activation\n---\n\n## 本文提供两种激活方式，随意选择\n\n### 方式一\n\n1. 启动win10点击桌面左下角的开始菜单，点击“设置”图标，选择“更新和安全”，并切换到“激活”选项卡，在此就可以查看到当前系统的激活状态。![](https://tva1.sinaimg.cn/large/006tNbRwgy1gausj7rd5jj30s40hlabi.jpg)\n\n   <!-- more -->\n\n2. 在开始菜单处点击鼠标右键，选择Windows PowerShell（管理员）。![](https://tva1.sinaimg.cn/large/006tNbRwgy1gara1vmqssj30aq0icaau.jpg)\n\n3. 此时将“以管理员身份”打开“MSDOS”窗口，在此界面中输入：slmgr.vbs /upk，按回车进行确定。![](https://tva1.sinaimg.cn/large/006tNbRwgy1gara4r1m07j30cd040dft.jpg)\n\n4. 此时弹出窗口显未“已成功卸载了产品密钥”\n\n5. 接着输入以下命令：slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX\n\n6. 弹出窗口提示：“成功的安装了产品密钥”。\n\n7. 继续输入以下命令：slmgr /skms zh.us.to\n\n8. 弹出窗口提示：“密钥管理服务计算机名成功的设置为zh.us.to”。\n\n9. 接下来输入以下命令：slmgr /ato此时将弹出窗口提示：“成功的激活了产品”。\n\n10. 最后就可以再次查看当前Win10专业版系统的激活状态啦。\n\n以上只演示了Win10专业版系统的激活方法，如果大家拥有Win10正式版其它系统版本的密钥，也可以利用类似的操作方法进行激活。\n\n### 方式二\n\n激活软件下载链接:https://pan.baidu.com/s/19D-n_3S4Ulqx5VZhbcB6fQ  密码:md2f\n\n此软件还附带激活Office功能，在我的电脑上右键查看属性，就可以看到系统的激活状态了。\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1garaedv33mj30ol0gg75z.jpg)","slug":"win-activation","published":1,"updated":"2020-01-14T00:55:01.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bix0014a6yb17in9nac","content":"<h2 id=\"本文提供两种激活方式，随意选择\"><a href=\"#本文提供两种激活方式，随意选择\" class=\"headerlink\" title=\"本文提供两种激活方式，随意选择\"></a>本文提供两种激活方式，随意选择</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><ol>\n<li><p>启动win10点击桌面左下角的开始菜单，点击“设置”图标，选择“更新和安全”，并切换到“激活”选项卡，在此就可以查看到当前系统的激活状态。<img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gausj7rd5jj30s40hlabi.jpg\" alt></p>\n<a id=\"more\"></a>\n</li>\n<li><p>在开始菜单处点击鼠标右键，选择Windows PowerShell（管理员）。<img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gara1vmqssj30aq0icaau.jpg\" alt></p>\n</li>\n<li><p>此时将“以管理员身份”打开“MSDOS”窗口，在此界面中输入：slmgr.vbs /upk，按回车进行确定。<img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gara4r1m07j30cd040dft.jpg\" alt></p>\n</li>\n<li><p>此时弹出窗口显未“已成功卸载了产品密钥”</p>\n</li>\n<li><p>接着输入以下命令：slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</p>\n</li>\n<li><p>弹出窗口提示：“成功的安装了产品密钥”。</p>\n</li>\n<li><p>继续输入以下命令：slmgr /skms zh.us.to</p>\n</li>\n<li><p>弹出窗口提示：“密钥管理服务计算机名成功的设置为zh.us.to”。</p>\n</li>\n<li><p>接下来输入以下命令：slmgr /ato此时将弹出窗口提示：“成功的激活了产品”。</p>\n</li>\n<li><p>最后就可以再次查看当前Win10专业版系统的激活状态啦。</p>\n</li>\n</ol>\n<p>以上只演示了Win10专业版系统的激活方法，如果大家拥有Win10正式版其它系统版本的密钥，也可以利用类似的操作方法进行激活。</p>\n<h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>激活软件下载链接:<a href=\"https://pan.baidu.com/s/19D-n_3S4Ulqx5VZhbcB6fQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/19D-n_3S4Ulqx5VZhbcB6fQ</a>  密码:md2f</p>\n<p>此软件还附带激活Office功能，在我的电脑上右键查看属性，就可以看到系统的激活状态了。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1garaedv33mj30ol0gg75z.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"本文提供两种激活方式，随意选择\"><a href=\"#本文提供两种激活方式，随意选择\" class=\"headerlink\" title=\"本文提供两种激活方式，随意选择\"></a>本文提供两种激活方式，随意选择</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><ol>\n<li><p>启动win10点击桌面左下角的开始菜单，点击“设置”图标，选择“更新和安全”，并切换到“激活”选项卡，在此就可以查看到当前系统的激活状态。<img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gausj7rd5jj30s40hlabi.jpg\" alt></p>","more":"</li>\n<li><p>在开始菜单处点击鼠标右键，选择Windows PowerShell（管理员）。<img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gara1vmqssj30aq0icaau.jpg\" alt></p>\n</li>\n<li><p>此时将“以管理员身份”打开“MSDOS”窗口，在此界面中输入：slmgr.vbs /upk，按回车进行确定。<img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gara4r1m07j30cd040dft.jpg\" alt></p>\n</li>\n<li><p>此时弹出窗口显未“已成功卸载了产品密钥”</p>\n</li>\n<li><p>接着输入以下命令：slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</p>\n</li>\n<li><p>弹出窗口提示：“成功的安装了产品密钥”。</p>\n</li>\n<li><p>继续输入以下命令：slmgr /skms zh.us.to</p>\n</li>\n<li><p>弹出窗口提示：“密钥管理服务计算机名成功的设置为zh.us.to”。</p>\n</li>\n<li><p>接下来输入以下命令：slmgr /ato此时将弹出窗口提示：“成功的激活了产品”。</p>\n</li>\n<li><p>最后就可以再次查看当前Win10专业版系统的激活状态啦。</p>\n</li>\n</ol>\n<p>以上只演示了Win10专业版系统的激活方法，如果大家拥有Win10正式版其它系统版本的密钥，也可以利用类似的操作方法进行激活。</p>\n<h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>激活软件下载链接:<a href=\"https://pan.baidu.com/s/19D-n_3S4Ulqx5VZhbcB6fQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/19D-n_3S4Ulqx5VZhbcB6fQ</a>  密码:md2f</p>\n<p>此软件还附带激活Office功能，在我的电脑上右键查看属性，就可以看到系统的激活状态了。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1garaedv33mj30ol0gg75z.jpg\" alt></p>"},{"title":"Nginx相关","date":"2018-06-06T13:32:24.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## Nginx安装配置\n\nhttps://www.runoob.com/linux/nginx-install-setup.html\n\n**正向代理**：正向代理的对象是客户端\t举例：访问Youtube挂VPN\n\n**反向代理**：反向代理的对象是服务器\t举例：各大电商平台的服务器\n\n**常用的web服务器**：Apache，Nginx，Tomcat，Jetty，Netty，Jboss，iis等\n\n**nginx的常用命令**\n\n- ./nginx   启动\n- ./nginx -t  检查nginx.conf文件格式\n- ./nginx -s stop  停止\n- ./nginx -s reload  重启nginx\n\n<!-- more -->\n\n## nginx的核心配置文件\n\nmain、events、http\n\n**nginx.conf**\n\n```xml\nworker_processes  2; #工作进程数\nerror_log  /usr/local/webserver/nginx/logs/nginx_error.log warn;\nworker_rlimit_nofile 10240; #最大打开文件的限制\nevents {\n    worker_connections  10240; #不能超过上面的数字\n}\nhttp {\n    include       mime.types; #请求头的映射关系表\n    default_type  application/octet-stream; #上面找不到的话会用这个\n    sendfile        on; #用来开启高效传输的模式\n    keepalive_timeout  65; #http连接的超时时间\n\n    include /etc/nginx/conf.d/*.conf;\n}\n```\n\n**proxy.conf**\n\n```xml\nserver{\n    listen 80;\n    server_name  localhost;\n    location / {\n        root   html;\n        index  index.html index.htm;\n    }\n}\nserver{\n    listen 8080;\n    server_name  sjaylee;\n    location / {\n        proxy_pass http://mysvr;\n        root   html;\n        index  index.html index.htm;\n    }\n}\n```\n\n**upstream.conf**\n\n```xml\nupstream.conf\nupstream mysvr{\n    server 10.211.55.4:8081;\n    server 10.211.55.4:8082;\n}\n```\n\n## location的匹配规则\n\n基础语法有三种：\n\n- location pattern {}\t一般匹配\n- location = pattern {}\t精准匹配\n- location ~pattern {}\t正则匹配\n\n**nginx的负载均衡和负载均衡的调度算法**\n\nupstream：ip_hash、轮询(默认)、weight、fair、url_hash。\n\nip_hash算法是对服务器的IP地址进行hash运算来获取对应代理服务器，好处是不需要考虑session跨域。\n\nweight算法是根据权重来合理分配各个代理服务器的调用比例。\n\n## nginx日志切分\n\n第一步：分析如何去实现日志切分，编写shell脚本，记得要给脚本赋予可执行权限。\n\n第二步：启动定时任务对脚本进行调度：crontab -e\n\n定时任务格式：\n\n```bash\n*/1 * * * * sh /usr/local/webserver/nginx/logs/access.log\n```\n\n第三步：新增split_log.sh文件，并给其增加权限，chmod 777 文件名\n\n**split_log.sh**\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1garbdepmokj30ik0mm4ev.jpg)","source":"_posts/nginx.md","raw":"---\ntitle: Nginx相关\ndate: 2018-06-06 21:32:24\ncategories: Java\ntags:\n  - 分布式\n  - nginx\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## Nginx安装配置\n\nhttps://www.runoob.com/linux/nginx-install-setup.html\n\n**正向代理**：正向代理的对象是客户端\t举例：访问Youtube挂VPN\n\n**反向代理**：反向代理的对象是服务器\t举例：各大电商平台的服务器\n\n**常用的web服务器**：Apache，Nginx，Tomcat，Jetty，Netty，Jboss，iis等\n\n**nginx的常用命令**\n\n- ./nginx   启动\n- ./nginx -t  检查nginx.conf文件格式\n- ./nginx -s stop  停止\n- ./nginx -s reload  重启nginx\n\n<!-- more -->\n\n## nginx的核心配置文件\n\nmain、events、http\n\n**nginx.conf**\n\n```xml\nworker_processes  2; #工作进程数\nerror_log  /usr/local/webserver/nginx/logs/nginx_error.log warn;\nworker_rlimit_nofile 10240; #最大打开文件的限制\nevents {\n    worker_connections  10240; #不能超过上面的数字\n}\nhttp {\n    include       mime.types; #请求头的映射关系表\n    default_type  application/octet-stream; #上面找不到的话会用这个\n    sendfile        on; #用来开启高效传输的模式\n    keepalive_timeout  65; #http连接的超时时间\n\n    include /etc/nginx/conf.d/*.conf;\n}\n```\n\n**proxy.conf**\n\n```xml\nserver{\n    listen 80;\n    server_name  localhost;\n    location / {\n        root   html;\n        index  index.html index.htm;\n    }\n}\nserver{\n    listen 8080;\n    server_name  sjaylee;\n    location / {\n        proxy_pass http://mysvr;\n        root   html;\n        index  index.html index.htm;\n    }\n}\n```\n\n**upstream.conf**\n\n```xml\nupstream.conf\nupstream mysvr{\n    server 10.211.55.4:8081;\n    server 10.211.55.4:8082;\n}\n```\n\n## location的匹配规则\n\n基础语法有三种：\n\n- location pattern {}\t一般匹配\n- location = pattern {}\t精准匹配\n- location ~pattern {}\t正则匹配\n\n**nginx的负载均衡和负载均衡的调度算法**\n\nupstream：ip_hash、轮询(默认)、weight、fair、url_hash。\n\nip_hash算法是对服务器的IP地址进行hash运算来获取对应代理服务器，好处是不需要考虑session跨域。\n\nweight算法是根据权重来合理分配各个代理服务器的调用比例。\n\n## nginx日志切分\n\n第一步：分析如何去实现日志切分，编写shell脚本，记得要给脚本赋予可执行权限。\n\n第二步：启动定时任务对脚本进行调度：crontab -e\n\n定时任务格式：\n\n```bash\n*/1 * * * * sh /usr/local/webserver/nginx/logs/access.log\n```\n\n第三步：新增split_log.sh文件，并给其增加权限，chmod 777 文件名\n\n**split_log.sh**\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1garbdepmokj30ik0mm4ev.jpg)","slug":"nginx","published":1,"updated":"2020-01-16T13:26:35.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61biz0017a6ybenu5rvm4","content":"<h2 id=\"Nginx安装配置\"><a href=\"#Nginx安装配置\" class=\"headerlink\" title=\"Nginx安装配置\"></a>Nginx安装配置</h2><p><a href=\"https://www.runoob.com/linux/nginx-install-setup.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/linux/nginx-install-setup.html</a></p>\n<p><strong>正向代理</strong>：正向代理的对象是客户端    举例：访问Youtube挂VPN</p>\n<p><strong>反向代理</strong>：反向代理的对象是服务器    举例：各大电商平台的服务器</p>\n<p><strong>常用的web服务器</strong>：Apache，Nginx，Tomcat，Jetty，Netty，Jboss，iis等</p>\n<p><strong>nginx的常用命令</strong></p>\n<ul>\n<li>./nginx   启动</li>\n<li>./nginx -t  检查nginx.conf文件格式</li>\n<li>./nginx -s stop  停止</li>\n<li>./nginx -s reload  重启nginx</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"nginx的核心配置文件\"><a href=\"#nginx的核心配置文件\" class=\"headerlink\" title=\"nginx的核心配置文件\"></a>nginx的核心配置文件</h2><p>main、events、http</p>\n<p><strong>nginx.conf</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker_processes  2; #工作进程数</span><br><span class=\"line\">error_log  /usr/local/webserver/nginx/logs/nginx_error.log warn;</span><br><span class=\"line\">worker_rlimit_nofile 10240; #最大打开文件的限制</span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  10240; #不能超过上面的数字</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types; #请求头的映射关系表</span><br><span class=\"line\">    default_type  application/octet-stream; #上面找不到的话会用这个</span><br><span class=\"line\">    sendfile        on; #用来开启高效传输的模式</span><br><span class=\"line\">    keepalive_timeout  65; #http连接的超时时间</span><br><span class=\"line\"></span><br><span class=\"line\">    include /etc/nginx/conf.d/*.conf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>proxy.conf</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name  localhost;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   html;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">    listen 8080;</span><br><span class=\"line\">    server_name  sjaylee;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://mysvr;</span><br><span class=\"line\">        root   html;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>upstream.conf</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream.conf</span><br><span class=\"line\">upstream mysvr&#123;</span><br><span class=\"line\">    server 10.211.55.4:8081;</span><br><span class=\"line\">    server 10.211.55.4:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"location的匹配规则\"><a href=\"#location的匹配规则\" class=\"headerlink\" title=\"location的匹配规则\"></a>location的匹配规则</h2><p>基础语法有三种：</p>\n<ul>\n<li>location pattern {}    一般匹配</li>\n<li>location = pattern {}    精准匹配</li>\n<li>location ~pattern {}    正则匹配</li>\n</ul>\n<p><strong>nginx的负载均衡和负载均衡的调度算法</strong></p>\n<p>upstream：ip_hash、轮询(默认)、weight、fair、url_hash。</p>\n<p>ip_hash算法是对服务器的IP地址进行hash运算来获取对应代理服务器，好处是不需要考虑session跨域。</p>\n<p>weight算法是根据权重来合理分配各个代理服务器的调用比例。</p>\n<h2 id=\"nginx日志切分\"><a href=\"#nginx日志切分\" class=\"headerlink\" title=\"nginx日志切分\"></a>nginx日志切分</h2><p>第一步：分析如何去实现日志切分，编写shell脚本，记得要给脚本赋予可执行权限。</p>\n<p>第二步：启动定时任务对脚本进行调度：crontab -e</p>\n<p>定时任务格式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/1 * * * * sh /usr/<span class=\"built_in\">local</span>/webserver/nginx/logs/access.log</span><br></pre></td></tr></table></figure>\n\n<p>第三步：新增split_log.sh文件，并给其增加权限，chmod 777 文件名</p>\n<p><strong>split_log.sh</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1garbdepmokj30ik0mm4ev.jpg\" alt></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Nginx安装配置\"><a href=\"#Nginx安装配置\" class=\"headerlink\" title=\"Nginx安装配置\"></a>Nginx安装配置</h2><p><a href=\"https://www.runoob.com/linux/nginx-install-setup.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/linux/nginx-install-setup.html</a></p>\n<p><strong>正向代理</strong>：正向代理的对象是客户端    举例：访问Youtube挂VPN</p>\n<p><strong>反向代理</strong>：反向代理的对象是服务器    举例：各大电商平台的服务器</p>\n<p><strong>常用的web服务器</strong>：Apache，Nginx，Tomcat，Jetty，Netty，Jboss，iis等</p>\n<p><strong>nginx的常用命令</strong></p>\n<ul>\n<li>./nginx   启动</li>\n<li>./nginx -t  检查nginx.conf文件格式</li>\n<li>./nginx -s stop  停止</li>\n<li>./nginx -s reload  重启nginx</li>\n</ul>","more":"<h2 id=\"nginx的核心配置文件\"><a href=\"#nginx的核心配置文件\" class=\"headerlink\" title=\"nginx的核心配置文件\"></a>nginx的核心配置文件</h2><p>main、events、http</p>\n<p><strong>nginx.conf</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">worker_processes  2; #工作进程数</span><br><span class=\"line\">error_log  /usr/local/webserver/nginx/logs/nginx_error.log warn;</span><br><span class=\"line\">worker_rlimit_nofile 10240; #最大打开文件的限制</span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    worker_connections  10240; #不能超过上面的数字</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types; #请求头的映射关系表</span><br><span class=\"line\">    default_type  application/octet-stream; #上面找不到的话会用这个</span><br><span class=\"line\">    sendfile        on; #用来开启高效传输的模式</span><br><span class=\"line\">    keepalive_timeout  65; #http连接的超时时间</span><br><span class=\"line\"></span><br><span class=\"line\">    include /etc/nginx/conf.d/*.conf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>proxy.conf</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server&#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name  localhost;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        root   html;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server&#123;</span><br><span class=\"line\">    listen 8080;</span><br><span class=\"line\">    server_name  sjaylee;</span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        proxy_pass http://mysvr;</span><br><span class=\"line\">        root   html;</span><br><span class=\"line\">        index  index.html index.htm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>upstream.conf</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream.conf</span><br><span class=\"line\">upstream mysvr&#123;</span><br><span class=\"line\">    server 10.211.55.4:8081;</span><br><span class=\"line\">    server 10.211.55.4:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"location的匹配规则\"><a href=\"#location的匹配规则\" class=\"headerlink\" title=\"location的匹配规则\"></a>location的匹配规则</h2><p>基础语法有三种：</p>\n<ul>\n<li>location pattern {}    一般匹配</li>\n<li>location = pattern {}    精准匹配</li>\n<li>location ~pattern {}    正则匹配</li>\n</ul>\n<p><strong>nginx的负载均衡和负载均衡的调度算法</strong></p>\n<p>upstream：ip_hash、轮询(默认)、weight、fair、url_hash。</p>\n<p>ip_hash算法是对服务器的IP地址进行hash运算来获取对应代理服务器，好处是不需要考虑session跨域。</p>\n<p>weight算法是根据权重来合理分配各个代理服务器的调用比例。</p>\n<h2 id=\"nginx日志切分\"><a href=\"#nginx日志切分\" class=\"headerlink\" title=\"nginx日志切分\"></a>nginx日志切分</h2><p>第一步：分析如何去实现日志切分，编写shell脚本，记得要给脚本赋予可执行权限。</p>\n<p>第二步：启动定时任务对脚本进行调度：crontab -e</p>\n<p>定时任务格式：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/1 * * * * sh /usr/<span class=\"built_in\">local</span>/webserver/nginx/logs/access.log</span><br></pre></td></tr></table></figure>\n\n<p>第三步：新增split_log.sh文件，并给其增加权限，chmod 777 文件名</p>\n<p><strong>split_log.sh</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1garbdepmokj30ik0mm4ev.jpg\" alt></p>"},{"title":"volatile关键字解析","date":"2019-03-15T14:56:30.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## volatile的两大特性\n\n1. 保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。（先行发生原则）\n2. 阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。\n\n## Java内存模型JMM\n\nJava内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。<!-- More -->\n\n由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。\n\n### 主内存（Main Memory）\n\n主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。\n\n### 工作内存（Working Memory）\n\n工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。\n\n### 为什么所有的线程不直接操作主内存？\n\n直接操作主内存太慢了，工作内存类似于高速缓存，访问速度更快。\n\n## volatile的出现\n\n多线程的情况下，由于工作内存所更新的变量不会立即同步到主内存，为了防止产生错误的结果，可以使用同步锁来保证线程安全，但是对程序的性能影响太大，所以产生了volatile。\n\n### volatile的可见性\n\n当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。为什么volatile关键字可以有这样的特性？这得益于java语言的**先行发生原则**（happens-before）。\n\n#### happens-before\n\n在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。\n\n这里所谓的事件，实际上就是各种指令操作，比如读操作、写操作、初始化操作、锁操作等等。先行发生原则作用于很多场景下，包括同步锁、线程启动、线程终止、volatile。\n\n#### volatile的适用范围\n\n1. **运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。**\n\n   ```java\n   public class VolatileTest{\n     public volatile static int count = 0;\n     public static void main(String[] args){\n       //开启10个线程\n       for(int i=0;i<10;i++){\n         new Thread(\n         \tnew Runnable(){\n             public void run(){\n               try{\n                 Thread.sleep(1);\n               }catch(InterruptedException e){\n                 e.printStackTrace();\n               }\n               //每个线程当中让count值自增100次\n               for(int j=0;j<100;j++){\n                 count++;\n               }\n             }\n           }\n         ).start();\n       }\n       try{\n         Thread.sleep(2000);\n       }catch(InterruptedException e){\n         e.printStackTrace();\n       }\n       System.out.print(\"count=\"+count);\n     }\n   }\n   ```\n\n   例子中的实际值要小于1000.\n\n2. **变量不需要与其他的状态变量共同参与不变约束。**\n\n   ```java\n   volatile static int start = 3;\n   volatile static int end = 6;\n   ```\n\n   线程A执行如下代码：\n\n   ```java\n   while (start < end){\n    //do something\n   }\n   ```\n\n   线程B执行如下代码：\n\n   ```java\n   start+=3;\n   end+=3;\n   ```\n\n   这种情况下，一旦在线程A的循环中执行了线程B，start有可能先更新成6，造成了一瞬间 start == end，从而跳出while循环的可能性。\n\n\n\n#### 什么是指令重排？\n\n指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。\n\n#### 指令重排的目的\n\n为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。\n\n### volatile的内存屏障\n\n#### 什么是内存屏障？\n\n内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。\n\n#### 内存屏障的 4 种类型\n\n**LoadLoad屏障**：\n\n抽象场景：Load1; LoadLoad; Load2\n\nLoad1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。\n\n**StoreStore屏障：**\n\n抽象场景：Store1; StoreStore; Store2\n\nStore1 和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见\n\n**LoadStore屏障：**\n\n抽象场景：Load1; LoadStore; Store2\n\n在Store2被写入前，保证Load1要读取的数据被读取完毕。\n\n**StoreLoad屏障：**\n\n抽象场景：Store1; StoreLoad; Load2\n\n在Load2读取操作执行前，保证Store1的写入对所有处理器可见。StoreLoad屏障的开销是四种屏障中最大的。\n\n#### volatile如何防止指令重排\n\n在一个变量被volatile修饰后，JVM会为我们做两件事：\n\n1. 在每个volatile写操作前插入**StoreStore**屏障，在写操作后插入**StoreLoad**屏障。\n2. 在每个volatile读操作前插入**LoadLoad**屏障，在读操作后插入**LoadStore**屏障。\n\n从而成功阻止了指令重排序。","source":"_posts/volatile.md","raw":"---\ntitle: volatile关键字解析\ndate: 2019-03-15 22:56:30\ncategories: Java\ntags: \n  - 高并发\n  - volatile\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## volatile的两大特性\n\n1. 保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。（先行发生原则）\n2. 阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。\n\n## Java内存模型JMM\n\nJava内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。<!-- More -->\n\n由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。\n\n### 主内存（Main Memory）\n\n主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。\n\n### 工作内存（Working Memory）\n\n工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。\n\n### 为什么所有的线程不直接操作主内存？\n\n直接操作主内存太慢了，工作内存类似于高速缓存，访问速度更快。\n\n## volatile的出现\n\n多线程的情况下，由于工作内存所更新的变量不会立即同步到主内存，为了防止产生错误的结果，可以使用同步锁来保证线程安全，但是对程序的性能影响太大，所以产生了volatile。\n\n### volatile的可见性\n\n当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。为什么volatile关键字可以有这样的特性？这得益于java语言的**先行发生原则**（happens-before）。\n\n#### happens-before\n\n在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。\n\n这里所谓的事件，实际上就是各种指令操作，比如读操作、写操作、初始化操作、锁操作等等。先行发生原则作用于很多场景下，包括同步锁、线程启动、线程终止、volatile。\n\n#### volatile的适用范围\n\n1. **运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。**\n\n   ```java\n   public class VolatileTest{\n     public volatile static int count = 0;\n     public static void main(String[] args){\n       //开启10个线程\n       for(int i=0;i<10;i++){\n         new Thread(\n         \tnew Runnable(){\n             public void run(){\n               try{\n                 Thread.sleep(1);\n               }catch(InterruptedException e){\n                 e.printStackTrace();\n               }\n               //每个线程当中让count值自增100次\n               for(int j=0;j<100;j++){\n                 count++;\n               }\n             }\n           }\n         ).start();\n       }\n       try{\n         Thread.sleep(2000);\n       }catch(InterruptedException e){\n         e.printStackTrace();\n       }\n       System.out.print(\"count=\"+count);\n     }\n   }\n   ```\n\n   例子中的实际值要小于1000.\n\n2. **变量不需要与其他的状态变量共同参与不变约束。**\n\n   ```java\n   volatile static int start = 3;\n   volatile static int end = 6;\n   ```\n\n   线程A执行如下代码：\n\n   ```java\n   while (start < end){\n    //do something\n   }\n   ```\n\n   线程B执行如下代码：\n\n   ```java\n   start+=3;\n   end+=3;\n   ```\n\n   这种情况下，一旦在线程A的循环中执行了线程B，start有可能先更新成6，造成了一瞬间 start == end，从而跳出while循环的可能性。\n\n\n\n#### 什么是指令重排？\n\n指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。\n\n#### 指令重排的目的\n\n为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。\n\n### volatile的内存屏障\n\n#### 什么是内存屏障？\n\n内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。\n\n#### 内存屏障的 4 种类型\n\n**LoadLoad屏障**：\n\n抽象场景：Load1; LoadLoad; Load2\n\nLoad1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。\n\n**StoreStore屏障：**\n\n抽象场景：Store1; StoreStore; Store2\n\nStore1 和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见\n\n**LoadStore屏障：**\n\n抽象场景：Load1; LoadStore; Store2\n\n在Store2被写入前，保证Load1要读取的数据被读取完毕。\n\n**StoreLoad屏障：**\n\n抽象场景：Store1; StoreLoad; Load2\n\n在Load2读取操作执行前，保证Store1的写入对所有处理器可见。StoreLoad屏障的开销是四种屏障中最大的。\n\n#### volatile如何防止指令重排\n\n在一个变量被volatile修饰后，JVM会为我们做两件事：\n\n1. 在每个volatile写操作前插入**StoreStore**屏障，在写操作后插入**StoreLoad**屏障。\n2. 在每个volatile读操作前插入**LoadLoad**屏障，在读操作后插入**LoadStore**屏障。\n\n从而成功阻止了指令重排序。","slug":"volatile","published":1,"updated":"2020-01-16T15:21:55.599Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bj0001ba6ybeva6hrl9","content":"<h2 id=\"volatile的两大特性\"><a href=\"#volatile的两大特性\" class=\"headerlink\" title=\"volatile的两大特性\"></a>volatile的两大特性</h2><ol>\n<li>保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。（先行发生原则）</li>\n<li>阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。</li>\n</ol>\n<h2 id=\"Java内存模型JMM\"><a href=\"#Java内存模型JMM\" class=\"headerlink\" title=\"Java内存模型JMM\"></a>Java内存模型JMM</h2><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。<a id=\"more\"></a></p>\n<p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p>\n<h3 id=\"主内存（Main-Memory）\"><a href=\"#主内存（Main-Memory）\" class=\"headerlink\" title=\"主内存（Main Memory）\"></a>主内存（Main Memory）</h3><p>主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。</p>\n<h3 id=\"工作内存（Working-Memory）\"><a href=\"#工作内存（Working-Memory）\" class=\"headerlink\" title=\"工作内存（Working Memory）\"></a>工作内存（Working Memory）</h3><p>工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。</p>\n<h3 id=\"为什么所有的线程不直接操作主内存？\"><a href=\"#为什么所有的线程不直接操作主内存？\" class=\"headerlink\" title=\"为什么所有的线程不直接操作主内存？\"></a>为什么所有的线程不直接操作主内存？</h3><p>直接操作主内存太慢了，工作内存类似于高速缓存，访问速度更快。</p>\n<h2 id=\"volatile的出现\"><a href=\"#volatile的出现\" class=\"headerlink\" title=\"volatile的出现\"></a>volatile的出现</h2><p>多线程的情况下，由于工作内存所更新的变量不会立即同步到主内存，为了防止产生错误的结果，可以使用同步锁来保证线程安全，但是对程序的性能影响太大，所以产生了volatile。</p>\n<h3 id=\"volatile的可见性\"><a href=\"#volatile的可见性\" class=\"headerlink\" title=\"volatile的可见性\"></a>volatile的可见性</h3><p>当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。为什么volatile关键字可以有这样的特性？这得益于java语言的<strong>先行发生原则</strong>（happens-before）。</p>\n<h4 id=\"happens-before\"><a href=\"#happens-before\" class=\"headerlink\" title=\"happens-before\"></a>happens-before</h4><p>在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。</p>\n<p>这里所谓的事件，实际上就是各种指令操作，比如读操作、写操作、初始化操作、锁操作等等。先行发生原则作用于很多场景下，包括同步锁、线程启动、线程终止、volatile。</p>\n<h4 id=\"volatile的适用范围\"><a href=\"#volatile的适用范围\" class=\"headerlink\" title=\"volatile的适用范围\"></a>volatile的适用范围</h4><ol>\n<li><p><strong>运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//开启10个线程</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Thread(</span><br><span class=\"line\">      \t<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">              Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span>(InterruptedException e)&#123;</span><br><span class=\"line\">              e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//每个线程当中让count值自增100次</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">100</span>;j++)&#123;</span><br><span class=\"line\">              count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(InterruptedException e)&#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"count=\"</span>+count);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例子中的实际值要小于1000.</p>\n</li>\n<li><p><strong>变量不需要与其他的状态变量共同参与不变约束。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> start = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> end = <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n\n<p>线程A执行如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (start &lt; end)&#123;</span><br><span class=\"line\"> <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线程B执行如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start+=<span class=\"number\">3</span>;</span><br><span class=\"line\">end+=<span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，一旦在线程A的循环中执行了线程B，start有可能先更新成6，造成了一瞬间 start == end，从而跳出while循环的可能性。</p>\n</li>\n</ol>\n<h4 id=\"什么是指令重排？\"><a href=\"#什么是指令重排？\" class=\"headerlink\" title=\"什么是指令重排？\"></a>什么是指令重排？</h4><p>指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。</p>\n<h4 id=\"指令重排的目的\"><a href=\"#指令重排的目的\" class=\"headerlink\" title=\"指令重排的目的\"></a>指令重排的目的</h4><p>为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。</p>\n<h3 id=\"volatile的内存屏障\"><a href=\"#volatile的内存屏障\" class=\"headerlink\" title=\"volatile的内存屏障\"></a>volatile的内存屏障</h3><h4 id=\"什么是内存屏障？\"><a href=\"#什么是内存屏障？\" class=\"headerlink\" title=\"什么是内存屏障？\"></a>什么是内存屏障？</h4><p>内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。</p>\n<h4 id=\"内存屏障的-4-种类型\"><a href=\"#内存屏障的-4-种类型\" class=\"headerlink\" title=\"内存屏障的 4 种类型\"></a>内存屏障的 4 种类型</h4><p><strong>LoadLoad屏障</strong>：</p>\n<p>抽象场景：Load1; LoadLoad; Load2</p>\n<p>Load1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>\n<p><strong>StoreStore屏障：</strong></p>\n<p>抽象场景：Store1; StoreStore; Store2</p>\n<p>Store1 和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见</p>\n<p><strong>LoadStore屏障：</strong></p>\n<p>抽象场景：Load1; LoadStore; Store2</p>\n<p>在Store2被写入前，保证Load1要读取的数据被读取完毕。</p>\n<p><strong>StoreLoad屏障：</strong></p>\n<p>抽象场景：Store1; StoreLoad; Load2</p>\n<p>在Load2读取操作执行前，保证Store1的写入对所有处理器可见。StoreLoad屏障的开销是四种屏障中最大的。</p>\n<h4 id=\"volatile如何防止指令重排\"><a href=\"#volatile如何防止指令重排\" class=\"headerlink\" title=\"volatile如何防止指令重排\"></a>volatile如何防止指令重排</h4><p>在一个变量被volatile修饰后，JVM会为我们做两件事：</p>\n<ol>\n<li>在每个volatile写操作前插入<strong>StoreStore</strong>屏障，在写操作后插入<strong>StoreLoad</strong>屏障。</li>\n<li>在每个volatile读操作前插入<strong>LoadLoad</strong>屏障，在读操作后插入<strong>LoadStore</strong>屏障。</li>\n</ol>\n<p>从而成功阻止了指令重排序。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"volatile的两大特性\"><a href=\"#volatile的两大特性\" class=\"headerlink\" title=\"volatile的两大特性\"></a>volatile的两大特性</h2><ol>\n<li>保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。（先行发生原则）</li>\n<li>阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。</li>\n</ol>\n<h2 id=\"Java内存模型JMM\"><a href=\"#Java内存模型JMM\" class=\"headerlink\" title=\"Java内存模型JMM\"></a>Java内存模型JMM</h2><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。","more":"</p>\n<p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p>\n<h3 id=\"主内存（Main-Memory）\"><a href=\"#主内存（Main-Memory）\" class=\"headerlink\" title=\"主内存（Main Memory）\"></a>主内存（Main Memory）</h3><p>主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。</p>\n<h3 id=\"工作内存（Working-Memory）\"><a href=\"#工作内存（Working-Memory）\" class=\"headerlink\" title=\"工作内存（Working Memory）\"></a>工作内存（Working Memory）</h3><p>工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。</p>\n<h3 id=\"为什么所有的线程不直接操作主内存？\"><a href=\"#为什么所有的线程不直接操作主内存？\" class=\"headerlink\" title=\"为什么所有的线程不直接操作主内存？\"></a>为什么所有的线程不直接操作主内存？</h3><p>直接操作主内存太慢了，工作内存类似于高速缓存，访问速度更快。</p>\n<h2 id=\"volatile的出现\"><a href=\"#volatile的出现\" class=\"headerlink\" title=\"volatile的出现\"></a>volatile的出现</h2><p>多线程的情况下，由于工作内存所更新的变量不会立即同步到主内存，为了防止产生错误的结果，可以使用同步锁来保证线程安全，但是对程序的性能影响太大，所以产生了volatile。</p>\n<h3 id=\"volatile的可见性\"><a href=\"#volatile的可见性\" class=\"headerlink\" title=\"volatile的可见性\"></a>volatile的可见性</h3><p>当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。为什么volatile关键字可以有这样的特性？这得益于java语言的<strong>先行发生原则</strong>（happens-before）。</p>\n<h4 id=\"happens-before\"><a href=\"#happens-before\" class=\"headerlink\" title=\"happens-before\"></a>happens-before</h4><p>在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。</p>\n<p>这里所谓的事件，实际上就是各种指令操作，比如读操作、写操作、初始化操作、锁操作等等。先行发生原则作用于很多场景下，包括同步锁、线程启动、线程终止、volatile。</p>\n<h4 id=\"volatile的适用范围\"><a href=\"#volatile的适用范围\" class=\"headerlink\" title=\"volatile的适用范围\"></a>volatile的适用范围</h4><ol>\n<li><p><strong>运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VolatileTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//开启10个线程</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">new</span> Thread(</span><br><span class=\"line\">      \t<span class=\"keyword\">new</span> Runnable()&#123;</span><br><span class=\"line\">          <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">              Thread.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">catch</span>(InterruptedException e)&#123;</span><br><span class=\"line\">              e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//每个线程当中让count值自增100次</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;<span class=\"number\">100</span>;j++)&#123;</span><br><span class=\"line\">              count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">      Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">catch</span>(InterruptedException e)&#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.print(<span class=\"string\">\"count=\"</span>+count);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>例子中的实际值要小于1000.</p>\n</li>\n<li><p><strong>变量不需要与其他的状态变量共同参与不变约束。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> start = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> end = <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n\n<p>线程A执行如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (start &lt; end)&#123;</span><br><span class=\"line\"> <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>线程B执行如下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start+=<span class=\"number\">3</span>;</span><br><span class=\"line\">end+=<span class=\"number\">3</span>;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况下，一旦在线程A的循环中执行了线程B，start有可能先更新成6，造成了一瞬间 start == end，从而跳出while循环的可能性。</p>\n</li>\n</ol>\n<h4 id=\"什么是指令重排？\"><a href=\"#什么是指令重排？\" class=\"headerlink\" title=\"什么是指令重排？\"></a>什么是指令重排？</h4><p>指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。</p>\n<h4 id=\"指令重排的目的\"><a href=\"#指令重排的目的\" class=\"headerlink\" title=\"指令重排的目的\"></a>指令重排的目的</h4><p>为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。</p>\n<h3 id=\"volatile的内存屏障\"><a href=\"#volatile的内存屏障\" class=\"headerlink\" title=\"volatile的内存屏障\"></a>volatile的内存屏障</h3><h4 id=\"什么是内存屏障？\"><a href=\"#什么是内存屏障？\" class=\"headerlink\" title=\"什么是内存屏障？\"></a>什么是内存屏障？</h4><p>内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。</p>\n<h4 id=\"内存屏障的-4-种类型\"><a href=\"#内存屏障的-4-种类型\" class=\"headerlink\" title=\"内存屏障的 4 种类型\"></a>内存屏障的 4 种类型</h4><p><strong>LoadLoad屏障</strong>：</p>\n<p>抽象场景：Load1; LoadLoad; Load2</p>\n<p>Load1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p>\n<p><strong>StoreStore屏障：</strong></p>\n<p>抽象场景：Store1; StoreStore; Store2</p>\n<p>Store1 和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见</p>\n<p><strong>LoadStore屏障：</strong></p>\n<p>抽象场景：Load1; LoadStore; Store2</p>\n<p>在Store2被写入前，保证Load1要读取的数据被读取完毕。</p>\n<p><strong>StoreLoad屏障：</strong></p>\n<p>抽象场景：Store1; StoreLoad; Load2</p>\n<p>在Load2读取操作执行前，保证Store1的写入对所有处理器可见。StoreLoad屏障的开销是四种屏障中最大的。</p>\n<h4 id=\"volatile如何防止指令重排\"><a href=\"#volatile如何防止指令重排\" class=\"headerlink\" title=\"volatile如何防止指令重排\"></a>volatile如何防止指令重排</h4><p>在一个变量被volatile修饰后，JVM会为我们做两件事：</p>\n<ol>\n<li>在每个volatile写操作前插入<strong>StoreStore</strong>屏障，在写操作后插入<strong>StoreLoad</strong>屏障。</li>\n<li>在每个volatile读操作前插入<strong>LoadLoad</strong>屏障，在读操作后插入<strong>LoadStore</strong>屏障。</li>\n</ol>\n<p>从而成功阻止了指令重排序。</p>"},{"title":"消息队列-MQ","date":"2019-03-19T15:28:33.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## 为什么使用消息队列？说说优缺点？\n\n我们公司有个什么业务场景，这个场景有个什么技术挑战，如果不用MQ会很麻烦，用了MQ之后带来了很多好处。\n\n比较核心的使用场景有3个：**解耦、异步、削峰**。同样也是使用MQ的**优点**。\n\n**解耦举例**：A系统产生了一条比较重要的数据，B、C、D系统都需要，如果不使用MQ的话，A系统要做很多事情，比如需要分别调用B、C、D系统的接口传递数据，还要考虑接口的参数，可用性等等， 如果有新系统加入的话，还要更改很麻烦。如果使用MQ的话，A系统把产生的数据直接发送到MQ就不用管了，谁需要这条消息自己去MQ里获取，如果某个系统不需要这些消息了就不用去消费数据了，这样A系统就不需要考虑其他系统是否调用成功，接口是否超时，失败重试等等，所有操作就变得很简单。\n\n总结：通过一个MQ的发布/订阅模型（Pub/Sub）系统A就跟其他系统解耦了。<!--more-->\n\n**异步举例**：A系统发起一次请求，假设A系统本地处理SQL并发送需要20ms，然后分别调用B、C、D系统，分别耗时300ms，450ms，200ms，如果是同步调用的话，总耗时就是这几次调用的和，用户的内心是崩溃的。如果使用MQ的话，系统A可以连续发送3条消息到3个MQ队列中，耗时5ms，系统B、C、D自己从对应的消息队列中获取，需要耗时操作在各自系统执行。因为是异步调用，A系统不需要等待反馈，发送成功后直接给用户反馈的时间就是20ms+5ms=25ms，用户爽歪歪。\n\n总结：系统间非常耗时的调用，可以使用MQ异步化来做性能优化。异步化可以大幅度提升高延时接口的性能。\n\n**削峰举例**：大量用户（几百万）通过浏览器同时在某一时刻进行操作，这时就会有大量的请求涌入，如果超过数据库瓶颈就会把数据库打死，高峰期过后请求会大量减少，这时可以考虑采用MQ做削峰处理。大量的请求直接发送到MQ，各个系统根据自己的处理能力去MQ拉取消息，延时处理MQ积压的请求，达到削峰的效果。\n\n总结：削峰可以缓解数据库压力，达到最终一致性。\n\n**缺点**：\n\n- 系统的可用性降低，系统引入的外部依赖越多，越容易挂掉。MQ发生故障，可能使系统崩溃。\n- 系统的复杂性提高，还需要考虑重复消费，消息丢失，消息传递顺序性等等一系列问题。\n- 一致性问题，A系统把请求发送到MQ返回成功了，但是B、C、D消费消息有失败的，如何解决。\n\n------\n\n## 不同消息中间件的区别以及适用场景？\n\n- 单机吞吐量：activemq和rabbitmq吞吐量是万级，rocketmq和kafka都是10万级。\n- 时效性：影响不大，activemq、rocketmq、kafka都在毫秒级，rabbitmq在微秒级。\n- 可用性：都可以保证，activemq和rabbitmq都是基于主从架构，后两者基于分布式架构。\n\n优劣势总结\n\n- activemq非常成熟，功能强大，在业内有广泛应用，不过偶尔会有较低概率丢失消息，还有就是开源社区越来越不活跃，维护次数也越来越少，activemq5.x主要是基于解耦和异步来使用的，较少在大规模吞吐量的场景哦中使用。\n- rabbitmq并发能力很强，性能极好，延迟很低，特别适合国内中小型公司，提供非常友好的后台管理界面，开源社区相对来说比较活跃。不过确实吞吐量低一些，而且rabbitmq集群动态扩展很麻烦，erlang开发的，很难读懂源码。\n- rocketmq的吞吐量很大，阿里开源的采用分布式架构设计的，扩展方便而且可用性很高，经过参数优化配置可以做到消息0丢失，可以支撑大规模吞吐量、业务复杂的场景，社区很活跃，源码是Java的。缺点是如果阿里抛弃这个技术，社区很可能黄掉，需要自己维护。\n- kafka也是可以做到大规模吞吐，分布式架构可用性很高，任意扩展，消息0丢失，功能较为简单，在大数据领域的实时计算以及日志采集被大规模使用。kafka唯一的缺点就是可能消息重复消费。\n\n综上所述：现在越来越多的公司去使用RocketMQ，大型公司并且对自己公司实力有自信的，推荐使用。对于技术实力较为一般、技术挑战不是很高的中小型公司推荐RabbitMQ，如果是大数据领域的实时计算，日志采集等场景，kafka是业内标准，肯定不会黄。\n\n------\n\n## RabbitMQ如何保证消息队列的高可用？\n\nRabbitMQ是比较有代表性的，因为是基于**主从架构**实现的的高可用。\n\nRabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式。\n\n1. 单机模式\n\n   就是demo级别的，一般就是自己玩玩，没有生产环境使用单机模式的。\n\n2. 普通集群模式（不是高可用的）\n\n   意思就是分别在多台机器上启动多个rabbitmq实例，每个机器启动一个，但是你创建的queue只会把元数据和实际数据放在一个rabbitmq实例上，每个实例都去同步queue的元数据。等到你消费的时候，如果你连接到另外一个实例，那么该实例就会从queue所在的实例上拉取实际数据过来。\n\n   该模式有两个缺点：\n\n   ​\t如果每次随机连接一个实例，可能会在rabbitmq集群内部产生大量的数据传输，造成大量的数据开销；\n\n   ​\t如果每次都连接queue的实例，那么也就没有什么性能可言，queue宕机后就不能使用了。\n\n3. 镜像集群模式（是高可用的）\n\n   这种模式才是真正的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论是元数据还是queue里的消息都会存在于多个实例上，每次写入消息到queue的时候，都会自动把消息同步到多个实例。\n\n   这样的话好处在于你的任何一个机器宕机了，其他机器都还可以使用。坏处在于开销太大，消息同步所有机器，导致网络带宽压力和消耗都很严重。其次是没有扩展性，如果queue的数据量很大，负载很严重，增加机器也会包含queue的所有数据，并没有办法扩展queue。\n\n   **怎么开启这个镜像集群模式呢？**\n\n   rabbitmq有很好的管理控制台，在后台新增一个镜像集群模式的策略，指定同步节点的时候要求数据同步到所有节点，再次创建queue的时候，应用这个策略就会自动将数据同步到其他的节点上。\n\n------\n\n## 如何保证消息不被重复消费？(幂等性)\n\n什么是幂等性，同一条数据重复出现了多次，数据库里只保存一条数据，这就是保证了系统的幂等性。\n\n**如何保证幂等性，需要结合具体的业务场景来思考，先来几个思路：**\n\n1. 比如获取到消息准备写入数据库，先根据主键查一下有没有消费过，如果消费过可以选择不处理或者更新。\n2. 比如是要写入Redis，就不用考虑了，Redis每次都是set，天然幂等性。\n3. 还可以让生产者发送数据时，增加一个全局唯一的ID，维护一张消费记录表，消费数据前，先去消息记录表中查询有没有消费过，如果没有消费就处理，消费过了就不要处理了。\n\n------\n\n## 如何保证消息的可靠性传输，不丢消息？\n\n**消息丢失的3种情况：**\n\n1. **生产者**写入消息的过程中，消息没到rabbitmq，在网络传输过程中丢失了；\n2. **rabbitmq**接受到了消息并暂存入内存，消费者还没来得及消费，rabbitmq自己挂掉了；\n3. **消费者**消费到了这个消息，但是还没来得及处理，自己就挂掉了，rabbitmq以为处理完了。\n\n情况1**（生产者弄丢了数据）**的解决方案：\n\n**rabbitmq的事务机制**：生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，就可以提交事务（channel.txCommit）。但是rabbitmq事务一搞，同步机制太耗性能，基本上吞吐量会下来。\n\n**confirm机制**：在生产者那里设置开启confirm模式后，每次写的消息都会分配一个唯一的ID，如果成功写入了rabbitmq中，rabbitmq会回调生产者ack接口，说明这个消息成功写入了。如果rabbitmq没能处理这个消息，会回调一个nack接口，说明这个消息接收失败，需要重发。而且还可以在内存里维护每个消息ID的状态，如果超过一定时间还没有接受到这个消息的回调，也可以重发。\n\n事务机制和confirm机制最大的不同在于，事务机制是同步的，提交一个事务以后会阻塞在那，但是confirm机制是异步的，发送消息以后可以再发送下一个消息，rabbitmq接收到以后会异步回调生产者接口告知。\n\n情况2**（rabbitmq弄丢了数据）**的解决方案：\n\n**开启rabbitmq持久化**：意思就是写入消息到rabbitmq后会把消息持久化到磁盘，这样就算rabbitmq自己挂了，恢复之后也会自动读取之前存储的数据，一般数据不会丢。也有可能rabbitmq还没持久化就挂了，导致数据丢失，不过这种情况概率较小。\n\n设置持久化有两个步骤，第一个步骤是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的消息；第二个步骤是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化。此时rabbitmq就会将消息持久化到磁盘了，**注意：必须同时设置这两个才可以**。\n\n这个持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会回调生产者的ack接口，所以即使是持久化到磁盘之前rabbitmq挂了，生产者收不到回调，也是会重发的。\n\n情况3**（消费者弄丢了数据）**的解决方案：\n\n消费者有autoAck机制，就是消费数据之后，消费者会自动通知rabbitmq消费成功了。但是如果消费的消息还在处理中，还没处理完，消费者宕机了，还是会造成消息丢失。所以这里我们需要关闭autoAck机制，然后等待消费者完全处理完消息后，再手动发送ack给rabbitmq，此时就不会丢失消息了。\n\n------\n\n## 如何保证消息的顺序性？\n\n先看看造成消息错乱的场景\n\n如果rabbitmq的一个queue对应多个consumer，肯定会发生错乱。\n\n解决方案：\n\n拆分多个queue，使每个queue对应一个consumer，这样就可以保证消费的顺序性了；\n\n一个queue只对应一个consumer，让consumer内部用内存队列排队，然后分发给底层不同的worker来处理。\n\n------\n\n如何解决消息队列的延迟以及过期失效的问题？消息队列满了以后怎么处理？有几百万条消息持续积压几小时，说说怎么解决？\n\n一般这个时候，只能操作临时紧急扩容了，具体操作步骤如下：\n\n1. 先修复consumer的问题，确保其恢复正常的消费速度，然后将现有的consumer都停掉。\n2. 临时建立好原先10倍或者20倍的queue数量。\n3. 然后写一个临时分发数据的consumer程序，把这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮训写入临时建立好的10倍数量的queue。\n4. 接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。\n5. 这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消耗数据。\n6. 等快速消费完积压的数据之后，得恢复原来部署的架构，重新用原先的consumer机器来消费消息。\n\n假设使用的是rabbitmq，设置了过期时间，过量积压最终导致大量数据过期后丢失，这种情况只能是批量重导。到了晚上高峰期过后，查询出来丢失的数据，重新灌入到mq中，把丢失的数据补回来。\n\n如果是因为积压太久导致mq快写满了，只能临时修改程序，快速消费掉所有消息，然后晚上再补数据。\n\n------\n\n## 如果让你写消息队列，如何架构设计？\n\n**下面说一下设计思路**\n\n1. 首先设计的mq得支持可伸缩，就是需要的时候快速扩容，就可以增加容量和吞吐量。所以需要设计一个分布式系统，参照kafka的设计理念，broker -> topic -> partition，每个partition放一个机器，就存一部分数据。如果资源不够了，可以直接给topic增加partition，然后做数据迁移。\n2. 其次设计的mq需要把数据落地到磁盘，防止数据丢失。根据Kafka的设计思路，顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的。\n3. 还要考虑一下mq的可用性。具体参照Kafka的高可用环节，多副本 -> leader & follower -> broker 挂了重新选举leader即可对外服务。","source":"_posts/MQ.md","raw":"---\ntitle: 消息队列-MQ\ndate: 2019-03-19 23:28:33\ncategories: Java\ntags:\n  - 分布式\n  - 消息队列\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## 为什么使用消息队列？说说优缺点？\n\n我们公司有个什么业务场景，这个场景有个什么技术挑战，如果不用MQ会很麻烦，用了MQ之后带来了很多好处。\n\n比较核心的使用场景有3个：**解耦、异步、削峰**。同样也是使用MQ的**优点**。\n\n**解耦举例**：A系统产生了一条比较重要的数据，B、C、D系统都需要，如果不使用MQ的话，A系统要做很多事情，比如需要分别调用B、C、D系统的接口传递数据，还要考虑接口的参数，可用性等等， 如果有新系统加入的话，还要更改很麻烦。如果使用MQ的话，A系统把产生的数据直接发送到MQ就不用管了，谁需要这条消息自己去MQ里获取，如果某个系统不需要这些消息了就不用去消费数据了，这样A系统就不需要考虑其他系统是否调用成功，接口是否超时，失败重试等等，所有操作就变得很简单。\n\n总结：通过一个MQ的发布/订阅模型（Pub/Sub）系统A就跟其他系统解耦了。<!--more-->\n\n**异步举例**：A系统发起一次请求，假设A系统本地处理SQL并发送需要20ms，然后分别调用B、C、D系统，分别耗时300ms，450ms，200ms，如果是同步调用的话，总耗时就是这几次调用的和，用户的内心是崩溃的。如果使用MQ的话，系统A可以连续发送3条消息到3个MQ队列中，耗时5ms，系统B、C、D自己从对应的消息队列中获取，需要耗时操作在各自系统执行。因为是异步调用，A系统不需要等待反馈，发送成功后直接给用户反馈的时间就是20ms+5ms=25ms，用户爽歪歪。\n\n总结：系统间非常耗时的调用，可以使用MQ异步化来做性能优化。异步化可以大幅度提升高延时接口的性能。\n\n**削峰举例**：大量用户（几百万）通过浏览器同时在某一时刻进行操作，这时就会有大量的请求涌入，如果超过数据库瓶颈就会把数据库打死，高峰期过后请求会大量减少，这时可以考虑采用MQ做削峰处理。大量的请求直接发送到MQ，各个系统根据自己的处理能力去MQ拉取消息，延时处理MQ积压的请求，达到削峰的效果。\n\n总结：削峰可以缓解数据库压力，达到最终一致性。\n\n**缺点**：\n\n- 系统的可用性降低，系统引入的外部依赖越多，越容易挂掉。MQ发生故障，可能使系统崩溃。\n- 系统的复杂性提高，还需要考虑重复消费，消息丢失，消息传递顺序性等等一系列问题。\n- 一致性问题，A系统把请求发送到MQ返回成功了，但是B、C、D消费消息有失败的，如何解决。\n\n------\n\n## 不同消息中间件的区别以及适用场景？\n\n- 单机吞吐量：activemq和rabbitmq吞吐量是万级，rocketmq和kafka都是10万级。\n- 时效性：影响不大，activemq、rocketmq、kafka都在毫秒级，rabbitmq在微秒级。\n- 可用性：都可以保证，activemq和rabbitmq都是基于主从架构，后两者基于分布式架构。\n\n优劣势总结\n\n- activemq非常成熟，功能强大，在业内有广泛应用，不过偶尔会有较低概率丢失消息，还有就是开源社区越来越不活跃，维护次数也越来越少，activemq5.x主要是基于解耦和异步来使用的，较少在大规模吞吐量的场景哦中使用。\n- rabbitmq并发能力很强，性能极好，延迟很低，特别适合国内中小型公司，提供非常友好的后台管理界面，开源社区相对来说比较活跃。不过确实吞吐量低一些，而且rabbitmq集群动态扩展很麻烦，erlang开发的，很难读懂源码。\n- rocketmq的吞吐量很大，阿里开源的采用分布式架构设计的，扩展方便而且可用性很高，经过参数优化配置可以做到消息0丢失，可以支撑大规模吞吐量、业务复杂的场景，社区很活跃，源码是Java的。缺点是如果阿里抛弃这个技术，社区很可能黄掉，需要自己维护。\n- kafka也是可以做到大规模吞吐，分布式架构可用性很高，任意扩展，消息0丢失，功能较为简单，在大数据领域的实时计算以及日志采集被大规模使用。kafka唯一的缺点就是可能消息重复消费。\n\n综上所述：现在越来越多的公司去使用RocketMQ，大型公司并且对自己公司实力有自信的，推荐使用。对于技术实力较为一般、技术挑战不是很高的中小型公司推荐RabbitMQ，如果是大数据领域的实时计算，日志采集等场景，kafka是业内标准，肯定不会黄。\n\n------\n\n## RabbitMQ如何保证消息队列的高可用？\n\nRabbitMQ是比较有代表性的，因为是基于**主从架构**实现的的高可用。\n\nRabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式。\n\n1. 单机模式\n\n   就是demo级别的，一般就是自己玩玩，没有生产环境使用单机模式的。\n\n2. 普通集群模式（不是高可用的）\n\n   意思就是分别在多台机器上启动多个rabbitmq实例，每个机器启动一个，但是你创建的queue只会把元数据和实际数据放在一个rabbitmq实例上，每个实例都去同步queue的元数据。等到你消费的时候，如果你连接到另外一个实例，那么该实例就会从queue所在的实例上拉取实际数据过来。\n\n   该模式有两个缺点：\n\n   ​\t如果每次随机连接一个实例，可能会在rabbitmq集群内部产生大量的数据传输，造成大量的数据开销；\n\n   ​\t如果每次都连接queue的实例，那么也就没有什么性能可言，queue宕机后就不能使用了。\n\n3. 镜像集群模式（是高可用的）\n\n   这种模式才是真正的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论是元数据还是queue里的消息都会存在于多个实例上，每次写入消息到queue的时候，都会自动把消息同步到多个实例。\n\n   这样的话好处在于你的任何一个机器宕机了，其他机器都还可以使用。坏处在于开销太大，消息同步所有机器，导致网络带宽压力和消耗都很严重。其次是没有扩展性，如果queue的数据量很大，负载很严重，增加机器也会包含queue的所有数据，并没有办法扩展queue。\n\n   **怎么开启这个镜像集群模式呢？**\n\n   rabbitmq有很好的管理控制台，在后台新增一个镜像集群模式的策略，指定同步节点的时候要求数据同步到所有节点，再次创建queue的时候，应用这个策略就会自动将数据同步到其他的节点上。\n\n------\n\n## 如何保证消息不被重复消费？(幂等性)\n\n什么是幂等性，同一条数据重复出现了多次，数据库里只保存一条数据，这就是保证了系统的幂等性。\n\n**如何保证幂等性，需要结合具体的业务场景来思考，先来几个思路：**\n\n1. 比如获取到消息准备写入数据库，先根据主键查一下有没有消费过，如果消费过可以选择不处理或者更新。\n2. 比如是要写入Redis，就不用考虑了，Redis每次都是set，天然幂等性。\n3. 还可以让生产者发送数据时，增加一个全局唯一的ID，维护一张消费记录表，消费数据前，先去消息记录表中查询有没有消费过，如果没有消费就处理，消费过了就不要处理了。\n\n------\n\n## 如何保证消息的可靠性传输，不丢消息？\n\n**消息丢失的3种情况：**\n\n1. **生产者**写入消息的过程中，消息没到rabbitmq，在网络传输过程中丢失了；\n2. **rabbitmq**接受到了消息并暂存入内存，消费者还没来得及消费，rabbitmq自己挂掉了；\n3. **消费者**消费到了这个消息，但是还没来得及处理，自己就挂掉了，rabbitmq以为处理完了。\n\n情况1**（生产者弄丢了数据）**的解决方案：\n\n**rabbitmq的事务机制**：生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，就可以提交事务（channel.txCommit）。但是rabbitmq事务一搞，同步机制太耗性能，基本上吞吐量会下来。\n\n**confirm机制**：在生产者那里设置开启confirm模式后，每次写的消息都会分配一个唯一的ID，如果成功写入了rabbitmq中，rabbitmq会回调生产者ack接口，说明这个消息成功写入了。如果rabbitmq没能处理这个消息，会回调一个nack接口，说明这个消息接收失败，需要重发。而且还可以在内存里维护每个消息ID的状态，如果超过一定时间还没有接受到这个消息的回调，也可以重发。\n\n事务机制和confirm机制最大的不同在于，事务机制是同步的，提交一个事务以后会阻塞在那，但是confirm机制是异步的，发送消息以后可以再发送下一个消息，rabbitmq接收到以后会异步回调生产者接口告知。\n\n情况2**（rabbitmq弄丢了数据）**的解决方案：\n\n**开启rabbitmq持久化**：意思就是写入消息到rabbitmq后会把消息持久化到磁盘，这样就算rabbitmq自己挂了，恢复之后也会自动读取之前存储的数据，一般数据不会丢。也有可能rabbitmq还没持久化就挂了，导致数据丢失，不过这种情况概率较小。\n\n设置持久化有两个步骤，第一个步骤是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的消息；第二个步骤是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化。此时rabbitmq就会将消息持久化到磁盘了，**注意：必须同时设置这两个才可以**。\n\n这个持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会回调生产者的ack接口，所以即使是持久化到磁盘之前rabbitmq挂了，生产者收不到回调，也是会重发的。\n\n情况3**（消费者弄丢了数据）**的解决方案：\n\n消费者有autoAck机制，就是消费数据之后，消费者会自动通知rabbitmq消费成功了。但是如果消费的消息还在处理中，还没处理完，消费者宕机了，还是会造成消息丢失。所以这里我们需要关闭autoAck机制，然后等待消费者完全处理完消息后，再手动发送ack给rabbitmq，此时就不会丢失消息了。\n\n------\n\n## 如何保证消息的顺序性？\n\n先看看造成消息错乱的场景\n\n如果rabbitmq的一个queue对应多个consumer，肯定会发生错乱。\n\n解决方案：\n\n拆分多个queue，使每个queue对应一个consumer，这样就可以保证消费的顺序性了；\n\n一个queue只对应一个consumer，让consumer内部用内存队列排队，然后分发给底层不同的worker来处理。\n\n------\n\n如何解决消息队列的延迟以及过期失效的问题？消息队列满了以后怎么处理？有几百万条消息持续积压几小时，说说怎么解决？\n\n一般这个时候，只能操作临时紧急扩容了，具体操作步骤如下：\n\n1. 先修复consumer的问题，确保其恢复正常的消费速度，然后将现有的consumer都停掉。\n2. 临时建立好原先10倍或者20倍的queue数量。\n3. 然后写一个临时分发数据的consumer程序，把这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮训写入临时建立好的10倍数量的queue。\n4. 接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。\n5. 这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消耗数据。\n6. 等快速消费完积压的数据之后，得恢复原来部署的架构，重新用原先的consumer机器来消费消息。\n\n假设使用的是rabbitmq，设置了过期时间，过量积压最终导致大量数据过期后丢失，这种情况只能是批量重导。到了晚上高峰期过后，查询出来丢失的数据，重新灌入到mq中，把丢失的数据补回来。\n\n如果是因为积压太久导致mq快写满了，只能临时修改程序，快速消费掉所有消息，然后晚上再补数据。\n\n------\n\n## 如果让你写消息队列，如何架构设计？\n\n**下面说一下设计思路**\n\n1. 首先设计的mq得支持可伸缩，就是需要的时候快速扩容，就可以增加容量和吞吐量。所以需要设计一个分布式系统，参照kafka的设计理念，broker -> topic -> partition，每个partition放一个机器，就存一部分数据。如果资源不够了，可以直接给topic增加partition，然后做数据迁移。\n2. 其次设计的mq需要把数据落地到磁盘，防止数据丢失。根据Kafka的设计思路，顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的。\n3. 还要考虑一下mq的可用性。具体参照Kafka的高可用环节，多副本 -> leader & follower -> broker 挂了重新选举leader即可对外服务。","slug":"MQ","published":1,"updated":"2020-02-14T16:33:42.630Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bjt003qa6ybhagsbxdb","content":"<h2 id=\"为什么使用消息队列？说说优缺点？\"><a href=\"#为什么使用消息队列？说说优缺点？\" class=\"headerlink\" title=\"为什么使用消息队列？说说优缺点？\"></a>为什么使用消息队列？说说优缺点？</h2><p>我们公司有个什么业务场景，这个场景有个什么技术挑战，如果不用MQ会很麻烦，用了MQ之后带来了很多好处。</p>\n<p>比较核心的使用场景有3个：<strong>解耦、异步、削峰</strong>。同样也是使用MQ的<strong>优点</strong>。</p>\n<p><strong>解耦举例</strong>：A系统产生了一条比较重要的数据，B、C、D系统都需要，如果不使用MQ的话，A系统要做很多事情，比如需要分别调用B、C、D系统的接口传递数据，还要考虑接口的参数，可用性等等， 如果有新系统加入的话，还要更改很麻烦。如果使用MQ的话，A系统把产生的数据直接发送到MQ就不用管了，谁需要这条消息自己去MQ里获取，如果某个系统不需要这些消息了就不用去消费数据了，这样A系统就不需要考虑其他系统是否调用成功，接口是否超时，失败重试等等，所有操作就变得很简单。</p>\n<p>总结：通过一个MQ的发布/订阅模型（Pub/Sub）系统A就跟其他系统解耦了。<a id=\"more\"></a></p>\n<p><strong>异步举例</strong>：A系统发起一次请求，假设A系统本地处理SQL并发送需要20ms，然后分别调用B、C、D系统，分别耗时300ms，450ms，200ms，如果是同步调用的话，总耗时就是这几次调用的和，用户的内心是崩溃的。如果使用MQ的话，系统A可以连续发送3条消息到3个MQ队列中，耗时5ms，系统B、C、D自己从对应的消息队列中获取，需要耗时操作在各自系统执行。因为是异步调用，A系统不需要等待反馈，发送成功后直接给用户反馈的时间就是20ms+5ms=25ms，用户爽歪歪。</p>\n<p>总结：系统间非常耗时的调用，可以使用MQ异步化来做性能优化。异步化可以大幅度提升高延时接口的性能。</p>\n<p><strong>削峰举例</strong>：大量用户（几百万）通过浏览器同时在某一时刻进行操作，这时就会有大量的请求涌入，如果超过数据库瓶颈就会把数据库打死，高峰期过后请求会大量减少，这时可以考虑采用MQ做削峰处理。大量的请求直接发送到MQ，各个系统根据自己的处理能力去MQ拉取消息，延时处理MQ积压的请求，达到削峰的效果。</p>\n<p>总结：削峰可以缓解数据库压力，达到最终一致性。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>系统的可用性降低，系统引入的外部依赖越多，越容易挂掉。MQ发生故障，可能使系统崩溃。</li>\n<li>系统的复杂性提高，还需要考虑重复消费，消息丢失，消息传递顺序性等等一系列问题。</li>\n<li>一致性问题，A系统把请求发送到MQ返回成功了，但是B、C、D消费消息有失败的，如何解决。</li>\n</ul>\n<hr>\n<h2 id=\"不同消息中间件的区别以及适用场景？\"><a href=\"#不同消息中间件的区别以及适用场景？\" class=\"headerlink\" title=\"不同消息中间件的区别以及适用场景？\"></a>不同消息中间件的区别以及适用场景？</h2><ul>\n<li>单机吞吐量：activemq和rabbitmq吞吐量是万级，rocketmq和kafka都是10万级。</li>\n<li>时效性：影响不大，activemq、rocketmq、kafka都在毫秒级，rabbitmq在微秒级。</li>\n<li>可用性：都可以保证，activemq和rabbitmq都是基于主从架构，后两者基于分布式架构。</li>\n</ul>\n<p>优劣势总结</p>\n<ul>\n<li>activemq非常成熟，功能强大，在业内有广泛应用，不过偶尔会有较低概率丢失消息，还有就是开源社区越来越不活跃，维护次数也越来越少，activemq5.x主要是基于解耦和异步来使用的，较少在大规模吞吐量的场景哦中使用。</li>\n<li>rabbitmq并发能力很强，性能极好，延迟很低，特别适合国内中小型公司，提供非常友好的后台管理界面，开源社区相对来说比较活跃。不过确实吞吐量低一些，而且rabbitmq集群动态扩展很麻烦，erlang开发的，很难读懂源码。</li>\n<li>rocketmq的吞吐量很大，阿里开源的采用分布式架构设计的，扩展方便而且可用性很高，经过参数优化配置可以做到消息0丢失，可以支撑大规模吞吐量、业务复杂的场景，社区很活跃，源码是Java的。缺点是如果阿里抛弃这个技术，社区很可能黄掉，需要自己维护。</li>\n<li>kafka也是可以做到大规模吞吐，分布式架构可用性很高，任意扩展，消息0丢失，功能较为简单，在大数据领域的实时计算以及日志采集被大规模使用。kafka唯一的缺点就是可能消息重复消费。</li>\n</ul>\n<p>综上所述：现在越来越多的公司去使用RocketMQ，大型公司并且对自己公司实力有自信的，推荐使用。对于技术实力较为一般、技术挑战不是很高的中小型公司推荐RabbitMQ，如果是大数据领域的实时计算，日志采集等场景，kafka是业内标准，肯定不会黄。</p>\n<hr>\n<h2 id=\"RabbitMQ如何保证消息队列的高可用？\"><a href=\"#RabbitMQ如何保证消息队列的高可用？\" class=\"headerlink\" title=\"RabbitMQ如何保证消息队列的高可用？\"></a>RabbitMQ如何保证消息队列的高可用？</h2><p>RabbitMQ是比较有代表性的，因为是基于<strong>主从架构</strong>实现的的高可用。</p>\n<p>RabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式。</p>\n<ol>\n<li><p>单机模式</p>\n<p>就是demo级别的，一般就是自己玩玩，没有生产环境使用单机模式的。</p>\n</li>\n<li><p>普通集群模式（不是高可用的）</p>\n<p>意思就是分别在多台机器上启动多个rabbitmq实例，每个机器启动一个，但是你创建的queue只会把元数据和实际数据放在一个rabbitmq实例上，每个实例都去同步queue的元数据。等到你消费的时候，如果你连接到另外一个实例，那么该实例就会从queue所在的实例上拉取实际数据过来。</p>\n<p>该模式有两个缺点：</p>\n<p>​    如果每次随机连接一个实例，可能会在rabbitmq集群内部产生大量的数据传输，造成大量的数据开销；</p>\n<p>​    如果每次都连接queue的实例，那么也就没有什么性能可言，queue宕机后就不能使用了。</p>\n</li>\n<li><p>镜像集群模式（是高可用的）</p>\n<p>这种模式才是真正的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论是元数据还是queue里的消息都会存在于多个实例上，每次写入消息到queue的时候，都会自动把消息同步到多个实例。</p>\n<p>这样的话好处在于你的任何一个机器宕机了，其他机器都还可以使用。坏处在于开销太大，消息同步所有机器，导致网络带宽压力和消耗都很严重。其次是没有扩展性，如果queue的数据量很大，负载很严重，增加机器也会包含queue的所有数据，并没有办法扩展queue。</p>\n<p><strong>怎么开启这个镜像集群模式呢？</strong></p>\n<p>rabbitmq有很好的管理控制台，在后台新增一个镜像集群模式的策略，指定同步节点的时候要求数据同步到所有节点，再次创建queue的时候，应用这个策略就会自动将数据同步到其他的节点上。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"如何保证消息不被重复消费？-幂等性\"><a href=\"#如何保证消息不被重复消费？-幂等性\" class=\"headerlink\" title=\"如何保证消息不被重复消费？(幂等性)\"></a>如何保证消息不被重复消费？(幂等性)</h2><p>什么是幂等性，同一条数据重复出现了多次，数据库里只保存一条数据，这就是保证了系统的幂等性。</p>\n<p><strong>如何保证幂等性，需要结合具体的业务场景来思考，先来几个思路：</strong></p>\n<ol>\n<li>比如获取到消息准备写入数据库，先根据主键查一下有没有消费过，如果消费过可以选择不处理或者更新。</li>\n<li>比如是要写入Redis，就不用考虑了，Redis每次都是set，天然幂等性。</li>\n<li>还可以让生产者发送数据时，增加一个全局唯一的ID，维护一张消费记录表，消费数据前，先去消息记录表中查询有没有消费过，如果没有消费就处理，消费过了就不要处理了。</li>\n</ol>\n<hr>\n<h2 id=\"如何保证消息的可靠性传输，不丢消息？\"><a href=\"#如何保证消息的可靠性传输，不丢消息？\" class=\"headerlink\" title=\"如何保证消息的可靠性传输，不丢消息？\"></a>如何保证消息的可靠性传输，不丢消息？</h2><p><strong>消息丢失的3种情况：</strong></p>\n<ol>\n<li><strong>生产者</strong>写入消息的过程中，消息没到rabbitmq，在网络传输过程中丢失了；</li>\n<li><strong>rabbitmq</strong>接受到了消息并暂存入内存，消费者还没来得及消费，rabbitmq自己挂掉了；</li>\n<li><strong>消费者</strong>消费到了这个消息，但是还没来得及处理，自己就挂掉了，rabbitmq以为处理完了。</li>\n</ol>\n<p>情况1<strong>（生产者弄丢了数据）</strong>的解决方案：</p>\n<p><strong>rabbitmq的事务机制</strong>：生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，就可以提交事务（channel.txCommit）。但是rabbitmq事务一搞，同步机制太耗性能，基本上吞吐量会下来。</p>\n<p><strong>confirm机制</strong>：在生产者那里设置开启confirm模式后，每次写的消息都会分配一个唯一的ID，如果成功写入了rabbitmq中，rabbitmq会回调生产者ack接口，说明这个消息成功写入了。如果rabbitmq没能处理这个消息，会回调一个nack接口，说明这个消息接收失败，需要重发。而且还可以在内存里维护每个消息ID的状态，如果超过一定时间还没有接受到这个消息的回调，也可以重发。</p>\n<p>事务机制和confirm机制最大的不同在于，事务机制是同步的，提交一个事务以后会阻塞在那，但是confirm机制是异步的，发送消息以后可以再发送下一个消息，rabbitmq接收到以后会异步回调生产者接口告知。</p>\n<p>情况2<strong>（rabbitmq弄丢了数据）</strong>的解决方案：</p>\n<p><strong>开启rabbitmq持久化</strong>：意思就是写入消息到rabbitmq后会把消息持久化到磁盘，这样就算rabbitmq自己挂了，恢复之后也会自动读取之前存储的数据，一般数据不会丢。也有可能rabbitmq还没持久化就挂了，导致数据丢失，不过这种情况概率较小。</p>\n<p>设置持久化有两个步骤，第一个步骤是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的消息；第二个步骤是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化。此时rabbitmq就会将消息持久化到磁盘了，<strong>注意：必须同时设置这两个才可以</strong>。</p>\n<p>这个持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会回调生产者的ack接口，所以即使是持久化到磁盘之前rabbitmq挂了，生产者收不到回调，也是会重发的。</p>\n<p>情况3<strong>（消费者弄丢了数据）</strong>的解决方案：</p>\n<p>消费者有autoAck机制，就是消费数据之后，消费者会自动通知rabbitmq消费成功了。但是如果消费的消息还在处理中，还没处理完，消费者宕机了，还是会造成消息丢失。所以这里我们需要关闭autoAck机制，然后等待消费者完全处理完消息后，再手动发送ack给rabbitmq，此时就不会丢失消息了。</p>\n<hr>\n<h2 id=\"如何保证消息的顺序性？\"><a href=\"#如何保证消息的顺序性？\" class=\"headerlink\" title=\"如何保证消息的顺序性？\"></a>如何保证消息的顺序性？</h2><p>先看看造成消息错乱的场景</p>\n<p>如果rabbitmq的一个queue对应多个consumer，肯定会发生错乱。</p>\n<p>解决方案：</p>\n<p>拆分多个queue，使每个queue对应一个consumer，这样就可以保证消费的顺序性了；</p>\n<p>一个queue只对应一个consumer，让consumer内部用内存队列排队，然后分发给底层不同的worker来处理。</p>\n<hr>\n<p>如何解决消息队列的延迟以及过期失效的问题？消息队列满了以后怎么处理？有几百万条消息持续积压几小时，说说怎么解决？</p>\n<p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤如下：</p>\n<ol>\n<li>先修复consumer的问题，确保其恢复正常的消费速度，然后将现有的consumer都停掉。</li>\n<li>临时建立好原先10倍或者20倍的queue数量。</li>\n<li>然后写一个临时分发数据的consumer程序，把这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮训写入临时建立好的10倍数量的queue。</li>\n<li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。</li>\n<li>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消耗数据。</li>\n<li>等快速消费完积压的数据之后，得恢复原来部署的架构，重新用原先的consumer机器来消费消息。</li>\n</ol>\n<p>假设使用的是rabbitmq，设置了过期时间，过量积压最终导致大量数据过期后丢失，这种情况只能是批量重导。到了晚上高峰期过后，查询出来丢失的数据，重新灌入到mq中，把丢失的数据补回来。</p>\n<p>如果是因为积压太久导致mq快写满了，只能临时修改程序，快速消费掉所有消息，然后晚上再补数据。</p>\n<hr>\n<h2 id=\"如果让你写消息队列，如何架构设计？\"><a href=\"#如果让你写消息队列，如何架构设计？\" class=\"headerlink\" title=\"如果让你写消息队列，如何架构设计？\"></a>如果让你写消息队列，如何架构设计？</h2><p><strong>下面说一下设计思路</strong></p>\n<ol>\n<li>首先设计的mq得支持可伸缩，就是需要的时候快速扩容，就可以增加容量和吞吐量。所以需要设计一个分布式系统，参照kafka的设计理念，broker -&gt; topic -&gt; partition，每个partition放一个机器，就存一部分数据。如果资源不够了，可以直接给topic增加partition，然后做数据迁移。</li>\n<li>其次设计的mq需要把数据落地到磁盘，防止数据丢失。根据Kafka的设计思路，顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的。</li>\n<li>还要考虑一下mq的可用性。具体参照Kafka的高可用环节，多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举leader即可对外服务。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"为什么使用消息队列？说说优缺点？\"><a href=\"#为什么使用消息队列？说说优缺点？\" class=\"headerlink\" title=\"为什么使用消息队列？说说优缺点？\"></a>为什么使用消息队列？说说优缺点？</h2><p>我们公司有个什么业务场景，这个场景有个什么技术挑战，如果不用MQ会很麻烦，用了MQ之后带来了很多好处。</p>\n<p>比较核心的使用场景有3个：<strong>解耦、异步、削峰</strong>。同样也是使用MQ的<strong>优点</strong>。</p>\n<p><strong>解耦举例</strong>：A系统产生了一条比较重要的数据，B、C、D系统都需要，如果不使用MQ的话，A系统要做很多事情，比如需要分别调用B、C、D系统的接口传递数据，还要考虑接口的参数，可用性等等， 如果有新系统加入的话，还要更改很麻烦。如果使用MQ的话，A系统把产生的数据直接发送到MQ就不用管了，谁需要这条消息自己去MQ里获取，如果某个系统不需要这些消息了就不用去消费数据了，这样A系统就不需要考虑其他系统是否调用成功，接口是否超时，失败重试等等，所有操作就变得很简单。</p>\n<p>总结：通过一个MQ的发布/订阅模型（Pub/Sub）系统A就跟其他系统解耦了。","more":"</p>\n<p><strong>异步举例</strong>：A系统发起一次请求，假设A系统本地处理SQL并发送需要20ms，然后分别调用B、C、D系统，分别耗时300ms，450ms，200ms，如果是同步调用的话，总耗时就是这几次调用的和，用户的内心是崩溃的。如果使用MQ的话，系统A可以连续发送3条消息到3个MQ队列中，耗时5ms，系统B、C、D自己从对应的消息队列中获取，需要耗时操作在各自系统执行。因为是异步调用，A系统不需要等待反馈，发送成功后直接给用户反馈的时间就是20ms+5ms=25ms，用户爽歪歪。</p>\n<p>总结：系统间非常耗时的调用，可以使用MQ异步化来做性能优化。异步化可以大幅度提升高延时接口的性能。</p>\n<p><strong>削峰举例</strong>：大量用户（几百万）通过浏览器同时在某一时刻进行操作，这时就会有大量的请求涌入，如果超过数据库瓶颈就会把数据库打死，高峰期过后请求会大量减少，这时可以考虑采用MQ做削峰处理。大量的请求直接发送到MQ，各个系统根据自己的处理能力去MQ拉取消息，延时处理MQ积压的请求，达到削峰的效果。</p>\n<p>总结：削峰可以缓解数据库压力，达到最终一致性。</p>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>系统的可用性降低，系统引入的外部依赖越多，越容易挂掉。MQ发生故障，可能使系统崩溃。</li>\n<li>系统的复杂性提高，还需要考虑重复消费，消息丢失，消息传递顺序性等等一系列问题。</li>\n<li>一致性问题，A系统把请求发送到MQ返回成功了，但是B、C、D消费消息有失败的，如何解决。</li>\n</ul>\n<hr>\n<h2 id=\"不同消息中间件的区别以及适用场景？\"><a href=\"#不同消息中间件的区别以及适用场景？\" class=\"headerlink\" title=\"不同消息中间件的区别以及适用场景？\"></a>不同消息中间件的区别以及适用场景？</h2><ul>\n<li>单机吞吐量：activemq和rabbitmq吞吐量是万级，rocketmq和kafka都是10万级。</li>\n<li>时效性：影响不大，activemq、rocketmq、kafka都在毫秒级，rabbitmq在微秒级。</li>\n<li>可用性：都可以保证，activemq和rabbitmq都是基于主从架构，后两者基于分布式架构。</li>\n</ul>\n<p>优劣势总结</p>\n<ul>\n<li>activemq非常成熟，功能强大，在业内有广泛应用，不过偶尔会有较低概率丢失消息，还有就是开源社区越来越不活跃，维护次数也越来越少，activemq5.x主要是基于解耦和异步来使用的，较少在大规模吞吐量的场景哦中使用。</li>\n<li>rabbitmq并发能力很强，性能极好，延迟很低，特别适合国内中小型公司，提供非常友好的后台管理界面，开源社区相对来说比较活跃。不过确实吞吐量低一些，而且rabbitmq集群动态扩展很麻烦，erlang开发的，很难读懂源码。</li>\n<li>rocketmq的吞吐量很大，阿里开源的采用分布式架构设计的，扩展方便而且可用性很高，经过参数优化配置可以做到消息0丢失，可以支撑大规模吞吐量、业务复杂的场景，社区很活跃，源码是Java的。缺点是如果阿里抛弃这个技术，社区很可能黄掉，需要自己维护。</li>\n<li>kafka也是可以做到大规模吞吐，分布式架构可用性很高，任意扩展，消息0丢失，功能较为简单，在大数据领域的实时计算以及日志采集被大规模使用。kafka唯一的缺点就是可能消息重复消费。</li>\n</ul>\n<p>综上所述：现在越来越多的公司去使用RocketMQ，大型公司并且对自己公司实力有自信的，推荐使用。对于技术实力较为一般、技术挑战不是很高的中小型公司推荐RabbitMQ，如果是大数据领域的实时计算，日志采集等场景，kafka是业内标准，肯定不会黄。</p>\n<hr>\n<h2 id=\"RabbitMQ如何保证消息队列的高可用？\"><a href=\"#RabbitMQ如何保证消息队列的高可用？\" class=\"headerlink\" title=\"RabbitMQ如何保证消息队列的高可用？\"></a>RabbitMQ如何保证消息队列的高可用？</h2><p>RabbitMQ是比较有代表性的，因为是基于<strong>主从架构</strong>实现的的高可用。</p>\n<p>RabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式。</p>\n<ol>\n<li><p>单机模式</p>\n<p>就是demo级别的，一般就是自己玩玩，没有生产环境使用单机模式的。</p>\n</li>\n<li><p>普通集群模式（不是高可用的）</p>\n<p>意思就是分别在多台机器上启动多个rabbitmq实例，每个机器启动一个，但是你创建的queue只会把元数据和实际数据放在一个rabbitmq实例上，每个实例都去同步queue的元数据。等到你消费的时候，如果你连接到另外一个实例，那么该实例就会从queue所在的实例上拉取实际数据过来。</p>\n<p>该模式有两个缺点：</p>\n<p>​    如果每次随机连接一个实例，可能会在rabbitmq集群内部产生大量的数据传输，造成大量的数据开销；</p>\n<p>​    如果每次都连接queue的实例，那么也就没有什么性能可言，queue宕机后就不能使用了。</p>\n</li>\n<li><p>镜像集群模式（是高可用的）</p>\n<p>这种模式才是真正的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论是元数据还是queue里的消息都会存在于多个实例上，每次写入消息到queue的时候，都会自动把消息同步到多个实例。</p>\n<p>这样的话好处在于你的任何一个机器宕机了，其他机器都还可以使用。坏处在于开销太大，消息同步所有机器，导致网络带宽压力和消耗都很严重。其次是没有扩展性，如果queue的数据量很大，负载很严重，增加机器也会包含queue的所有数据，并没有办法扩展queue。</p>\n<p><strong>怎么开启这个镜像集群模式呢？</strong></p>\n<p>rabbitmq有很好的管理控制台，在后台新增一个镜像集群模式的策略，指定同步节点的时候要求数据同步到所有节点，再次创建queue的时候，应用这个策略就会自动将数据同步到其他的节点上。</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"如何保证消息不被重复消费？-幂等性\"><a href=\"#如何保证消息不被重复消费？-幂等性\" class=\"headerlink\" title=\"如何保证消息不被重复消费？(幂等性)\"></a>如何保证消息不被重复消费？(幂等性)</h2><p>什么是幂等性，同一条数据重复出现了多次，数据库里只保存一条数据，这就是保证了系统的幂等性。</p>\n<p><strong>如何保证幂等性，需要结合具体的业务场景来思考，先来几个思路：</strong></p>\n<ol>\n<li>比如获取到消息准备写入数据库，先根据主键查一下有没有消费过，如果消费过可以选择不处理或者更新。</li>\n<li>比如是要写入Redis，就不用考虑了，Redis每次都是set，天然幂等性。</li>\n<li>还可以让生产者发送数据时，增加一个全局唯一的ID，维护一张消费记录表，消费数据前，先去消息记录表中查询有没有消费过，如果没有消费就处理，消费过了就不要处理了。</li>\n</ol>\n<hr>\n<h2 id=\"如何保证消息的可靠性传输，不丢消息？\"><a href=\"#如何保证消息的可靠性传输，不丢消息？\" class=\"headerlink\" title=\"如何保证消息的可靠性传输，不丢消息？\"></a>如何保证消息的可靠性传输，不丢消息？</h2><p><strong>消息丢失的3种情况：</strong></p>\n<ol>\n<li><strong>生产者</strong>写入消息的过程中，消息没到rabbitmq，在网络传输过程中丢失了；</li>\n<li><strong>rabbitmq</strong>接受到了消息并暂存入内存，消费者还没来得及消费，rabbitmq自己挂掉了；</li>\n<li><strong>消费者</strong>消费到了这个消息，但是还没来得及处理，自己就挂掉了，rabbitmq以为处理完了。</li>\n</ol>\n<p>情况1<strong>（生产者弄丢了数据）</strong>的解决方案：</p>\n<p><strong>rabbitmq的事务机制</strong>：生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，就可以提交事务（channel.txCommit）。但是rabbitmq事务一搞，同步机制太耗性能，基本上吞吐量会下来。</p>\n<p><strong>confirm机制</strong>：在生产者那里设置开启confirm模式后，每次写的消息都会分配一个唯一的ID，如果成功写入了rabbitmq中，rabbitmq会回调生产者ack接口，说明这个消息成功写入了。如果rabbitmq没能处理这个消息，会回调一个nack接口，说明这个消息接收失败，需要重发。而且还可以在内存里维护每个消息ID的状态，如果超过一定时间还没有接受到这个消息的回调，也可以重发。</p>\n<p>事务机制和confirm机制最大的不同在于，事务机制是同步的，提交一个事务以后会阻塞在那，但是confirm机制是异步的，发送消息以后可以再发送下一个消息，rabbitmq接收到以后会异步回调生产者接口告知。</p>\n<p>情况2<strong>（rabbitmq弄丢了数据）</strong>的解决方案：</p>\n<p><strong>开启rabbitmq持久化</strong>：意思就是写入消息到rabbitmq后会把消息持久化到磁盘，这样就算rabbitmq自己挂了，恢复之后也会自动读取之前存储的数据，一般数据不会丢。也有可能rabbitmq还没持久化就挂了，导致数据丢失，不过这种情况概率较小。</p>\n<p>设置持久化有两个步骤，第一个步骤是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的消息；第二个步骤是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化。此时rabbitmq就会将消息持久化到磁盘了，<strong>注意：必须同时设置这两个才可以</strong>。</p>\n<p>这个持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会回调生产者的ack接口，所以即使是持久化到磁盘之前rabbitmq挂了，生产者收不到回调，也是会重发的。</p>\n<p>情况3<strong>（消费者弄丢了数据）</strong>的解决方案：</p>\n<p>消费者有autoAck机制，就是消费数据之后，消费者会自动通知rabbitmq消费成功了。但是如果消费的消息还在处理中，还没处理完，消费者宕机了，还是会造成消息丢失。所以这里我们需要关闭autoAck机制，然后等待消费者完全处理完消息后，再手动发送ack给rabbitmq，此时就不会丢失消息了。</p>\n<hr>\n<h2 id=\"如何保证消息的顺序性？\"><a href=\"#如何保证消息的顺序性？\" class=\"headerlink\" title=\"如何保证消息的顺序性？\"></a>如何保证消息的顺序性？</h2><p>先看看造成消息错乱的场景</p>\n<p>如果rabbitmq的一个queue对应多个consumer，肯定会发生错乱。</p>\n<p>解决方案：</p>\n<p>拆分多个queue，使每个queue对应一个consumer，这样就可以保证消费的顺序性了；</p>\n<p>一个queue只对应一个consumer，让consumer内部用内存队列排队，然后分发给底层不同的worker来处理。</p>\n<hr>\n<p>如何解决消息队列的延迟以及过期失效的问题？消息队列满了以后怎么处理？有几百万条消息持续积压几小时，说说怎么解决？</p>\n<p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤如下：</p>\n<ol>\n<li>先修复consumer的问题，确保其恢复正常的消费速度，然后将现有的consumer都停掉。</li>\n<li>临时建立好原先10倍或者20倍的queue数量。</li>\n<li>然后写一个临时分发数据的consumer程序，把这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮训写入临时建立好的10倍数量的queue。</li>\n<li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。</li>\n<li>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消耗数据。</li>\n<li>等快速消费完积压的数据之后，得恢复原来部署的架构，重新用原先的consumer机器来消费消息。</li>\n</ol>\n<p>假设使用的是rabbitmq，设置了过期时间，过量积压最终导致大量数据过期后丢失，这种情况只能是批量重导。到了晚上高峰期过后，查询出来丢失的数据，重新灌入到mq中，把丢失的数据补回来。</p>\n<p>如果是因为积压太久导致mq快写满了，只能临时修改程序，快速消费掉所有消息，然后晚上再补数据。</p>\n<hr>\n<h2 id=\"如果让你写消息队列，如何架构设计？\"><a href=\"#如果让你写消息队列，如何架构设计？\" class=\"headerlink\" title=\"如果让你写消息队列，如何架构设计？\"></a>如果让你写消息队列，如何架构设计？</h2><p><strong>下面说一下设计思路</strong></p>\n<ol>\n<li>首先设计的mq得支持可伸缩，就是需要的时候快速扩容，就可以增加容量和吞吐量。所以需要设计一个分布式系统，参照kafka的设计理念，broker -&gt; topic -&gt; partition，每个partition放一个机器，就存一部分数据。如果资源不够了，可以直接给topic增加partition，然后做数据迁移。</li>\n<li>其次设计的mq需要把数据落地到磁盘，防止数据丢失。根据Kafka的设计思路，顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的。</li>\n<li>还要考虑一下mq的可用性。具体参照Kafka的高可用环节，多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举leader即可对外服务。</li>\n</ol>"},{"title":"分库分表的原理","date":"2019-03-17T15:43:23.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## 为什么要分库分表？\n\n- 数据库的数据会随着业务的发展而不断增多，对数据操作的开销也会越来越大。\n\n- 物理服务器的资源有限（CPU、磁盘、内存、IO）最终数据库所能承载的数据量和数据处理能力遇到瓶颈。\n\n  换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。\n\n  比如单表数据量太大（500w以上），会极大的影响SQL的执行性能。<!--more-->\n\n------\n\n## 如何进行分库分表？\n\n### 数据分表\n\n- #### 垂直分表\n\n  根据业务把一个表中的字段(Field)分到不同的表中。这些被分出去的数据通常根据业务需要，例如分出去一些不是经常使用的字段，一些长度较长的字段。一般被拆分的表的字段数比较多。**主要是避免查询的时候出现因为数据量大而造成的“跨页”问题。**\n\n  垂直拆分在数据库设计之初就会考虑，尽量在系统上线之前调整。已经上线的项目，做这种操作是要慎重考虑的。\n\n- #### 水平分表\n\n  将一个表中的数据，按照关键字(例如：ID)对一个具体的数字取模，得到的余数就是需要存放到的新表的位置。\n\n  水平分表就是把一个表里的数据分配到多个表里去，但是每个库的表结构一样，只不过每个库表存放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义就是将数据均匀的放到更多的库里，然后用更多的库来抗更高的并发，还可以通过多个库的容量来扩容。\n\n![](https://tva1.sinaimg.cn/large/0082zybply1gbtin7sm0xj31tc0quhdv.jpg)\n\n### 数据分库\n\n每个物理数据库支持数据都是有限的，每一次的数据库请求都会产生一次数据库链接，当一个库无法支持更多访问的时候，我们会把原来的单个数据库分成多个，帮助分担压力。\n\n- 根据业务不同分库，这种情况都会把主营业务和其他功能分开。例如可以分为订单数据库，核算数据库，评论数据库。\n- 根据冷热数据进行分库，用数据访问频率来划分，例如：近一个月的交易数据属于高频数据，2-6 个月的交易数据属于中频数据，大于 6 个月的数据属于低频数据。\n- 根据访问数据的地域/时间范围进行分库。\n\n**range和hash的优缺点**\n\n![](https://tva1.sinaimg.cn/large/0082zybply1gbtiwjec6pj30yw09418a.jpg)\n\n**分库分表会遇到哪些问题**\n\n- ID：主键不可以使用 UUID，性能太差，如果是文件名啥的可以用，不依赖数据库直接在系统中生成，即UUID.randomUUID().toString.replace(\"-\",\"\")，UUID 实现起来比较方便，但是占用的空间比较大；可以用数据库自增ID，即通过一张表来存放生成的 Sequence，不过效率都不算高。Sequence 表的方式节省了空间，但是单表性能瓶颈，且所有的 ID 都依赖于单表。这里推荐使用snowflake算法。\n\n- Join：需要做两次查询，把两次查询的结果在应用层做合并。这种做法是最简单的，在应用层设计的时候需要考虑。\n\n- 排序/分页：数据分配到水平的几个表中的时候，做排序和分页或者一些集合操作是不容易的。这里根据经验介绍两种方法。\n\n  1. 对分表的数据先进行排序/分页/聚合，再进行合并。\n\n  2. 对分表的数据先进行合并再做排序/分页/聚合。\n\n- 事务：存在分布式事务的可能，需要考虑补偿事务或者用 TCC(Try Confirm Cancel)协助完成。\n\n------\n\n## 如何对数据库进行扩容？\n\n分库之后的数据库会遇到数据扩容或者数据迁移的情况。这里推荐两种数据库扩容的方案。\n\n- ### 主从数据库扩容\n\n  我们这里假设有两个数据库集群，每个集群分别有 M1 S1 和 M2 S2 互为主备。\n\n  由于 M1 和 S1 互为主备所以数据是一样的，M2 和 S2 同样。把原有的 ID %2 模式切换成 ID %4 模式，也就是把两个数据集群扩充到 4 个数据库集群。\n\n  负载均衡器直接把数据路由到原来两个 S1 和 S2 上面，同时 S1 和 S2 会停止与 M1 和 M2 的数据同步，单独作为主库(写操作)存在。\n\n  这些修改不需要重启数据库服务，只需要修改代理配置就可以完成。由于 M1 M2 S1 S2 中会存在一些冗余的数据，可以后台起服务将这些冗余数据删除，不会影响数据使用。\n\n  此时，再考虑数据库可用性，将扩展后的 4 个主库进行主备操作，针对每个主库都建立对应的从库，前者负责写操作，后者负责读操作。下次如果需要扩容也可以按照类似的操作进行。\n\n- ### 双写数据库扩容\n\n  在没有数据库主从配置的情况下的扩容，假设有数据库 M1 M2，需要对目前的两个数据库做扩容，扩容之后是 4 个库。新增的库是 M3，M4 路由的方式分别是 ID%2=0 和 ID%2=1。\n\n  这个时候新的数据会同时进入 M1 M2 M3 M4 四个库中，而老数据的使用依旧从 M1 M2 中获取。\n\n  与此同时，后台服务对 M1 M3，M2 M4 做数据同步，建议先做全量同步再做数据校验。\n\n  当完成数据同步之后，四个库的数据保持一致了，修改负载均衡代理的配置为 ID%4 的模式。此时扩容就完成了，从原来的 2 个数据库扩展成 4 个数据库。\n\n  当然会存在部分的数据冗余，需要像上面一个方案一样通过后台服务删除这些冗余数据，删除的过程不会影响业务。\n\n------\n\n## 用过哪些分库分表的中间件？\n\n**sharding-jdbc 和 mycat**。\n\nsharding-jdbc是基于client层的，优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高。缺点是如果遇到升级啥的需要各个系统都重新升级再发布。\n\nmycat是基于proxy层的，优点在于各个项目是透明的，直接访问中间件就可以了，升级维护啥的自己在中间件那里搞就行了。缺点是需要部署，自己维护一套中间件，运维成本高。\n\n## 不同的中间件有什么优缺点？\n\n![](https://tva1.sinaimg.cn/large/0082zybply1gbthfnw403j30yk070k3g.jpg)\n\n------\n\n## 如何把单库单表的系统迁移到分库分表？\n\n1. ### 停机迁移\n\n   发布公告，凌晨0点～2点维护系统，暂停使用。\n\n   数据迁移，修改配置，验证测试。\n\n   ![](https://tva1.sinaimg.cn/large/0082zybply1gbtrd56mz7j31400k84qp.jpg)\n\n   \n\n2. ### 不停机双写迁移\n\n   通过修改配置实现在系统写入单库单表的同时，也将数据发送到mycat，往分库分表中写入数据。\n\n   此时还会启动一个后台数据迁移临时工具来将历史数据同步到分库分表中，将历史数据写入分库分表前，先查询分库分表中是否存在，如果不存在，直接写入，如果存在，则通过查询比较两个数据的时间戳，将更新的数据保留在分库分表中。\n\n   ![](https://tva1.sinaimg.cn/large/0082zybply1gbtrsa3jy3j31300n64qp.jpg)\n\n------\n\n## 分库分表以后ID主键如何处理？\n\n推荐使用Snowflake算法，这是 Twitter 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。\n\n其核心思想是：生成一个64位的long型ID，其中第一位是符号位0，后面使用 41bit 作为毫秒数，10bit 作为机器的 ID(5 个 bit 是数据中心(机房)，5 个 bit 的机器 ID)，12bit 作为毫秒内的流水号(意味着每个节点在每毫秒可以产生 4096 个 ID)。\n\n![](https://tva1.sinaimg.cn/large/0082zybply1gbushxzxnlj30go05bdg1.jpg)\n\n\n\n------\n\n## 如何实现mysql的读写分离？\n\n其实很简单，就是基于主从复制架构，搞一个主库，挂多个从库，我们单单只是写主库，主库会自动把数据同步到从库上去，从库只负责读，借此来分担数据库读压力。\n\n## mysql主从复制的原理？\n\n1. mysql里有一个概念-binlog日志，每个增删改操作在操作数据的同时，还会维护一个日志文件，记录这些操作。\n2. 从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入relay(中继)日志中。\n3. 接着从库中有一个SQL线程会从relay日志中读取binlog日志，然后执行其中的内容，使主从数据保持一致。\n\n**需要注意的问题（数据延迟和数据丢失）**\n\n![](https://tva1.sinaimg.cn/large/0082zybply1gbvrsjdv6wj316c0dcwvw.jpg)\n\n1. 从库同步主库的过程是串行化的，也就是说主库上并行的操作在从库上会串行执行。\n2. 由于从库拷贝主库日志以及串行执行的特点，在高并发的场景下，从库的数据同步会有延迟。\n3. 如果主库突然宕机，数据恰好还没同步到从库，导致有些数据在从库里是没有的，造成数据丢失。\n\n**如何解决？**\n\nmysql在这一块有两个机制，一个是**半同步复制**，解决数据丢失问题。一个是**并行复制**，缓解数据延时问题。\n\n- 所谓半同步复制（semi-sync）指的就是主库写入binlog日志后，就会立即将数据同步到从库。从库将日志写入到relay日志后，会返回ack给主库，主库收到至少一个ack之后才会认为写操作完成了。\n- 所谓并行复制，指的是从库开启多个SQL线程，并行读取relay日志进行多库并发重放，有必要让DBA开启并行复制，不过并行复制的意义并不大，并发高了以后生产环境还会有延时问题。\n\n**有没有更好的方法解决主从数据延时问题（重点）**\n\n1. 分库，把一个主库拆分成多个主库，降低主库的写并发，使得延迟时间可以忽略不计。\n2. 重写代码，插入数据成功后直接修改数据，不要查询（因为修改数据在主库，查询在从库）。\n3. 如果确实存在数据写入后立马就要查到，可以对这个查询设置直连主库（不推荐，失去读写分离的意义）。\n\n------\n\n## 总结\n\n- 因为数据量的上升，为了提高性能会对系统进行分表分库。\n- 从分表来说，有水平分表和垂直分表两种方式。\n- 从分库来说，可以根据业务，冷热数据等来进行分库，分库以后通过主从库来实现读写分离。\n- 如果对分库之后数据库做扩容，有两种方式，主从数据库扩容和双写数据库扩容。","source":"_posts/Sub-table.md","raw":"---\ntitle: 分库分表的原理\ndate: 2019-03-17 23:43:23\ncategories: Java\ntags:\n  - 数据库\n  - Sub-table\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## 为什么要分库分表？\n\n- 数据库的数据会随着业务的发展而不断增多，对数据操作的开销也会越来越大。\n\n- 物理服务器的资源有限（CPU、磁盘、内存、IO）最终数据库所能承载的数据量和数据处理能力遇到瓶颈。\n\n  换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。\n\n  比如单表数据量太大（500w以上），会极大的影响SQL的执行性能。<!--more-->\n\n------\n\n## 如何进行分库分表？\n\n### 数据分表\n\n- #### 垂直分表\n\n  根据业务把一个表中的字段(Field)分到不同的表中。这些被分出去的数据通常根据业务需要，例如分出去一些不是经常使用的字段，一些长度较长的字段。一般被拆分的表的字段数比较多。**主要是避免查询的时候出现因为数据量大而造成的“跨页”问题。**\n\n  垂直拆分在数据库设计之初就会考虑，尽量在系统上线之前调整。已经上线的项目，做这种操作是要慎重考虑的。\n\n- #### 水平分表\n\n  将一个表中的数据，按照关键字(例如：ID)对一个具体的数字取模，得到的余数就是需要存放到的新表的位置。\n\n  水平分表就是把一个表里的数据分配到多个表里去，但是每个库的表结构一样，只不过每个库表存放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义就是将数据均匀的放到更多的库里，然后用更多的库来抗更高的并发，还可以通过多个库的容量来扩容。\n\n![](https://tva1.sinaimg.cn/large/0082zybply1gbtin7sm0xj31tc0quhdv.jpg)\n\n### 数据分库\n\n每个物理数据库支持数据都是有限的，每一次的数据库请求都会产生一次数据库链接，当一个库无法支持更多访问的时候，我们会把原来的单个数据库分成多个，帮助分担压力。\n\n- 根据业务不同分库，这种情况都会把主营业务和其他功能分开。例如可以分为订单数据库，核算数据库，评论数据库。\n- 根据冷热数据进行分库，用数据访问频率来划分，例如：近一个月的交易数据属于高频数据，2-6 个月的交易数据属于中频数据，大于 6 个月的数据属于低频数据。\n- 根据访问数据的地域/时间范围进行分库。\n\n**range和hash的优缺点**\n\n![](https://tva1.sinaimg.cn/large/0082zybply1gbtiwjec6pj30yw09418a.jpg)\n\n**分库分表会遇到哪些问题**\n\n- ID：主键不可以使用 UUID，性能太差，如果是文件名啥的可以用，不依赖数据库直接在系统中生成，即UUID.randomUUID().toString.replace(\"-\",\"\")，UUID 实现起来比较方便，但是占用的空间比较大；可以用数据库自增ID，即通过一张表来存放生成的 Sequence，不过效率都不算高。Sequence 表的方式节省了空间，但是单表性能瓶颈，且所有的 ID 都依赖于单表。这里推荐使用snowflake算法。\n\n- Join：需要做两次查询，把两次查询的结果在应用层做合并。这种做法是最简单的，在应用层设计的时候需要考虑。\n\n- 排序/分页：数据分配到水平的几个表中的时候，做排序和分页或者一些集合操作是不容易的。这里根据经验介绍两种方法。\n\n  1. 对分表的数据先进行排序/分页/聚合，再进行合并。\n\n  2. 对分表的数据先进行合并再做排序/分页/聚合。\n\n- 事务：存在分布式事务的可能，需要考虑补偿事务或者用 TCC(Try Confirm Cancel)协助完成。\n\n------\n\n## 如何对数据库进行扩容？\n\n分库之后的数据库会遇到数据扩容或者数据迁移的情况。这里推荐两种数据库扩容的方案。\n\n- ### 主从数据库扩容\n\n  我们这里假设有两个数据库集群，每个集群分别有 M1 S1 和 M2 S2 互为主备。\n\n  由于 M1 和 S1 互为主备所以数据是一样的，M2 和 S2 同样。把原有的 ID %2 模式切换成 ID %4 模式，也就是把两个数据集群扩充到 4 个数据库集群。\n\n  负载均衡器直接把数据路由到原来两个 S1 和 S2 上面，同时 S1 和 S2 会停止与 M1 和 M2 的数据同步，单独作为主库(写操作)存在。\n\n  这些修改不需要重启数据库服务，只需要修改代理配置就可以完成。由于 M1 M2 S1 S2 中会存在一些冗余的数据，可以后台起服务将这些冗余数据删除，不会影响数据使用。\n\n  此时，再考虑数据库可用性，将扩展后的 4 个主库进行主备操作，针对每个主库都建立对应的从库，前者负责写操作，后者负责读操作。下次如果需要扩容也可以按照类似的操作进行。\n\n- ### 双写数据库扩容\n\n  在没有数据库主从配置的情况下的扩容，假设有数据库 M1 M2，需要对目前的两个数据库做扩容，扩容之后是 4 个库。新增的库是 M3，M4 路由的方式分别是 ID%2=0 和 ID%2=1。\n\n  这个时候新的数据会同时进入 M1 M2 M3 M4 四个库中，而老数据的使用依旧从 M1 M2 中获取。\n\n  与此同时，后台服务对 M1 M3，M2 M4 做数据同步，建议先做全量同步再做数据校验。\n\n  当完成数据同步之后，四个库的数据保持一致了，修改负载均衡代理的配置为 ID%4 的模式。此时扩容就完成了，从原来的 2 个数据库扩展成 4 个数据库。\n\n  当然会存在部分的数据冗余，需要像上面一个方案一样通过后台服务删除这些冗余数据，删除的过程不会影响业务。\n\n------\n\n## 用过哪些分库分表的中间件？\n\n**sharding-jdbc 和 mycat**。\n\nsharding-jdbc是基于client层的，优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高。缺点是如果遇到升级啥的需要各个系统都重新升级再发布。\n\nmycat是基于proxy层的，优点在于各个项目是透明的，直接访问中间件就可以了，升级维护啥的自己在中间件那里搞就行了。缺点是需要部署，自己维护一套中间件，运维成本高。\n\n## 不同的中间件有什么优缺点？\n\n![](https://tva1.sinaimg.cn/large/0082zybply1gbthfnw403j30yk070k3g.jpg)\n\n------\n\n## 如何把单库单表的系统迁移到分库分表？\n\n1. ### 停机迁移\n\n   发布公告，凌晨0点～2点维护系统，暂停使用。\n\n   数据迁移，修改配置，验证测试。\n\n   ![](https://tva1.sinaimg.cn/large/0082zybply1gbtrd56mz7j31400k84qp.jpg)\n\n   \n\n2. ### 不停机双写迁移\n\n   通过修改配置实现在系统写入单库单表的同时，也将数据发送到mycat，往分库分表中写入数据。\n\n   此时还会启动一个后台数据迁移临时工具来将历史数据同步到分库分表中，将历史数据写入分库分表前，先查询分库分表中是否存在，如果不存在，直接写入，如果存在，则通过查询比较两个数据的时间戳，将更新的数据保留在分库分表中。\n\n   ![](https://tva1.sinaimg.cn/large/0082zybply1gbtrsa3jy3j31300n64qp.jpg)\n\n------\n\n## 分库分表以后ID主键如何处理？\n\n推荐使用Snowflake算法，这是 Twitter 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。\n\n其核心思想是：生成一个64位的long型ID，其中第一位是符号位0，后面使用 41bit 作为毫秒数，10bit 作为机器的 ID(5 个 bit 是数据中心(机房)，5 个 bit 的机器 ID)，12bit 作为毫秒内的流水号(意味着每个节点在每毫秒可以产生 4096 个 ID)。\n\n![](https://tva1.sinaimg.cn/large/0082zybply1gbushxzxnlj30go05bdg1.jpg)\n\n\n\n------\n\n## 如何实现mysql的读写分离？\n\n其实很简单，就是基于主从复制架构，搞一个主库，挂多个从库，我们单单只是写主库，主库会自动把数据同步到从库上去，从库只负责读，借此来分担数据库读压力。\n\n## mysql主从复制的原理？\n\n1. mysql里有一个概念-binlog日志，每个增删改操作在操作数据的同时，还会维护一个日志文件，记录这些操作。\n2. 从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入relay(中继)日志中。\n3. 接着从库中有一个SQL线程会从relay日志中读取binlog日志，然后执行其中的内容，使主从数据保持一致。\n\n**需要注意的问题（数据延迟和数据丢失）**\n\n![](https://tva1.sinaimg.cn/large/0082zybply1gbvrsjdv6wj316c0dcwvw.jpg)\n\n1. 从库同步主库的过程是串行化的，也就是说主库上并行的操作在从库上会串行执行。\n2. 由于从库拷贝主库日志以及串行执行的特点，在高并发的场景下，从库的数据同步会有延迟。\n3. 如果主库突然宕机，数据恰好还没同步到从库，导致有些数据在从库里是没有的，造成数据丢失。\n\n**如何解决？**\n\nmysql在这一块有两个机制，一个是**半同步复制**，解决数据丢失问题。一个是**并行复制**，缓解数据延时问题。\n\n- 所谓半同步复制（semi-sync）指的就是主库写入binlog日志后，就会立即将数据同步到从库。从库将日志写入到relay日志后，会返回ack给主库，主库收到至少一个ack之后才会认为写操作完成了。\n- 所谓并行复制，指的是从库开启多个SQL线程，并行读取relay日志进行多库并发重放，有必要让DBA开启并行复制，不过并行复制的意义并不大，并发高了以后生产环境还会有延时问题。\n\n**有没有更好的方法解决主从数据延时问题（重点）**\n\n1. 分库，把一个主库拆分成多个主库，降低主库的写并发，使得延迟时间可以忽略不计。\n2. 重写代码，插入数据成功后直接修改数据，不要查询（因为修改数据在主库，查询在从库）。\n3. 如果确实存在数据写入后立马就要查到，可以对这个查询设置直连主库（不推荐，失去读写分离的意义）。\n\n------\n\n## 总结\n\n- 因为数据量的上升，为了提高性能会对系统进行分表分库。\n- 从分表来说，有水平分表和垂直分表两种方式。\n- 从分库来说，可以根据业务，冷热数据等来进行分库，分库以后通过主从库来实现读写分离。\n- 如果对分库之后数据库做扩容，有两种方式，主从数据库扩容和双写数据库扩容。","slug":"Sub-table","published":1,"updated":"2020-02-14T04:41:00.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bju003sa6yb7luw8v0a","content":"<h2 id=\"为什么要分库分表？\"><a href=\"#为什么要分库分表？\" class=\"headerlink\" title=\"为什么要分库分表？\"></a>为什么要分库分表？</h2><ul>\n<li><p>数据库的数据会随着业务的发展而不断增多，对数据操作的开销也会越来越大。</p>\n</li>\n<li><p>物理服务器的资源有限（CPU、磁盘、内存、IO）最终数据库所能承载的数据量和数据处理能力遇到瓶颈。</p>\n<p>换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。</p>\n<p>比如单表数据量太大（500w以上），会极大的影响SQL的执行性能。<a id=\"more\"></a></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"如何进行分库分表？\"><a href=\"#如何进行分库分表？\" class=\"headerlink\" title=\"如何进行分库分表？\"></a>如何进行分库分表？</h2><h3 id=\"数据分表\"><a href=\"#数据分表\" class=\"headerlink\" title=\"数据分表\"></a>数据分表</h3><ul>\n<li><h4 id=\"垂直分表\"><a href=\"#垂直分表\" class=\"headerlink\" title=\"垂直分表\"></a>垂直分表</h4><p>根据业务把一个表中的字段(Field)分到不同的表中。这些被分出去的数据通常根据业务需要，例如分出去一些不是经常使用的字段，一些长度较长的字段。一般被拆分的表的字段数比较多。<strong>主要是避免查询的时候出现因为数据量大而造成的“跨页”问题。</strong></p>\n<p>垂直拆分在数据库设计之初就会考虑，尽量在系统上线之前调整。已经上线的项目，做这种操作是要慎重考虑的。</p>\n</li>\n<li><h4 id=\"水平分表\"><a href=\"#水平分表\" class=\"headerlink\" title=\"水平分表\"></a>水平分表</h4><p>将一个表中的数据，按照关键字(例如：ID)对一个具体的数字取模，得到的余数就是需要存放到的新表的位置。</p>\n<p>水平分表就是把一个表里的数据分配到多个表里去，但是每个库的表结构一样，只不过每个库表存放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义就是将数据均匀的放到更多的库里，然后用更多的库来抗更高的并发，还可以通过多个库的容量来扩容。</p>\n</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbtin7sm0xj31tc0quhdv.jpg\" alt></p>\n<h3 id=\"数据分库\"><a href=\"#数据分库\" class=\"headerlink\" title=\"数据分库\"></a>数据分库</h3><p>每个物理数据库支持数据都是有限的，每一次的数据库请求都会产生一次数据库链接，当一个库无法支持更多访问的时候，我们会把原来的单个数据库分成多个，帮助分担压力。</p>\n<ul>\n<li>根据业务不同分库，这种情况都会把主营业务和其他功能分开。例如可以分为订单数据库，核算数据库，评论数据库。</li>\n<li>根据冷热数据进行分库，用数据访问频率来划分，例如：近一个月的交易数据属于高频数据，2-6 个月的交易数据属于中频数据，大于 6 个月的数据属于低频数据。</li>\n<li>根据访问数据的地域/时间范围进行分库。</li>\n</ul>\n<p><strong>range和hash的优缺点</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbtiwjec6pj30yw09418a.jpg\" alt></p>\n<p><strong>分库分表会遇到哪些问题</strong></p>\n<ul>\n<li><p>ID：主键不可以使用 UUID，性能太差，如果是文件名啥的可以用，不依赖数据库直接在系统中生成，即UUID.randomUUID().toString.replace(“-“,””)，UUID 实现起来比较方便，但是占用的空间比较大；可以用数据库自增ID，即通过一张表来存放生成的 Sequence，不过效率都不算高。Sequence 表的方式节省了空间，但是单表性能瓶颈，且所有的 ID 都依赖于单表。这里推荐使用snowflake算法。</p>\n</li>\n<li><p>Join：需要做两次查询，把两次查询的结果在应用层做合并。这种做法是最简单的，在应用层设计的时候需要考虑。</p>\n</li>\n<li><p>排序/分页：数据分配到水平的几个表中的时候，做排序和分页或者一些集合操作是不容易的。这里根据经验介绍两种方法。</p>\n<ol>\n<li><p>对分表的数据先进行排序/分页/聚合，再进行合并。</p>\n</li>\n<li><p>对分表的数据先进行合并再做排序/分页/聚合。</p>\n</li>\n</ol>\n</li>\n<li><p>事务：存在分布式事务的可能，需要考虑补偿事务或者用 TCC(Try Confirm Cancel)协助完成。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"如何对数据库进行扩容？\"><a href=\"#如何对数据库进行扩容？\" class=\"headerlink\" title=\"如何对数据库进行扩容？\"></a>如何对数据库进行扩容？</h2><p>分库之后的数据库会遇到数据扩容或者数据迁移的情况。这里推荐两种数据库扩容的方案。</p>\n<ul>\n<li><h3 id=\"主从数据库扩容\"><a href=\"#主从数据库扩容\" class=\"headerlink\" title=\"主从数据库扩容\"></a>主从数据库扩容</h3><p>我们这里假设有两个数据库集群，每个集群分别有 M1 S1 和 M2 S2 互为主备。</p>\n<p>由于 M1 和 S1 互为主备所以数据是一样的，M2 和 S2 同样。把原有的 ID %2 模式切换成 ID %4 模式，也就是把两个数据集群扩充到 4 个数据库集群。</p>\n<p>负载均衡器直接把数据路由到原来两个 S1 和 S2 上面，同时 S1 和 S2 会停止与 M1 和 M2 的数据同步，单独作为主库(写操作)存在。</p>\n<p>这些修改不需要重启数据库服务，只需要修改代理配置就可以完成。由于 M1 M2 S1 S2 中会存在一些冗余的数据，可以后台起服务将这些冗余数据删除，不会影响数据使用。</p>\n<p>此时，再考虑数据库可用性，将扩展后的 4 个主库进行主备操作，针对每个主库都建立对应的从库，前者负责写操作，后者负责读操作。下次如果需要扩容也可以按照类似的操作进行。</p>\n</li>\n<li><h3 id=\"双写数据库扩容\"><a href=\"#双写数据库扩容\" class=\"headerlink\" title=\"双写数据库扩容\"></a>双写数据库扩容</h3><p>在没有数据库主从配置的情况下的扩容，假设有数据库 M1 M2，需要对目前的两个数据库做扩容，扩容之后是 4 个库。新增的库是 M3，M4 路由的方式分别是 ID%2=0 和 ID%2=1。</p>\n<p>这个时候新的数据会同时进入 M1 M2 M3 M4 四个库中，而老数据的使用依旧从 M1 M2 中获取。</p>\n<p>与此同时，后台服务对 M1 M3，M2 M4 做数据同步，建议先做全量同步再做数据校验。</p>\n<p>当完成数据同步之后，四个库的数据保持一致了，修改负载均衡代理的配置为 ID%4 的模式。此时扩容就完成了，从原来的 2 个数据库扩展成 4 个数据库。</p>\n<p>当然会存在部分的数据冗余，需要像上面一个方案一样通过后台服务删除这些冗余数据，删除的过程不会影响业务。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"用过哪些分库分表的中间件？\"><a href=\"#用过哪些分库分表的中间件？\" class=\"headerlink\" title=\"用过哪些分库分表的中间件？\"></a>用过哪些分库分表的中间件？</h2><p><strong>sharding-jdbc 和 mycat</strong>。</p>\n<p>sharding-jdbc是基于client层的，优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高。缺点是如果遇到升级啥的需要各个系统都重新升级再发布。</p>\n<p>mycat是基于proxy层的，优点在于各个项目是透明的，直接访问中间件就可以了，升级维护啥的自己在中间件那里搞就行了。缺点是需要部署，自己维护一套中间件，运维成本高。</p>\n<h2 id=\"不同的中间件有什么优缺点？\"><a href=\"#不同的中间件有什么优缺点？\" class=\"headerlink\" title=\"不同的中间件有什么优缺点？\"></a>不同的中间件有什么优缺点？</h2><p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbthfnw403j30yk070k3g.jpg\" alt></p>\n<hr>\n<h2 id=\"如何把单库单表的系统迁移到分库分表？\"><a href=\"#如何把单库单表的系统迁移到分库分表？\" class=\"headerlink\" title=\"如何把单库单表的系统迁移到分库分表？\"></a>如何把单库单表的系统迁移到分库分表？</h2><ol>\n<li><h3 id=\"停机迁移\"><a href=\"#停机迁移\" class=\"headerlink\" title=\"停机迁移\"></a>停机迁移</h3><p>发布公告，凌晨0点～2点维护系统，暂停使用。</p>\n<p>数据迁移，修改配置，验证测试。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbtrd56mz7j31400k84qp.jpg\" alt></p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><h3 id=\"不停机双写迁移\"><a href=\"#不停机双写迁移\" class=\"headerlink\" title=\"不停机双写迁移\"></a>不停机双写迁移</h3><p>通过修改配置实现在系统写入单库单表的同时，也将数据发送到mycat，往分库分表中写入数据。</p>\n<p>此时还会启动一个后台数据迁移临时工具来将历史数据同步到分库分表中，将历史数据写入分库分表前，先查询分库分表中是否存在，如果不存在，直接写入，如果存在，则通过查询比较两个数据的时间戳，将更新的数据保留在分库分表中。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbtrsa3jy3j31300n64qp.jpg\" alt></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"分库分表以后ID主键如何处理？\"><a href=\"#分库分表以后ID主键如何处理？\" class=\"headerlink\" title=\"分库分表以后ID主键如何处理？\"></a>分库分表以后ID主键如何处理？</h2><p>推荐使用Snowflake算法，这是 Twitter 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。</p>\n<p>其核心思想是：生成一个64位的long型ID，其中第一位是符号位0，后面使用 41bit 作为毫秒数，10bit 作为机器的 ID(5 个 bit 是数据中心(机房)，5 个 bit 的机器 ID)，12bit 作为毫秒内的流水号(意味着每个节点在每毫秒可以产生 4096 个 ID)。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbushxzxnlj30go05bdg1.jpg\" alt></p>\n<hr>\n<h2 id=\"如何实现mysql的读写分离？\"><a href=\"#如何实现mysql的读写分离？\" class=\"headerlink\" title=\"如何实现mysql的读写分离？\"></a>如何实现mysql的读写分离？</h2><p>其实很简单，就是基于主从复制架构，搞一个主库，挂多个从库，我们单单只是写主库，主库会自动把数据同步到从库上去，从库只负责读，借此来分担数据库读压力。</p>\n<h2 id=\"mysql主从复制的原理？\"><a href=\"#mysql主从复制的原理？\" class=\"headerlink\" title=\"mysql主从复制的原理？\"></a>mysql主从复制的原理？</h2><ol>\n<li>mysql里有一个概念-binlog日志，每个增删改操作在操作数据的同时，还会维护一个日志文件，记录这些操作。</li>\n<li>从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入relay(中继)日志中。</li>\n<li>接着从库中有一个SQL线程会从relay日志中读取binlog日志，然后执行其中的内容，使主从数据保持一致。</li>\n</ol>\n<p><strong>需要注意的问题（数据延迟和数据丢失）</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbvrsjdv6wj316c0dcwvw.jpg\" alt></p>\n<ol>\n<li>从库同步主库的过程是串行化的，也就是说主库上并行的操作在从库上会串行执行。</li>\n<li>由于从库拷贝主库日志以及串行执行的特点，在高并发的场景下，从库的数据同步会有延迟。</li>\n<li>如果主库突然宕机，数据恰好还没同步到从库，导致有些数据在从库里是没有的，造成数据丢失。</li>\n</ol>\n<p><strong>如何解决？</strong></p>\n<p>mysql在这一块有两个机制，一个是<strong>半同步复制</strong>，解决数据丢失问题。一个是<strong>并行复制</strong>，缓解数据延时问题。</p>\n<ul>\n<li>所谓半同步复制（semi-sync）指的就是主库写入binlog日志后，就会立即将数据同步到从库。从库将日志写入到relay日志后，会返回ack给主库，主库收到至少一个ack之后才会认为写操作完成了。</li>\n<li>所谓并行复制，指的是从库开启多个SQL线程，并行读取relay日志进行多库并发重放，有必要让DBA开启并行复制，不过并行复制的意义并不大，并发高了以后生产环境还会有延时问题。</li>\n</ul>\n<p><strong>有没有更好的方法解决主从数据延时问题（重点）</strong></p>\n<ol>\n<li>分库，把一个主库拆分成多个主库，降低主库的写并发，使得延迟时间可以忽略不计。</li>\n<li>重写代码，插入数据成功后直接修改数据，不要查询（因为修改数据在主库，查询在从库）。</li>\n<li>如果确实存在数据写入后立马就要查到，可以对这个查询设置直连主库（不推荐，失去读写分离的意义）。</li>\n</ol>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>因为数据量的上升，为了提高性能会对系统进行分表分库。</li>\n<li>从分表来说，有水平分表和垂直分表两种方式。</li>\n<li>从分库来说，可以根据业务，冷热数据等来进行分库，分库以后通过主从库来实现读写分离。</li>\n<li>如果对分库之后数据库做扩容，有两种方式，主从数据库扩容和双写数据库扩容。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"为什么要分库分表？\"><a href=\"#为什么要分库分表？\" class=\"headerlink\" title=\"为什么要分库分表？\"></a>为什么要分库分表？</h2><ul>\n<li><p>数据库的数据会随着业务的发展而不断增多，对数据操作的开销也会越来越大。</p>\n</li>\n<li><p>物理服务器的资源有限（CPU、磁盘、内存、IO）最终数据库所能承载的数据量和数据处理能力遇到瓶颈。</p>\n<p>换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。</p>\n<p>比如单表数据量太大（500w以上），会极大的影响SQL的执行性能。","more":"</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"如何进行分库分表？\"><a href=\"#如何进行分库分表？\" class=\"headerlink\" title=\"如何进行分库分表？\"></a>如何进行分库分表？</h2><h3 id=\"数据分表\"><a href=\"#数据分表\" class=\"headerlink\" title=\"数据分表\"></a>数据分表</h3><ul>\n<li><h4 id=\"垂直分表\"><a href=\"#垂直分表\" class=\"headerlink\" title=\"垂直分表\"></a>垂直分表</h4><p>根据业务把一个表中的字段(Field)分到不同的表中。这些被分出去的数据通常根据业务需要，例如分出去一些不是经常使用的字段，一些长度较长的字段。一般被拆分的表的字段数比较多。<strong>主要是避免查询的时候出现因为数据量大而造成的“跨页”问题。</strong></p>\n<p>垂直拆分在数据库设计之初就会考虑，尽量在系统上线之前调整。已经上线的项目，做这种操作是要慎重考虑的。</p>\n</li>\n<li><h4 id=\"水平分表\"><a href=\"#水平分表\" class=\"headerlink\" title=\"水平分表\"></a>水平分表</h4><p>将一个表中的数据，按照关键字(例如：ID)对一个具体的数字取模，得到的余数就是需要存放到的新表的位置。</p>\n<p>水平分表就是把一个表里的数据分配到多个表里去，但是每个库的表结构一样，只不过每个库表存放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义就是将数据均匀的放到更多的库里，然后用更多的库来抗更高的并发，还可以通过多个库的容量来扩容。</p>\n</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbtin7sm0xj31tc0quhdv.jpg\" alt></p>\n<h3 id=\"数据分库\"><a href=\"#数据分库\" class=\"headerlink\" title=\"数据分库\"></a>数据分库</h3><p>每个物理数据库支持数据都是有限的，每一次的数据库请求都会产生一次数据库链接，当一个库无法支持更多访问的时候，我们会把原来的单个数据库分成多个，帮助分担压力。</p>\n<ul>\n<li>根据业务不同分库，这种情况都会把主营业务和其他功能分开。例如可以分为订单数据库，核算数据库，评论数据库。</li>\n<li>根据冷热数据进行分库，用数据访问频率来划分，例如：近一个月的交易数据属于高频数据，2-6 个月的交易数据属于中频数据，大于 6 个月的数据属于低频数据。</li>\n<li>根据访问数据的地域/时间范围进行分库。</li>\n</ul>\n<p><strong>range和hash的优缺点</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbtiwjec6pj30yw09418a.jpg\" alt></p>\n<p><strong>分库分表会遇到哪些问题</strong></p>\n<ul>\n<li><p>ID：主键不可以使用 UUID，性能太差，如果是文件名啥的可以用，不依赖数据库直接在系统中生成，即UUID.randomUUID().toString.replace(“-“,””)，UUID 实现起来比较方便，但是占用的空间比较大；可以用数据库自增ID，即通过一张表来存放生成的 Sequence，不过效率都不算高。Sequence 表的方式节省了空间，但是单表性能瓶颈，且所有的 ID 都依赖于单表。这里推荐使用snowflake算法。</p>\n</li>\n<li><p>Join：需要做两次查询，把两次查询的结果在应用层做合并。这种做法是最简单的，在应用层设计的时候需要考虑。</p>\n</li>\n<li><p>排序/分页：数据分配到水平的几个表中的时候，做排序和分页或者一些集合操作是不容易的。这里根据经验介绍两种方法。</p>\n<ol>\n<li><p>对分表的数据先进行排序/分页/聚合，再进行合并。</p>\n</li>\n<li><p>对分表的数据先进行合并再做排序/分页/聚合。</p>\n</li>\n</ol>\n</li>\n<li><p>事务：存在分布式事务的可能，需要考虑补偿事务或者用 TCC(Try Confirm Cancel)协助完成。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"如何对数据库进行扩容？\"><a href=\"#如何对数据库进行扩容？\" class=\"headerlink\" title=\"如何对数据库进行扩容？\"></a>如何对数据库进行扩容？</h2><p>分库之后的数据库会遇到数据扩容或者数据迁移的情况。这里推荐两种数据库扩容的方案。</p>\n<ul>\n<li><h3 id=\"主从数据库扩容\"><a href=\"#主从数据库扩容\" class=\"headerlink\" title=\"主从数据库扩容\"></a>主从数据库扩容</h3><p>我们这里假设有两个数据库集群，每个集群分别有 M1 S1 和 M2 S2 互为主备。</p>\n<p>由于 M1 和 S1 互为主备所以数据是一样的，M2 和 S2 同样。把原有的 ID %2 模式切换成 ID %4 模式，也就是把两个数据集群扩充到 4 个数据库集群。</p>\n<p>负载均衡器直接把数据路由到原来两个 S1 和 S2 上面，同时 S1 和 S2 会停止与 M1 和 M2 的数据同步，单独作为主库(写操作)存在。</p>\n<p>这些修改不需要重启数据库服务，只需要修改代理配置就可以完成。由于 M1 M2 S1 S2 中会存在一些冗余的数据，可以后台起服务将这些冗余数据删除，不会影响数据使用。</p>\n<p>此时，再考虑数据库可用性，将扩展后的 4 个主库进行主备操作，针对每个主库都建立对应的从库，前者负责写操作，后者负责读操作。下次如果需要扩容也可以按照类似的操作进行。</p>\n</li>\n<li><h3 id=\"双写数据库扩容\"><a href=\"#双写数据库扩容\" class=\"headerlink\" title=\"双写数据库扩容\"></a>双写数据库扩容</h3><p>在没有数据库主从配置的情况下的扩容，假设有数据库 M1 M2，需要对目前的两个数据库做扩容，扩容之后是 4 个库。新增的库是 M3，M4 路由的方式分别是 ID%2=0 和 ID%2=1。</p>\n<p>这个时候新的数据会同时进入 M1 M2 M3 M4 四个库中，而老数据的使用依旧从 M1 M2 中获取。</p>\n<p>与此同时，后台服务对 M1 M3，M2 M4 做数据同步，建议先做全量同步再做数据校验。</p>\n<p>当完成数据同步之后，四个库的数据保持一致了，修改负载均衡代理的配置为 ID%4 的模式。此时扩容就完成了，从原来的 2 个数据库扩展成 4 个数据库。</p>\n<p>当然会存在部分的数据冗余，需要像上面一个方案一样通过后台服务删除这些冗余数据，删除的过程不会影响业务。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"用过哪些分库分表的中间件？\"><a href=\"#用过哪些分库分表的中间件？\" class=\"headerlink\" title=\"用过哪些分库分表的中间件？\"></a>用过哪些分库分表的中间件？</h2><p><strong>sharding-jdbc 和 mycat</strong>。</p>\n<p>sharding-jdbc是基于client层的，优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高。缺点是如果遇到升级啥的需要各个系统都重新升级再发布。</p>\n<p>mycat是基于proxy层的，优点在于各个项目是透明的，直接访问中间件就可以了，升级维护啥的自己在中间件那里搞就行了。缺点是需要部署，自己维护一套中间件，运维成本高。</p>\n<h2 id=\"不同的中间件有什么优缺点？\"><a href=\"#不同的中间件有什么优缺点？\" class=\"headerlink\" title=\"不同的中间件有什么优缺点？\"></a>不同的中间件有什么优缺点？</h2><p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbthfnw403j30yk070k3g.jpg\" alt></p>\n<hr>\n<h2 id=\"如何把单库单表的系统迁移到分库分表？\"><a href=\"#如何把单库单表的系统迁移到分库分表？\" class=\"headerlink\" title=\"如何把单库单表的系统迁移到分库分表？\"></a>如何把单库单表的系统迁移到分库分表？</h2><ol>\n<li><h3 id=\"停机迁移\"><a href=\"#停机迁移\" class=\"headerlink\" title=\"停机迁移\"></a>停机迁移</h3><p>发布公告，凌晨0点～2点维护系统，暂停使用。</p>\n<p>数据迁移，修改配置，验证测试。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbtrd56mz7j31400k84qp.jpg\" alt></p>\n</li>\n</ol>\n<ol start=\"2\">\n<li><h3 id=\"不停机双写迁移\"><a href=\"#不停机双写迁移\" class=\"headerlink\" title=\"不停机双写迁移\"></a>不停机双写迁移</h3><p>通过修改配置实现在系统写入单库单表的同时，也将数据发送到mycat，往分库分表中写入数据。</p>\n<p>此时还会启动一个后台数据迁移临时工具来将历史数据同步到分库分表中，将历史数据写入分库分表前，先查询分库分表中是否存在，如果不存在，直接写入，如果存在，则通过查询比较两个数据的时间戳，将更新的数据保留在分库分表中。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbtrsa3jy3j31300n64qp.jpg\" alt></p>\n</li>\n</ol>\n<hr>\n<h2 id=\"分库分表以后ID主键如何处理？\"><a href=\"#分库分表以后ID主键如何处理？\" class=\"headerlink\" title=\"分库分表以后ID主键如何处理？\"></a>分库分表以后ID主键如何处理？</h2><p>推荐使用Snowflake算法，这是 Twitter 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。</p>\n<p>其核心思想是：生成一个64位的long型ID，其中第一位是符号位0，后面使用 41bit 作为毫秒数，10bit 作为机器的 ID(5 个 bit 是数据中心(机房)，5 个 bit 的机器 ID)，12bit 作为毫秒内的流水号(意味着每个节点在每毫秒可以产生 4096 个 ID)。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbushxzxnlj30go05bdg1.jpg\" alt></p>\n<hr>\n<h2 id=\"如何实现mysql的读写分离？\"><a href=\"#如何实现mysql的读写分离？\" class=\"headerlink\" title=\"如何实现mysql的读写分离？\"></a>如何实现mysql的读写分离？</h2><p>其实很简单，就是基于主从复制架构，搞一个主库，挂多个从库，我们单单只是写主库，主库会自动把数据同步到从库上去，从库只负责读，借此来分担数据库读压力。</p>\n<h2 id=\"mysql主从复制的原理？\"><a href=\"#mysql主从复制的原理？\" class=\"headerlink\" title=\"mysql主从复制的原理？\"></a>mysql主从复制的原理？</h2><ol>\n<li>mysql里有一个概念-binlog日志，每个增删改操作在操作数据的同时，还会维护一个日志文件，记录这些操作。</li>\n<li>从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入relay(中继)日志中。</li>\n<li>接着从库中有一个SQL线程会从relay日志中读取binlog日志，然后执行其中的内容，使主从数据保持一致。</li>\n</ol>\n<p><strong>需要注意的问题（数据延迟和数据丢失）</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/0082zybply1gbvrsjdv6wj316c0dcwvw.jpg\" alt></p>\n<ol>\n<li>从库同步主库的过程是串行化的，也就是说主库上并行的操作在从库上会串行执行。</li>\n<li>由于从库拷贝主库日志以及串行执行的特点，在高并发的场景下，从库的数据同步会有延迟。</li>\n<li>如果主库突然宕机，数据恰好还没同步到从库，导致有些数据在从库里是没有的，造成数据丢失。</li>\n</ol>\n<p><strong>如何解决？</strong></p>\n<p>mysql在这一块有两个机制，一个是<strong>半同步复制</strong>，解决数据丢失问题。一个是<strong>并行复制</strong>，缓解数据延时问题。</p>\n<ul>\n<li>所谓半同步复制（semi-sync）指的就是主库写入binlog日志后，就会立即将数据同步到从库。从库将日志写入到relay日志后，会返回ack给主库，主库收到至少一个ack之后才会认为写操作完成了。</li>\n<li>所谓并行复制，指的是从库开启多个SQL线程，并行读取relay日志进行多库并发重放，有必要让DBA开启并行复制，不过并行复制的意义并不大，并发高了以后生产环境还会有延时问题。</li>\n</ul>\n<p><strong>有没有更好的方法解决主从数据延时问题（重点）</strong></p>\n<ol>\n<li>分库，把一个主库拆分成多个主库，降低主库的写并发，使得延迟时间可以忽略不计。</li>\n<li>重写代码，插入数据成功后直接修改数据，不要查询（因为修改数据在主库，查询在从库）。</li>\n<li>如果确实存在数据写入后立马就要查到，可以对这个查询设置直连主库（不推荐，失去读写分离的意义）。</li>\n</ol>\n<hr>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>因为数据量的上升，为了提高性能会对系统进行分表分库。</li>\n<li>从分表来说，有水平分表和垂直分表两种方式。</li>\n<li>从分库来说，可以根据业务，冷热数据等来进行分库，分库以后通过主从库来实现读写分离。</li>\n<li>如果对分库之后数据库做扩容，有两种方式，主从数据库扩容和双写数据库扩容。</li>\n</ul>"},{"title":"Git相关","date":"2018-05-13T14:10:27.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## 什么是 Git\n\nGit是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git是Linus Torvalds 为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。\n\n## Git 的特点\n\n分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone）在本地机器上拷贝一个完整的Git仓库。从一般开发者的角度来看，git有以下功能：\n\n从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上、在自己的机器上根据不同的开发目的，创建分支，修改代码、在单机上自己创建的分支上提交代码、在单机上合并分支、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并等。\n\n<!-- more -->\n\n- 优点\n\n适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。\n\n- 缺点\n\n资料少（起码中文资料很少）。学习周期相对而言比较长。不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有码和版本信息。因其资料的公开性，导致大型商业化工程几乎不会使用GIT来托管工程版本信息（除非搭建企业私服）。\n\n## Git 创建仓库\n\n### git init\n\nGit 使用 **git init** 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 **git init** 是使用 Git 的第一个命令。在执行完成 **git init** 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。\n\n**使用方法**\n\n使用当前目录作为Git仓库，我们只需使它初始化。\n\n```\ngit init\n```\n\n该命令执行完后会在当前目录生成一个 .git 目录。\n\n使用我们指定目录作为Git仓库。\n\n```\ngit init newrepo\n```\n\n初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。\n\n如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：\n\n```\n$ git add *.c\n$ git add README\n$ git commit -m '初始化项目版本'\n```\n\n以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。\n\n------\n\n### git clone\n\n我们使用 **git clone** 从现有 Git 仓库中拷贝项目（类似 **svn checkout**）。\n\n克隆仓库的命令格式为：\n\n```\ngit clone <repo>\n```\n\n如果我们需要克隆到指定的目录，可以使用以下命令格式：\n\n```\ngit clone <repo> <directory>\n```\n\n**参数说明：**\n\n- **repo:** Git 仓库。\n- **directory:** 本地目录。\n\n比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：\n\n```\n$ git clone git://github.com/schacon/grit.git\n```\n\n执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。\n\n如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：\n\n```\n$ git clone git://github.com/schacon/grit.git mygrit\n```\n\n## Git 基本操作\n\n### git add\n\ngit add 命令可将文件添加到缓存\n\n### git status\n\ngit status 命令可以查看当前的提交状态\n\n```xml\n➜  lishaojie.github.io git:(master) ✗ git status -s\n m themes/melody\n?? source/_posts/git.md\n```\n\n### git diff\n\ngit diff 命令可以查看文件具体哪里做了改动\n\n### git commit\n\ngit commit 命令可以把缓存区的内容提交到本地仓库\n\n### git reset\n\ngit reset 命令可以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存\n\n### git rm\n\n如果只是简单地从工作目录中手工删除文件，运行 **git status** 时就会在 **Changes not staged for commit** 的提示。\n\n要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作\n\n```\ngit rm <file>\n```\n\n如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 **-f**\n\n```\ngit rm -f <file>\n```\n\n如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 **--cached** 选项即可\n\n```\ngit rm --cached <file>\n```\n\n如我们删除 hello.php文件：\n\n```\n$ git rm hello.php \nrm 'hello.php'\n$ ls\nREADME\n```\n\n不从工作区中删除文件：\n\n```\n$ git rm --cached README \nrm 'README'\n$ ls\nREADME\n```\n\n可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：\n\n```\ngit rm –r * \n```\n\n进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录\n\n### git mv\n\ngit mv 命令用于移动或重命名一个文件、目录、软连接\n\n## Git 分支管理\n\n### 创建分支\n\n```\ngit branch (branchname)\n```\n\n### 切换分支\n\n```\ngit checkout (branchname)\n```\n\n当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。\n\n### 列出分支\n\n```\ngit branch\n```\n\n没有参数时，**git branch** 会列出你在本地的分支。\n\n```\n$ git branch\n* master\n```\n\n此例的意思就是，我们有一个叫做 **master** 的分支，并且该分支是当前分支。\n\n当你执行 **git init** 的时候，默认情况下 Git 就会为你创建 **master** 分支。\n\n如果我们要手动创建一个分支。执行 **git branch (branchname)** 即可。\n\n```\n$ git branch testing\n$ git branch\n* master\n  testing\n```\n\n现在我们可以看到，有了一个新分支 **testing**。\n\n当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 **testing** 分支，Git 将还原你的工作目录到你创建分支时候的样子。\n\n接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。\n\n```\n$ ls\nREADME\n$ echo 'runoob.com' > test.txt\n$ git add .\n$ git commit -m 'add test.txt'\n[master 3e92c19] add test.txt\n 1 file changed, 1 insertion(+)\n create mode 100644 test.txt\n$ ls\nREADME        test.txt\n$ git checkout testing\nSwitched to branch 'testing'\n$ ls\nREADME\n```\n\n当我们切换到 **testing** 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 **master** 分支的时候，它们有重新出现了。\n\n```\n$ git checkout master\nSwitched to branch 'master'\n$ ls\nREADME        test.txt\n```\n\n我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。\n\n```\n$ git checkout -b newtest\nSwitched to a new branch 'newtest'\n$ git rm test.txt \nrm 'test.txt'\n$ ls\nREADME\n$ touch runoob.php\n$ git add .\n$ git commit -am 'removed test.txt、add runoob.php'\n[newtest c1501a2] removed test.txt、add runoob.php\n 2 files changed, 1 deletion(-)\n create mode 100644 runoob.php\n delete mode 100644 test.txt\n$ ls\nREADME        runoob.php\n$ git checkout master\nSwitched to branch 'master'\n$ ls\nREADME        test.txt\n```\n\n如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。\n\n使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。\n\n### 删除分支\n\n删除分支命令：\n\n```\ngit branch -d (branchname)\n```\n\n例如我们要删除 testing 分支：\n\n```\n$ git branch\n* master\n  testing\n$ git branch -d testing\nDeleted branch testing (was 85fc7e7).\n$ git branch\n* master\n```\n\n### 分支合并\n\n一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：\n\n```\ngit merge\n$ git branch\n* master\n  newtest\n$ ls\nREADME        test.txt\n$ git merge newtest\nUpdating 3e92c19..c1501a2\nFast-forward\n runoob.php | 0\n test.txt   | 1 -\n 2 files changed, 1 deletion(-)\n create mode 100644 runoob.php\n delete mode 100644 test.txt\n$ ls\nREADME        runoob.php\n```\n\n以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。\n\n合并完后就可以删除分支:\n\n```\n$ git branch -d newtest\nDeleted branch newtest (was c1501a2).\n```\n\n删除后， 就只剩下 master 分支了：\n\n```\n$ git branch\n* master\n```\n\n### 合并冲突\n\n合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。\n\n```\n$ git branch\n* master\n$ cat runoob.php\n```\n\n首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:\n\n```\n<?php\necho 'runoob';\n?>\n```\n\n创建 change_site 分支：\n\n```\n$ git checkout -b change_site\nSwitched to a new branch 'change_site'\n$ vim runoob.php\n$ head -3 runoob.php\n<?php\necho 'runoob';\n?>\n$ git commit -am 'changed the runoob.php'\n[change_site 7774248] changed the runoob.php\n 1 file changed, 3 insertions(+)\n \n```\n\n将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。\n\n```\n$ git checkout master\nSwitched to branch 'master'\n$ cat runoob.php\n$ vim runoob.php    # 修改内容如下\n$ cat runoob.php\n<?php\necho 1;\n?>\n$ git diff\ndiff --git a/runoob.php b/runoob.php\nindex e69de29..ac60739 100644\n--- a/runoob.php\n+++ b/runoob.php\n@@ -0,0 +1,3 @@\n+<?php\n+echo 1;\n+?>\n$ git commit -am '修改代码'\n[master c68142b] 修改代码\n 1 file changed, 3 insertions(+)\n```\n\n现在这些改变已经记录到我的 \"master\" 分支了。接下来我们将 \"change_site\" 分支合并过来。\n\n```\n$ git merge change_site\nAuto-merging runoob.php\nCONFLICT (content): Merge conflict in runoob.php\nAutomatic merge failed; fix conflicts and then commit the result.\n\n$ cat runoob.php     # 代开文件，看到冲突内容\n<?php\n<<<<<<< HEAD\necho 1;\n=======\necho 'runoob';\n>>>>>>> change_site\n?>\n```\n\n我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。\n\n```\n$ vim runoob.php \n$ cat runoob.php\n<?php\necho 1;\necho 'runoob';\n?>\n$ git diff\ndiff --cc runoob.php\nindex ac60739,b63d7d7..0000000\n--- a/runoob.php\n+++ b/runoob.php\n@@@ -1,3 -1,3 +1,4 @@@\n  <?php\n +echo 1;\n+ echo 'runoob';\n  ?>\n```\n\n在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决\n\n```\n$ git status -s\nUU runoob.php\n$ git add runoob.php\n$ git status -s\nM  runoob.php\n$ git commit\n[master 88afe0e] Merge branch 'change_site'\n```\n\n现在我们成功解决了合并中的冲突，并提交了结果。\n\n## Git 查看提交历史\n\n在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。\n\n针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：\n\n```\n$ git log\ncommit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -> master)\nMerge: c68142b 7774248\nAuthor: runoob <test@runoob.com>\nDate:   Fri May 3 15:55:58 2019 +0800\n\n    Merge branch 'change_site'\n\ncommit c68142b562c260c3071754623b08e2657b4c6d5b\nAuthor: runoob <test@runoob.com>\nDate:   Fri May 3 15:52:12 2019 +0800\n\n    修改代码\n\ncommit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)\nAuthor: runoob <test@runoob.com>\nDate:   Fri May 3 15:49:26 2019 +0800\n\n    changed the runoob.php\n\ncommit c1501a244676ff55e7cccac1ecac0e18cbf6cb00\nAuthor: runoob <test@runoob.com>\nDate:   Fri May 3 15:35:32 2019 +0800\n```\n\n我们可以用 --oneline 选项来查看历史记录的简洁的版本。\n\n```\n$ git log --oneline\n$ git log --oneline\nd5e9fc2 (HEAD -> master) Merge branch 'change_site'\nc68142b 修改代码\n7774248 (change_site) changed the runoob.php\nc1501a2 removed test.txt、add runoob.php\n3e92c19 add test.txt\n3b58100 第一次版本提交\n```\n\n这告诉我们的是，此项目的开发历史。\n\n我们还可以用 --graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：\n\n```\n*   d5e9fc2 (HEAD -> master) Merge branch 'change_site'\n|\\  \n| * 7774248 (change_site) changed the runoob.php\n* | c68142b 修改代码\n|/  \n* c1501a2 removed test.txt、add runoob.php\n* 3e92c19 add test.txt\n* 3b58100 第一次版本提交\n```\n\n现在我们可以更清楚明了地看到何时工作分叉、又何时归并。\n\n你也可以用 **--reverse** 参数来逆向显示所有日志。\n\n```\n$ git log --reverse --oneline\n3b58100 第一次版本提交\n3e92c19 add test.txt\nc1501a2 removed test.txt、add runoob.php\n7774248 (change_site) changed the runoob.php\nc68142b 修改代码\nd5e9fc2 (HEAD -> master) Merge branch 'change_site'\n```\n\n如果只想查找指定用户的提交日志可以使用命令：git log --author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：\n\n```\n$ git log --author=Linus --oneline -5\n81b50f3 Move 'builtin-*' into a 'builtin/' subdirectory\n3bb7256 make \"index-pack\" a built-in\n377d027 make \"git pack-redundant\" a built-in\nb532581 make \"git unpack-file\" a built-in\n112dd51 make \"mktag\" a built-in\n```\n\n如果你要指定日期，可以执行几个选项：--since 和 --before，但是你也可以用 --until 和 --after。\n\n例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 --no-merges 选项以隐藏合并提交）：\n\n```\n$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges\n5469e2d Git 1.7.1-rc2\nd43427d Documentation/remote-helpers: Fix typos and improve language\n272a36b Fixup: Second argument may be any arbitrary string\nb6c8d2d Documentation/remote-helpers: Add invocation section\n5ce4f4e Documentation/urls: Rewrite to accomodate transport::address\n00b84e9 Documentation/remote-helpers: Rewrite description\n03aa87e Documentation: Describe other situations where -z affects git diff\n77bc694 rebase-interactive: silence warning when no commits rewritten\n636db2c t3301: add tests to use --format=\"%N\"\n```","source":"_posts/git.md","raw":"---\ntitle: Git相关\ndate: 2018-05-13 22:10:27\ncategories: Java\ntags:\n  - version control\n  - git\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## 什么是 Git\n\nGit是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git是Linus Torvalds 为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。\n\n## Git 的特点\n\n分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone）在本地机器上拷贝一个完整的Git仓库。从一般开发者的角度来看，git有以下功能：\n\n从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上、在自己的机器上根据不同的开发目的，创建分支，修改代码、在单机上自己创建的分支上提交代码、在单机上合并分支、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并等。\n\n<!-- more -->\n\n- 优点\n\n适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。\n\n- 缺点\n\n资料少（起码中文资料很少）。学习周期相对而言比较长。不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有码和版本信息。因其资料的公开性，导致大型商业化工程几乎不会使用GIT来托管工程版本信息（除非搭建企业私服）。\n\n## Git 创建仓库\n\n### git init\n\nGit 使用 **git init** 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 **git init** 是使用 Git 的第一个命令。在执行完成 **git init** 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。\n\n**使用方法**\n\n使用当前目录作为Git仓库，我们只需使它初始化。\n\n```\ngit init\n```\n\n该命令执行完后会在当前目录生成一个 .git 目录。\n\n使用我们指定目录作为Git仓库。\n\n```\ngit init newrepo\n```\n\n初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。\n\n如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：\n\n```\n$ git add *.c\n$ git add README\n$ git commit -m '初始化项目版本'\n```\n\n以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。\n\n------\n\n### git clone\n\n我们使用 **git clone** 从现有 Git 仓库中拷贝项目（类似 **svn checkout**）。\n\n克隆仓库的命令格式为：\n\n```\ngit clone <repo>\n```\n\n如果我们需要克隆到指定的目录，可以使用以下命令格式：\n\n```\ngit clone <repo> <directory>\n```\n\n**参数说明：**\n\n- **repo:** Git 仓库。\n- **directory:** 本地目录。\n\n比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：\n\n```\n$ git clone git://github.com/schacon/grit.git\n```\n\n执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。\n\n如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：\n\n```\n$ git clone git://github.com/schacon/grit.git mygrit\n```\n\n## Git 基本操作\n\n### git add\n\ngit add 命令可将文件添加到缓存\n\n### git status\n\ngit status 命令可以查看当前的提交状态\n\n```xml\n➜  lishaojie.github.io git:(master) ✗ git status -s\n m themes/melody\n?? source/_posts/git.md\n```\n\n### git diff\n\ngit diff 命令可以查看文件具体哪里做了改动\n\n### git commit\n\ngit commit 命令可以把缓存区的内容提交到本地仓库\n\n### git reset\n\ngit reset 命令可以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存\n\n### git rm\n\n如果只是简单地从工作目录中手工删除文件，运行 **git status** 时就会在 **Changes not staged for commit** 的提示。\n\n要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作\n\n```\ngit rm <file>\n```\n\n如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 **-f**\n\n```\ngit rm -f <file>\n```\n\n如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 **--cached** 选项即可\n\n```\ngit rm --cached <file>\n```\n\n如我们删除 hello.php文件：\n\n```\n$ git rm hello.php \nrm 'hello.php'\n$ ls\nREADME\n```\n\n不从工作区中删除文件：\n\n```\n$ git rm --cached README \nrm 'README'\n$ ls\nREADME\n```\n\n可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：\n\n```\ngit rm –r * \n```\n\n进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录\n\n### git mv\n\ngit mv 命令用于移动或重命名一个文件、目录、软连接\n\n## Git 分支管理\n\n### 创建分支\n\n```\ngit branch (branchname)\n```\n\n### 切换分支\n\n```\ngit checkout (branchname)\n```\n\n当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。\n\n### 列出分支\n\n```\ngit branch\n```\n\n没有参数时，**git branch** 会列出你在本地的分支。\n\n```\n$ git branch\n* master\n```\n\n此例的意思就是，我们有一个叫做 **master** 的分支，并且该分支是当前分支。\n\n当你执行 **git init** 的时候，默认情况下 Git 就会为你创建 **master** 分支。\n\n如果我们要手动创建一个分支。执行 **git branch (branchname)** 即可。\n\n```\n$ git branch testing\n$ git branch\n* master\n  testing\n```\n\n现在我们可以看到，有了一个新分支 **testing**。\n\n当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 **testing** 分支，Git 将还原你的工作目录到你创建分支时候的样子。\n\n接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。\n\n```\n$ ls\nREADME\n$ echo 'runoob.com' > test.txt\n$ git add .\n$ git commit -m 'add test.txt'\n[master 3e92c19] add test.txt\n 1 file changed, 1 insertion(+)\n create mode 100644 test.txt\n$ ls\nREADME        test.txt\n$ git checkout testing\nSwitched to branch 'testing'\n$ ls\nREADME\n```\n\n当我们切换到 **testing** 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 **master** 分支的时候，它们有重新出现了。\n\n```\n$ git checkout master\nSwitched to branch 'master'\n$ ls\nREADME        test.txt\n```\n\n我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。\n\n```\n$ git checkout -b newtest\nSwitched to a new branch 'newtest'\n$ git rm test.txt \nrm 'test.txt'\n$ ls\nREADME\n$ touch runoob.php\n$ git add .\n$ git commit -am 'removed test.txt、add runoob.php'\n[newtest c1501a2] removed test.txt、add runoob.php\n 2 files changed, 1 deletion(-)\n create mode 100644 runoob.php\n delete mode 100644 test.txt\n$ ls\nREADME        runoob.php\n$ git checkout master\nSwitched to branch 'master'\n$ ls\nREADME        test.txt\n```\n\n如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。\n\n使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。\n\n### 删除分支\n\n删除分支命令：\n\n```\ngit branch -d (branchname)\n```\n\n例如我们要删除 testing 分支：\n\n```\n$ git branch\n* master\n  testing\n$ git branch -d testing\nDeleted branch testing (was 85fc7e7).\n$ git branch\n* master\n```\n\n### 分支合并\n\n一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：\n\n```\ngit merge\n$ git branch\n* master\n  newtest\n$ ls\nREADME        test.txt\n$ git merge newtest\nUpdating 3e92c19..c1501a2\nFast-forward\n runoob.php | 0\n test.txt   | 1 -\n 2 files changed, 1 deletion(-)\n create mode 100644 runoob.php\n delete mode 100644 test.txt\n$ ls\nREADME        runoob.php\n```\n\n以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。\n\n合并完后就可以删除分支:\n\n```\n$ git branch -d newtest\nDeleted branch newtest (was c1501a2).\n```\n\n删除后， 就只剩下 master 分支了：\n\n```\n$ git branch\n* master\n```\n\n### 合并冲突\n\n合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。\n\n```\n$ git branch\n* master\n$ cat runoob.php\n```\n\n首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:\n\n```\n<?php\necho 'runoob';\n?>\n```\n\n创建 change_site 分支：\n\n```\n$ git checkout -b change_site\nSwitched to a new branch 'change_site'\n$ vim runoob.php\n$ head -3 runoob.php\n<?php\necho 'runoob';\n?>\n$ git commit -am 'changed the runoob.php'\n[change_site 7774248] changed the runoob.php\n 1 file changed, 3 insertions(+)\n \n```\n\n将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。\n\n```\n$ git checkout master\nSwitched to branch 'master'\n$ cat runoob.php\n$ vim runoob.php    # 修改内容如下\n$ cat runoob.php\n<?php\necho 1;\n?>\n$ git diff\ndiff --git a/runoob.php b/runoob.php\nindex e69de29..ac60739 100644\n--- a/runoob.php\n+++ b/runoob.php\n@@ -0,0 +1,3 @@\n+<?php\n+echo 1;\n+?>\n$ git commit -am '修改代码'\n[master c68142b] 修改代码\n 1 file changed, 3 insertions(+)\n```\n\n现在这些改变已经记录到我的 \"master\" 分支了。接下来我们将 \"change_site\" 分支合并过来。\n\n```\n$ git merge change_site\nAuto-merging runoob.php\nCONFLICT (content): Merge conflict in runoob.php\nAutomatic merge failed; fix conflicts and then commit the result.\n\n$ cat runoob.php     # 代开文件，看到冲突内容\n<?php\n<<<<<<< HEAD\necho 1;\n=======\necho 'runoob';\n>>>>>>> change_site\n?>\n```\n\n我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。\n\n```\n$ vim runoob.php \n$ cat runoob.php\n<?php\necho 1;\necho 'runoob';\n?>\n$ git diff\ndiff --cc runoob.php\nindex ac60739,b63d7d7..0000000\n--- a/runoob.php\n+++ b/runoob.php\n@@@ -1,3 -1,3 +1,4 @@@\n  <?php\n +echo 1;\n+ echo 'runoob';\n  ?>\n```\n\n在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决\n\n```\n$ git status -s\nUU runoob.php\n$ git add runoob.php\n$ git status -s\nM  runoob.php\n$ git commit\n[master 88afe0e] Merge branch 'change_site'\n```\n\n现在我们成功解决了合并中的冲突，并提交了结果。\n\n## Git 查看提交历史\n\n在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。\n\n针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：\n\n```\n$ git log\ncommit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -> master)\nMerge: c68142b 7774248\nAuthor: runoob <test@runoob.com>\nDate:   Fri May 3 15:55:58 2019 +0800\n\n    Merge branch 'change_site'\n\ncommit c68142b562c260c3071754623b08e2657b4c6d5b\nAuthor: runoob <test@runoob.com>\nDate:   Fri May 3 15:52:12 2019 +0800\n\n    修改代码\n\ncommit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)\nAuthor: runoob <test@runoob.com>\nDate:   Fri May 3 15:49:26 2019 +0800\n\n    changed the runoob.php\n\ncommit c1501a244676ff55e7cccac1ecac0e18cbf6cb00\nAuthor: runoob <test@runoob.com>\nDate:   Fri May 3 15:35:32 2019 +0800\n```\n\n我们可以用 --oneline 选项来查看历史记录的简洁的版本。\n\n```\n$ git log --oneline\n$ git log --oneline\nd5e9fc2 (HEAD -> master) Merge branch 'change_site'\nc68142b 修改代码\n7774248 (change_site) changed the runoob.php\nc1501a2 removed test.txt、add runoob.php\n3e92c19 add test.txt\n3b58100 第一次版本提交\n```\n\n这告诉我们的是，此项目的开发历史。\n\n我们还可以用 --graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：\n\n```\n*   d5e9fc2 (HEAD -> master) Merge branch 'change_site'\n|\\  \n| * 7774248 (change_site) changed the runoob.php\n* | c68142b 修改代码\n|/  \n* c1501a2 removed test.txt、add runoob.php\n* 3e92c19 add test.txt\n* 3b58100 第一次版本提交\n```\n\n现在我们可以更清楚明了地看到何时工作分叉、又何时归并。\n\n你也可以用 **--reverse** 参数来逆向显示所有日志。\n\n```\n$ git log --reverse --oneline\n3b58100 第一次版本提交\n3e92c19 add test.txt\nc1501a2 removed test.txt、add runoob.php\n7774248 (change_site) changed the runoob.php\nc68142b 修改代码\nd5e9fc2 (HEAD -> master) Merge branch 'change_site'\n```\n\n如果只想查找指定用户的提交日志可以使用命令：git log --author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：\n\n```\n$ git log --author=Linus --oneline -5\n81b50f3 Move 'builtin-*' into a 'builtin/' subdirectory\n3bb7256 make \"index-pack\" a built-in\n377d027 make \"git pack-redundant\" a built-in\nb532581 make \"git unpack-file\" a built-in\n112dd51 make \"mktag\" a built-in\n```\n\n如果你要指定日期，可以执行几个选项：--since 和 --before，但是你也可以用 --until 和 --after。\n\n例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 --no-merges 选项以隐藏合并提交）：\n\n```\n$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges\n5469e2d Git 1.7.1-rc2\nd43427d Documentation/remote-helpers: Fix typos and improve language\n272a36b Fixup: Second argument may be any arbitrary string\nb6c8d2d Documentation/remote-helpers: Add invocation section\n5ce4f4e Documentation/urls: Rewrite to accomodate transport::address\n00b84e9 Documentation/remote-helpers: Rewrite description\n03aa87e Documentation: Describe other situations where -z affects git diff\n77bc694 rebase-interactive: silence warning when no commits rewritten\n636db2c t3301: add tests to use --format=\"%N\"\n```","slug":"git","published":1,"updated":"2020-01-15T06:03:47.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bjv003ua6ybc54rojzy","content":"<h2 id=\"什么是-Git\"><a href=\"#什么是-Git\" class=\"headerlink\" title=\"什么是 Git\"></a>什么是 Git</h2><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git是Linus Torvalds 为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p>\n<h2 id=\"Git-的特点\"><a href=\"#Git-的特点\" class=\"headerlink\" title=\"Git 的特点\"></a>Git 的特点</h2><p>分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone）在本地机器上拷贝一个完整的Git仓库。从一般开发者的角度来看，git有以下功能：</p>\n<p>从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上、在自己的机器上根据不同的开发目的，创建分支，修改代码、在单机上自己创建的分支上提交代码、在单机上合并分支、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并等。</p>\n<a id=\"more\"></a>\n\n<ul>\n<li>优点</li>\n</ul>\n<p>适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>资料少（起码中文资料很少）。学习周期相对而言比较长。不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有码和版本信息。因其资料的公开性，导致大型商业化工程几乎不会使用GIT来托管工程版本信息（除非搭建企业私服）。</p>\n<h2 id=\"Git-创建仓库\"><a href=\"#Git-创建仓库\" class=\"headerlink\" title=\"Git 创建仓库\"></a>Git 创建仓库</h2><h3 id=\"git-init\"><a href=\"#git-init\" class=\"headerlink\" title=\"git init\"></a>git init</h3><p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong> 是使用 Git 的第一个命令。在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p>\n<p><strong>使用方法</strong></p>\n<p>使用当前目录作为Git仓库，我们只需使它初始化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>该命令执行完后会在当前目录生成一个 .git 目录。</p>\n<p>使用我们指定目录作为Git仓库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init newrepo</span><br></pre></td></tr></table></figure>\n\n<p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>\n<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add *.c</span><br><span class=\"line\">$ git add README</span><br><span class=\"line\">$ git commit -m &apos;初始化项目版本&apos;</span><br></pre></td></tr></table></figure>\n\n<p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p>\n<hr>\n<h3 id=\"git-clone\"><a href=\"#git-clone\" class=\"headerlink\" title=\"git clone\"></a>git clone</h3><p>我们使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目（类似 <strong>svn checkout</strong>）。</p>\n<p>克隆仓库的命令格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数说明：</strong></p>\n<ul>\n<li><strong>repo:</strong> Git 仓库。</li>\n<li><strong>directory:</strong> 本地目录。</li>\n</ul>\n<p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure>\n\n<p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p>\n<p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Git-基本操作\"><a href=\"#Git-基本操作\" class=\"headerlink\" title=\"Git 基本操作\"></a>Git 基本操作</h2><h3 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h3><p>git add 命令可将文件添加到缓存</p>\n<h3 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h3><p>git status 命令可以查看当前的提交状态</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  lishaojie.github.io git:(master) ✗ git status -s</span><br><span class=\"line\"> m themes/melody</span><br><span class=\"line\">?? source/_posts/git.md</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h3><p>git diff 命令可以查看文件具体哪里做了改动</p>\n<h3 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h3><p>git commit 命令可以把缓存区的内容提交到本地仓库</p>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><p>git reset 命令可以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存</p>\n<h3 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h3><p>如果只是简单地从工作目录中手工删除文件，运行 <strong>git status</strong> 时就会在 <strong>Changes not staged for commit</strong> 的提示。</p>\n<p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm &lt;file&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <strong>-f</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -f &lt;file&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <strong>–cached</strong> 选项即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如我们删除 hello.php文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm hello.php </span><br><span class=\"line\">rm &apos;hello.php&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README</span><br></pre></td></tr></table></figure>\n\n<p>不从工作区中删除文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm --cached README </span><br><span class=\"line\">rm &apos;README&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README</span><br></pre></td></tr></table></figure>\n\n<p>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm –r *</span><br></pre></td></tr></table></figure>\n\n<p>进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录</p>\n<h3 id=\"git-mv\"><a href=\"#git-mv\" class=\"headerlink\" title=\"git mv\"></a>git mv</h3><p>git mv 命令用于移动或重命名一个文件、目录、软连接</p>\n<h2 id=\"Git-分支管理\"><a href=\"#Git-分支管理\" class=\"headerlink\" title=\"Git 分支管理\"></a>Git 分支管理</h2><h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch (branchname)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout (branchname)</span><br></pre></td></tr></table></figure>\n\n<p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p>\n<h3 id=\"列出分支\"><a href=\"#列出分支\" class=\"headerlink\" title=\"列出分支\"></a>列出分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n\n<p>没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n\n<p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p>\n<p>当你执行 <strong>git init</strong> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p>\n<p>如果我们要手动创建一个分支。执行 <strong>git branch (branchname)</strong> 即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch testing</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br><span class=\"line\">  testing</span><br></pre></td></tr></table></figure>\n\n<p>现在我们可以看到，有了一个新分支 <strong>testing</strong>。</p>\n<p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 <strong>testing</strong> 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p>\n<p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls</span><br><span class=\"line\">README</span><br><span class=\"line\">$ echo &apos;runoob.com&apos; &gt; test.txt</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m &apos;add test.txt&apos;</span><br><span class=\"line\">[master 3e92c19] add test.txt</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br><span class=\"line\"> create mode 100644 test.txt</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        test.txt</span><br><span class=\"line\">$ git checkout testing</span><br><span class=\"line\">Switched to branch &apos;testing&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README</span><br></pre></td></tr></table></figure>\n\n<p>当我们切换到 <strong>testing</strong> 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 <strong>master</strong> 分支的时候，它们有重新出现了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &apos;master&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        test.txt</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b newtest</span><br><span class=\"line\">Switched to a new branch &apos;newtest&apos;</span><br><span class=\"line\">$ git rm test.txt </span><br><span class=\"line\">rm &apos;test.txt&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README</span><br><span class=\"line\">$ touch runoob.php</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -am &apos;removed test.txt、add runoob.php&apos;</span><br><span class=\"line\">[newtest c1501a2] removed test.txt、add runoob.php</span><br><span class=\"line\"> 2 files changed, 1 deletion(-)</span><br><span class=\"line\"> create mode 100644 runoob.php</span><br><span class=\"line\"> delete mode 100644 test.txt</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        runoob.php</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &apos;master&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        test.txt</span><br></pre></td></tr></table></figure>\n\n<p>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p>\n<p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><p>删除分支命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d (branchname)</span><br></pre></td></tr></table></figure>\n\n<p>例如我们要删除 testing 分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br><span class=\"line\">  testing</span><br><span class=\"line\">$ git branch -d testing</span><br><span class=\"line\">Deleted branch testing (was 85fc7e7).</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h3><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br><span class=\"line\">  newtest</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        test.txt</span><br><span class=\"line\">$ git merge newtest</span><br><span class=\"line\">Updating 3e92c19..c1501a2</span><br><span class=\"line\">Fast-forward</span><br><span class=\"line\"> runoob.php | 0</span><br><span class=\"line\"> test.txt   | 1 -</span><br><span class=\"line\"> 2 files changed, 1 deletion(-)</span><br><span class=\"line\"> create mode 100644 runoob.php</span><br><span class=\"line\"> delete mode 100644 test.txt</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        runoob.php</span><br></pre></td></tr></table></figure>\n\n<p>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</p>\n<p>合并完后就可以删除分支:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d newtest</span><br><span class=\"line\">Deleted branch newtest (was c1501a2).</span><br></pre></td></tr></table></figure>\n\n<p>删除后， 就只剩下 master 分支了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并冲突\"><a href=\"#合并冲突\" class=\"headerlink\" title=\"合并冲突\"></a>合并冲突</h3><p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br><span class=\"line\">$ cat runoob.php</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo &apos;runoob&apos;;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>创建 change_site 分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b change_site</span><br><span class=\"line\">Switched to a new branch &apos;change_site&apos;</span><br><span class=\"line\">$ vim runoob.php</span><br><span class=\"line\">$ head -3 runoob.php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo &apos;runoob&apos;;</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">$ git commit -am &apos;changed the runoob.php&apos;</span><br><span class=\"line\">[change_site 7774248] changed the runoob.php</span><br><span class=\"line\"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure>\n\n<p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &apos;master&apos;</span><br><span class=\"line\">$ cat runoob.php</span><br><span class=\"line\">$ vim runoob.php    # 修改内容如下</span><br><span class=\"line\">$ cat runoob.php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo 1;</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">$ git diff</span><br><span class=\"line\">diff --git a/runoob.php b/runoob.php</span><br><span class=\"line\">index e69de29..ac60739 100644</span><br><span class=\"line\">--- a/runoob.php</span><br><span class=\"line\">+++ b/runoob.php</span><br><span class=\"line\">@@ -0,0 +1,3 @@</span><br><span class=\"line\">+&lt;?php</span><br><span class=\"line\">+echo 1;</span><br><span class=\"line\">+?&gt;</span><br><span class=\"line\">$ git commit -am &apos;修改代码&apos;</span><br><span class=\"line\">[master c68142b] 修改代码</span><br><span class=\"line\"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure>\n\n<p>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge change_site</span><br><span class=\"line\">Auto-merging runoob.php</span><br><span class=\"line\">CONFLICT (content): Merge conflict in runoob.php</span><br><span class=\"line\">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class=\"line\"></span><br><span class=\"line\">$ cat runoob.php     # 代开文件，看到冲突内容</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">echo 1;</span><br><span class=\"line\">=======</span><br><span class=\"line\">echo &apos;runoob&apos;;</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim runoob.php </span><br><span class=\"line\">$ cat runoob.php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo 1;</span><br><span class=\"line\">echo &apos;runoob&apos;;</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">$ git diff</span><br><span class=\"line\">diff --cc runoob.php</span><br><span class=\"line\">index ac60739,b63d7d7..0000000</span><br><span class=\"line\">--- a/runoob.php</span><br><span class=\"line\">+++ b/runoob.php</span><br><span class=\"line\">@@@ -1,3 -1,3 +1,4 @@@</span><br><span class=\"line\">  &lt;?php</span><br><span class=\"line\"> +echo 1;</span><br><span class=\"line\">+ echo &apos;runoob&apos;;</span><br><span class=\"line\">  ?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status -s</span><br><span class=\"line\">UU runoob.php</span><br><span class=\"line\">$ git add runoob.php</span><br><span class=\"line\">$ git status -s</span><br><span class=\"line\">M  runoob.php</span><br><span class=\"line\">$ git commit</span><br><span class=\"line\">[master 88afe0e] Merge branch &apos;change_site&apos;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们成功解决了合并中的冲突，并提交了结果。</p>\n<h2 id=\"Git-查看提交历史\"><a href=\"#Git-查看提交历史\" class=\"headerlink\" title=\"Git 查看提交历史\"></a>Git 查看提交历史</h2><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。</p>\n<p>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br><span class=\"line\">commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)</span><br><span class=\"line\">Merge: c68142b 7774248</span><br><span class=\"line\">Author: runoob &lt;test@runoob.com&gt;</span><br><span class=\"line\">Date:   Fri May 3 15:55:58 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    Merge branch &apos;change_site&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">commit c68142b562c260c3071754623b08e2657b4c6d5b</span><br><span class=\"line\">Author: runoob &lt;test@runoob.com&gt;</span><br><span class=\"line\">Date:   Fri May 3 15:52:12 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    修改代码</span><br><span class=\"line\"></span><br><span class=\"line\">commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)</span><br><span class=\"line\">Author: runoob &lt;test@runoob.com&gt;</span><br><span class=\"line\">Date:   Fri May 3 15:49:26 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    changed the runoob.php</span><br><span class=\"line\"></span><br><span class=\"line\">commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00</span><br><span class=\"line\">Author: runoob &lt;test@runoob.com&gt;</span><br><span class=\"line\">Date:   Fri May 3 15:35:32 2019 +0800</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --oneline</span><br><span class=\"line\">$ git log --oneline</span><br><span class=\"line\">d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;</span><br><span class=\"line\">c68142b 修改代码</span><br><span class=\"line\">7774248 (change_site) changed the runoob.php</span><br><span class=\"line\">c1501a2 removed test.txt、add runoob.php</span><br><span class=\"line\">3e92c19 add test.txt</span><br><span class=\"line\">3b58100 第一次版本提交</span><br></pre></td></tr></table></figure>\n\n<p>这告诉我们的是，此项目的开发历史。</p>\n<p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;</span><br><span class=\"line\">|\\  </span><br><span class=\"line\">| * 7774248 (change_site) changed the runoob.php</span><br><span class=\"line\">* | c68142b 修改代码</span><br><span class=\"line\">|/  </span><br><span class=\"line\">* c1501a2 removed test.txt、add runoob.php</span><br><span class=\"line\">* 3e92c19 add test.txt</span><br><span class=\"line\">* 3b58100 第一次版本提交</span><br></pre></td></tr></table></figure>\n\n<p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p>\n<p>你也可以用 <strong>–reverse</strong> 参数来逆向显示所有日志。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --reverse --oneline</span><br><span class=\"line\">3b58100 第一次版本提交</span><br><span class=\"line\">3e92c19 add test.txt</span><br><span class=\"line\">c1501a2 removed test.txt、add runoob.php</span><br><span class=\"line\">7774248 (change_site) changed the runoob.php</span><br><span class=\"line\">c68142b 修改代码</span><br><span class=\"line\">d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;</span><br></pre></td></tr></table></figure>\n\n<p>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --author=Linus --oneline -5</span><br><span class=\"line\">81b50f3 Move &apos;builtin-*&apos; into a &apos;builtin/&apos; subdirectory</span><br><span class=\"line\">3bb7256 make &quot;index-pack&quot; a built-in</span><br><span class=\"line\">377d027 make &quot;git pack-redundant&quot; a built-in</span><br><span class=\"line\">b532581 make &quot;git unpack-file&quot; a built-in</span><br><span class=\"line\">112dd51 make &quot;mktag&quot; a built-in</span><br></pre></td></tr></table></figure>\n\n<p>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p>\n<p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br><span class=\"line\">5469e2d Git 1.7.1-rc2</span><br><span class=\"line\">d43427d Documentation/remote-helpers: Fix typos and improve language</span><br><span class=\"line\">272a36b Fixup: Second argument may be any arbitrary string</span><br><span class=\"line\">b6c8d2d Documentation/remote-helpers: Add invocation section</span><br><span class=\"line\">5ce4f4e Documentation/urls: Rewrite to accomodate transport::address</span><br><span class=\"line\">00b84e9 Documentation/remote-helpers: Rewrite description</span><br><span class=\"line\">03aa87e Documentation: Describe other situations where -z affects git diff</span><br><span class=\"line\">77bc694 rebase-interactive: silence warning when no commits rewritten</span><br><span class=\"line\">636db2c t3301: add tests to use --format=&quot;%N&quot;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"什么是-Git\"><a href=\"#什么是-Git\" class=\"headerlink\" title=\"什么是 Git\"></a>什么是 Git</h2><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git是Linus Torvalds 为了帮助管理Linux内核开发而开发的一个开放源码的版本控制软件。</p>\n<h2 id=\"Git-的特点\"><a href=\"#Git-的特点\" class=\"headerlink\" title=\"Git 的特点\"></a>Git 的特点</h2><p>分布式相比于集中式的最大区别在于开发者可以提交到本地，每个开发者通过克隆（git clone）在本地机器上拷贝一个完整的Git仓库。从一般开发者的角度来看，git有以下功能：</p>\n<p>从服务器上克隆完整的Git仓库（包括代码和版本信息）到单机上、在自己的机器上根据不同的开发目的，创建分支，修改代码、在单机上自己创建的分支上提交代码、在单机上合并分支、把服务器上最新版的代码fetch下来，然后跟自己的主分支合并等。</p>","more":"<ul>\n<li>优点</li>\n</ul>\n<p>适合分布式开发，强调个体。公共服务器压力和数据量都不会太大。速度快、灵活。任意两个开发者之间可以很容易的解决冲突。离线工作。</p>\n<ul>\n<li>缺点</li>\n</ul>\n<p>资料少（起码中文资料很少）。学习周期相对而言比较长。不符合常规思维。代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有码和版本信息。因其资料的公开性，导致大型商业化工程几乎不会使用GIT来托管工程版本信息（除非搭建企业私服）。</p>\n<h2 id=\"Git-创建仓库\"><a href=\"#Git-创建仓库\" class=\"headerlink\" title=\"Git 创建仓库\"></a>Git 创建仓库</h2><h3 id=\"git-init\"><a href=\"#git-init\" class=\"headerlink\" title=\"git init\"></a>git init</h3><p>Git 使用 <strong>git init</strong> 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 <strong>git init</strong> 是使用 Git 的第一个命令。在执行完成 <strong>git init</strong> 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p>\n<p><strong>使用方法</strong></p>\n<p>使用当前目录作为Git仓库，我们只需使它初始化。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br></pre></td></tr></table></figure>\n\n<p>该命令执行完后会在当前目录生成一个 .git 目录。</p>\n<p>使用我们指定目录作为Git仓库。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init newrepo</span><br></pre></td></tr></table></figure>\n\n<p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p>\n<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git add *.c</span><br><span class=\"line\">$ git add README</span><br><span class=\"line\">$ git commit -m &apos;初始化项目版本&apos;</span><br></pre></td></tr></table></figure>\n\n<p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p>\n<hr>\n<h3 id=\"git-clone\"><a href=\"#git-clone\" class=\"headerlink\" title=\"git clone\"></a>git clone</h3><p>我们使用 <strong>git clone</strong> 从现有 Git 仓库中拷贝项目（类似 <strong>svn checkout</strong>）。</p>\n<p>克隆仓库的命令格式为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>\n\n<p><strong>参数说明：</strong></p>\n<ul>\n<li><strong>repo:</strong> Git 仓库。</li>\n<li><strong>directory:</strong> 本地目录。</li>\n</ul>\n<p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure>\n\n<p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。</p>\n<p>如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Git-基本操作\"><a href=\"#Git-基本操作\" class=\"headerlink\" title=\"Git 基本操作\"></a>Git 基本操作</h2><h3 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h3><p>git add 命令可将文件添加到缓存</p>\n<h3 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h3><p>git status 命令可以查看当前的提交状态</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  lishaojie.github.io git:(master) ✗ git status -s</span><br><span class=\"line\"> m themes/melody</span><br><span class=\"line\">?? source/_posts/git.md</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h3><p>git diff 命令可以查看文件具体哪里做了改动</p>\n<h3 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h3><p>git commit 命令可以把缓存区的内容提交到本地仓库</p>\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><p>git reset 命令可以取消之前 git add 添加，但不希望包含在下一提交快照中的缓存</p>\n<h3 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h3><p>如果只是简单地从工作目录中手工删除文件，运行 <strong>git status</strong> 时就会在 <strong>Changes not staged for commit</strong> 的提示。</p>\n<p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm &lt;file&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <strong>-f</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm -f &lt;file&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 <strong>–cached</strong> 选项即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure>\n\n<p>如我们删除 hello.php文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm hello.php </span><br><span class=\"line\">rm &apos;hello.php&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README</span><br></pre></td></tr></table></figure>\n\n<p>不从工作区中删除文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git rm --cached README </span><br><span class=\"line\">rm &apos;README&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README</span><br></pre></td></tr></table></figure>\n\n<p>可以递归删除，即如果后面跟的是一个目录做为参数，则会递归删除整个目录中的所有子目录和文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git rm –r *</span><br></pre></td></tr></table></figure>\n\n<p>进入某个目录中，执行此语句，会删除该目录下的所有文件和子目录</p>\n<h3 id=\"git-mv\"><a href=\"#git-mv\" class=\"headerlink\" title=\"git mv\"></a>git mv</h3><p>git mv 命令用于移动或重命名一个文件、目录、软连接</p>\n<h2 id=\"Git-分支管理\"><a href=\"#Git-分支管理\" class=\"headerlink\" title=\"Git 分支管理\"></a>Git 分支管理</h2><h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch (branchname)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"切换分支\"><a href=\"#切换分支\" class=\"headerlink\" title=\"切换分支\"></a>切换分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git checkout (branchname)</span><br></pre></td></tr></table></figure>\n\n<p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容， 所以多个分支不需要多个目录。</p>\n<h3 id=\"列出分支\"><a href=\"#列出分支\" class=\"headerlink\" title=\"列出分支\"></a>列出分支</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch</span><br></pre></td></tr></table></figure>\n\n<p>没有参数时，<strong>git branch</strong> 会列出你在本地的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n\n<p>此例的意思就是，我们有一个叫做 <strong>master</strong> 的分支，并且该分支是当前分支。</p>\n<p>当你执行 <strong>git init</strong> 的时候，默认情况下 Git 就会为你创建 <strong>master</strong> 分支。</p>\n<p>如果我们要手动创建一个分支。执行 <strong>git branch (branchname)</strong> 即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch testing</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br><span class=\"line\">  testing</span><br></pre></td></tr></table></figure>\n\n<p>现在我们可以看到，有了一个新分支 <strong>testing</strong>。</p>\n<p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交， 然后又切换到了 <strong>testing</strong> 分支，Git 将还原你的工作目录到你创建分支时候的样子。</p>\n<p>接下来我们将演示如何切换分支，我们用 git checkout (branch) 切换到我们要修改的分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ls</span><br><span class=\"line\">README</span><br><span class=\"line\">$ echo &apos;runoob.com&apos; &gt; test.txt</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -m &apos;add test.txt&apos;</span><br><span class=\"line\">[master 3e92c19] add test.txt</span><br><span class=\"line\"> 1 file changed, 1 insertion(+)</span><br><span class=\"line\"> create mode 100644 test.txt</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        test.txt</span><br><span class=\"line\">$ git checkout testing</span><br><span class=\"line\">Switched to branch &apos;testing&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README</span><br></pre></td></tr></table></figure>\n\n<p>当我们切换到 <strong>testing</strong> 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 <strong>master</strong> 分支的时候，它们有重新出现了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &apos;master&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        test.txt</span><br></pre></td></tr></table></figure>\n\n<p>我们也可以使用 git checkout -b (branchname) 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b newtest</span><br><span class=\"line\">Switched to a new branch &apos;newtest&apos;</span><br><span class=\"line\">$ git rm test.txt </span><br><span class=\"line\">rm &apos;test.txt&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README</span><br><span class=\"line\">$ touch runoob.php</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\">$ git commit -am &apos;removed test.txt、add runoob.php&apos;</span><br><span class=\"line\">[newtest c1501a2] removed test.txt、add runoob.php</span><br><span class=\"line\"> 2 files changed, 1 deletion(-)</span><br><span class=\"line\"> create mode 100644 runoob.php</span><br><span class=\"line\"> delete mode 100644 test.txt</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        runoob.php</span><br><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &apos;master&apos;</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        test.txt</span><br></pre></td></tr></table></figure>\n\n<p>如你所见，我们创建了一个分支，在该分支的上移除了一些文件 test.txt，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 文件又回来了，且新增加的 runoob.php 不存在主分支中。</p>\n<p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p>\n<h3 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h3><p>删除分支命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git branch -d (branchname)</span><br></pre></td></tr></table></figure>\n\n<p>例如我们要删除 testing 分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br><span class=\"line\">  testing</span><br><span class=\"line\">$ git branch -d testing</span><br><span class=\"line\">Deleted branch testing (was 85fc7e7).</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h3><p>一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git merge</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br><span class=\"line\">  newtest</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        test.txt</span><br><span class=\"line\">$ git merge newtest</span><br><span class=\"line\">Updating 3e92c19..c1501a2</span><br><span class=\"line\">Fast-forward</span><br><span class=\"line\"> runoob.php | 0</span><br><span class=\"line\"> test.txt   | 1 -</span><br><span class=\"line\"> 2 files changed, 1 deletion(-)</span><br><span class=\"line\"> create mode 100644 runoob.php</span><br><span class=\"line\"> delete mode 100644 test.txt</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">README        runoob.php</span><br></pre></td></tr></table></figure>\n\n<p>以上实例中我们将 newtest 分支合并到主分支去，test.txt 文件被删除。</p>\n<p>合并完后就可以删除分支:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch -d newtest</span><br><span class=\"line\">Deleted branch newtest (was c1501a2).</span><br></pre></td></tr></table></figure>\n\n<p>删除后， 就只剩下 master 分支了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"合并冲突\"><a href=\"#合并冲突\" class=\"headerlink\" title=\"合并冲突\"></a>合并冲突</h3><p>合并并不仅仅是简单的文件添加、移除的操作，Git 也会合并修改。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br><span class=\"line\">* master</span><br><span class=\"line\">$ cat runoob.php</span><br></pre></td></tr></table></figure>\n\n<p>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo &apos;runoob&apos;;</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>创建 change_site 分支：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout -b change_site</span><br><span class=\"line\">Switched to a new branch &apos;change_site&apos;</span><br><span class=\"line\">$ vim runoob.php</span><br><span class=\"line\">$ head -3 runoob.php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo &apos;runoob&apos;;</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">$ git commit -am &apos;changed the runoob.php&apos;</span><br><span class=\"line\">[change_site 7774248] changed the runoob.php</span><br><span class=\"line\"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure>\n\n<p>将修改的内容提交到 change_site 分支中。 现在，假如切换回 master 分支我们可以看内容恢复到我们修改前的(空文件，没有代码)，我们再次修改 runoob.php 文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br><span class=\"line\">Switched to branch &apos;master&apos;</span><br><span class=\"line\">$ cat runoob.php</span><br><span class=\"line\">$ vim runoob.php    # 修改内容如下</span><br><span class=\"line\">$ cat runoob.php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo 1;</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">$ git diff</span><br><span class=\"line\">diff --git a/runoob.php b/runoob.php</span><br><span class=\"line\">index e69de29..ac60739 100644</span><br><span class=\"line\">--- a/runoob.php</span><br><span class=\"line\">+++ b/runoob.php</span><br><span class=\"line\">@@ -0,0 +1,3 @@</span><br><span class=\"line\">+&lt;?php</span><br><span class=\"line\">+echo 1;</span><br><span class=\"line\">+?&gt;</span><br><span class=\"line\">$ git commit -am &apos;修改代码&apos;</span><br><span class=\"line\">[master c68142b] 修改代码</span><br><span class=\"line\"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure>\n\n<p>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git merge change_site</span><br><span class=\"line\">Auto-merging runoob.php</span><br><span class=\"line\">CONFLICT (content): Merge conflict in runoob.php</span><br><span class=\"line\">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class=\"line\"></span><br><span class=\"line\">$ cat runoob.php     # 代开文件，看到冲突内容</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">echo 1;</span><br><span class=\"line\">=======</span><br><span class=\"line\">echo &apos;runoob&apos;;</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site</span><br><span class=\"line\">?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vim runoob.php </span><br><span class=\"line\">$ cat runoob.php</span><br><span class=\"line\">&lt;?php</span><br><span class=\"line\">echo 1;</span><br><span class=\"line\">echo &apos;runoob&apos;;</span><br><span class=\"line\">?&gt;</span><br><span class=\"line\">$ git diff</span><br><span class=\"line\">diff --cc runoob.php</span><br><span class=\"line\">index ac60739,b63d7d7..0000000</span><br><span class=\"line\">--- a/runoob.php</span><br><span class=\"line\">+++ b/runoob.php</span><br><span class=\"line\">@@@ -1,3 -1,3 +1,4 @@@</span><br><span class=\"line\">  &lt;?php</span><br><span class=\"line\"> +echo 1;</span><br><span class=\"line\">+ echo &apos;runoob&apos;;</span><br><span class=\"line\">  ?&gt;</span><br></pre></td></tr></table></figure>\n\n<p>在 Git 中，我们可以用 git add 要告诉 Git 文件冲突已经解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git status -s</span><br><span class=\"line\">UU runoob.php</span><br><span class=\"line\">$ git add runoob.php</span><br><span class=\"line\">$ git status -s</span><br><span class=\"line\">M  runoob.php</span><br><span class=\"line\">$ git commit</span><br><span class=\"line\">[master 88afe0e] Merge branch &apos;change_site&apos;</span><br></pre></td></tr></table></figure>\n\n<p>现在我们成功解决了合并中的冲突，并提交了结果。</p>\n<h2 id=\"Git-查看提交历史\"><a href=\"#Git-查看提交历史\" class=\"headerlink\" title=\"Git 查看提交历史\"></a>Git 查看提交历史</h2><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 git log 命令查看。</p>\n<p>针对我们前一章节的操作，使用 git log 命令列出历史提交记录如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log</span><br><span class=\"line\">commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)</span><br><span class=\"line\">Merge: c68142b 7774248</span><br><span class=\"line\">Author: runoob &lt;test@runoob.com&gt;</span><br><span class=\"line\">Date:   Fri May 3 15:55:58 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    Merge branch &apos;change_site&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">commit c68142b562c260c3071754623b08e2657b4c6d5b</span><br><span class=\"line\">Author: runoob &lt;test@runoob.com&gt;</span><br><span class=\"line\">Date:   Fri May 3 15:52:12 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    修改代码</span><br><span class=\"line\"></span><br><span class=\"line\">commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)</span><br><span class=\"line\">Author: runoob &lt;test@runoob.com&gt;</span><br><span class=\"line\">Date:   Fri May 3 15:49:26 2019 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">    changed the runoob.php</span><br><span class=\"line\"></span><br><span class=\"line\">commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00</span><br><span class=\"line\">Author: runoob &lt;test@runoob.com&gt;</span><br><span class=\"line\">Date:   Fri May 3 15:35:32 2019 +0800</span><br></pre></td></tr></table></figure>\n\n<p>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --oneline</span><br><span class=\"line\">$ git log --oneline</span><br><span class=\"line\">d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;</span><br><span class=\"line\">c68142b 修改代码</span><br><span class=\"line\">7774248 (change_site) changed the runoob.php</span><br><span class=\"line\">c1501a2 removed test.txt、add runoob.php</span><br><span class=\"line\">3e92c19 add test.txt</span><br><span class=\"line\">3b58100 第一次版本提交</span><br></pre></td></tr></table></figure>\n\n<p>这告诉我们的是，此项目的开发历史。</p>\n<p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*   d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;</span><br><span class=\"line\">|\\  </span><br><span class=\"line\">| * 7774248 (change_site) changed the runoob.php</span><br><span class=\"line\">* | c68142b 修改代码</span><br><span class=\"line\">|/  </span><br><span class=\"line\">* c1501a2 removed test.txt、add runoob.php</span><br><span class=\"line\">* 3e92c19 add test.txt</span><br><span class=\"line\">* 3b58100 第一次版本提交</span><br></pre></td></tr></table></figure>\n\n<p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p>\n<p>你也可以用 <strong>–reverse</strong> 参数来逆向显示所有日志。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --reverse --oneline</span><br><span class=\"line\">3b58100 第一次版本提交</span><br><span class=\"line\">3e92c19 add test.txt</span><br><span class=\"line\">c1501a2 removed test.txt、add runoob.php</span><br><span class=\"line\">7774248 (change_site) changed the runoob.php</span><br><span class=\"line\">c68142b 修改代码</span><br><span class=\"line\">d5e9fc2 (HEAD -&gt; master) Merge branch &apos;change_site&apos;</span><br></pre></td></tr></table></figure>\n\n<p>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --author=Linus --oneline -5</span><br><span class=\"line\">81b50f3 Move &apos;builtin-*&apos; into a &apos;builtin/&apos; subdirectory</span><br><span class=\"line\">3bb7256 make &quot;index-pack&quot; a built-in</span><br><span class=\"line\">377d027 make &quot;git pack-redundant&quot; a built-in</span><br><span class=\"line\">b532581 make &quot;git unpack-file&quot; a built-in</span><br><span class=\"line\">112dd51 make &quot;mktag&quot; a built-in</span><br></pre></td></tr></table></figure>\n\n<p>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p>\n<p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br><span class=\"line\">5469e2d Git 1.7.1-rc2</span><br><span class=\"line\">d43427d Documentation/remote-helpers: Fix typos and improve language</span><br><span class=\"line\">272a36b Fixup: Second argument may be any arbitrary string</span><br><span class=\"line\">b6c8d2d Documentation/remote-helpers: Add invocation section</span><br><span class=\"line\">5ce4f4e Documentation/urls: Rewrite to accomodate transport::address</span><br><span class=\"line\">00b84e9 Documentation/remote-helpers: Rewrite description</span><br><span class=\"line\">03aa87e Documentation: Describe other situations where -z affects git diff</span><br><span class=\"line\">77bc694 rebase-interactive: silence warning when no commits rewritten</span><br><span class=\"line\">636db2c t3301: add tests to use --format=&quot;%N&quot;</span><br></pre></td></tr></table></figure>"},{"title":"Mybatis","date":"2018-03-22T15:47:43.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n参考链接：[mybatis入门](https://mybatis.org/mybatis-3/zh/getting-started.html)\n\n## mybatis常见问题\n\n### 1、什么是MyBatis？\n\nMyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。\n\n\n\n### 2、讲下MyBatis的缓存\n\nMyBatis的缓存分为一级缓存和二级缓存,一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/>\n\n<!--more-->\n\n### 3、Mybatis是如何进行分页的？分页插件的原理是什么？\n\n1. Mybatis使用RowBounds对象进行分页，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件。\n2. 分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。\n\n举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10\n\n\n\n### 4、简述Mybatis的插件运行原理，以及如何编写一个插件？\n\n1. Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。\n2. 实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。\n\n\n\n### 5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？\n\n1. Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。\n2. Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。\n3. 其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。\n\n\n\n### 6、#{}和${}的区别是什么？\n\n1. \\#{}是预编译处理，${}是字符串替换。\n2. Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；\n3. Mybatis在处理${}时，就是把${}替换成变量的值。\n4. 使用#{}可以有效的防止SQL注入，提高系统安全性。\n\n\n\n### 7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？\n\nHibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。\n\n\n\n### 8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\n\n1. Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。\n2. 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。\n\n\n\n### 9、MyBatis与Hibernate有哪些不同？\n\n1. Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。\n2. Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。\n3. Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。\n\n总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。\n\n\n\n### 10、MyBatis的好处是什么？\n\n1. MyBatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的维护带来了很大便利。\n2. MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。\n3. 因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。\n\n\n\n### 11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？\n\nMybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。\n\n\n\n### 12、什么是MyBatis的接口绑定,有什么好处？\n\n接口映射就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。\n\n\n\n### 13、接口绑定有几种实现方式,分别是怎么实现的?\n\n接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定,另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。\n\n\n\n### 14、什么情况下用注解绑定,什么情况下用xml绑定？\n\n当Sql语句比较简单时候,用注解绑定；当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多\n\n\n\n### 15、MyBatis实现一对一有几种方式?具体怎么操作的？\n\n有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置association节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。\n\n\n\n### 16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？\n\n能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。\n\n关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。\n\n\n\n### 17、MyBatis里面的动态Sql是怎么设定的?用什么语法?\n\nMyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。\n\n\n\n### 18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\n\n第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。\n\n第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。\n\n有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。\n\n\n\n### 19、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？\n\n还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。\n\n\n\n### 20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？\n\n1. 通过在查询的sql语句中定义字段名的别名。\n2. 通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。\n\n\n\n### 21、模糊查询like语句该怎么写\n\n1. 在java中拼接通配符，通过#{}赋值\n2. 在Sql语句中拼接通配符 （不安全 会引起Sql注入）\n\n\n\n### 22、通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？\n\n不能重载，因为通过Dao寻找Xml对应的sql的时候全限名+方法名的保存和寻找策略。接口工作原理为jdk动态代理原理，运行时会为dao生成proxy，代理对象会拦截接口方法，去执行对应的sql返回数据。\n\n\n\n### 23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？\n\n虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。\n\n\n\n### 24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？\n\n不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。原因就是namespace+id是作为Map<String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。\n\n\n\n### 25、Mybatis中如何执行批处理？\n\n使用BatchExecutor完成批处理。\n\n\n\n### 26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？\n\nMybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。1）SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。2）ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map3）BatchExecutor：完成批处理。\n\n\n\n### 27、Mybatis中如何指定使用哪一种Executor执行器？\n\n在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。\n\n\n\n### 28、Mybatis执行批量插入，能返回数据库主键列表吗？\n\n能，JDBC都能，Mybatis当然也能。\n\n\n\n### 29、Mybatis是否可以映射Enum枚举类？\n\nMybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。\n\n\n\n### 30、如何获取自动生成的(主)键值？\n\n配置文件设置usegeneratedkeys 为 true。\n\n\n\n### 31、在mapper中如何传递多个参数？\n\n1. 直接在方法中传递参数，xml文件用#{0} #{1}来获取\n2. 使用 @param 注解:这样可以直接在xml文件中通过#{name}来获取\n\n\n\n### 32、resultType resultMap的区别？\n\n1. 类的名字和数据库相同时，可以直接设置resultType参数为Pojo类\n2. 若不同，需要设置resultMap 将结果名字和Pojo名字进行转换\n\n\n\n### 33、使用MyBatis的mapper接口调用时有哪些要求？\n\n1. Mapper接口方法名和mapper.xml中定义的每个sql的id相同\n2. Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同\n3. Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n4. Mapper.xml文件中的namespace即是mapper接口的类路径。\n\n\n\n### 34、Mybatis比IBatis比较大的几个改进是什么？\n\n1. 有接口绑定,包括注解绑定sql和xml绑定Sql。\n2. 动态sql由原来的节点配置变成OGNL表达式3） 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置。\n\n\n\n### 35、IBatis和MyBatis在核心处理类分别叫什么？\n\nIBatis里面的核心处理类交SqlMapClient,MyBatis里面的核心处理类叫做SqlSession。\n\n\n\n### 36、IBatis和MyBatis在细节上的不同有哪些？\n\n1. 在sql里面变量命名有原来的#变量# 变成了#{变量}。\n2. 原来的 \\$变量\\$ 变成了 ${变量}。\n3. 原来在sql节点里面的class都换名字交type。\n4. 原来的queryForObject queryForList 变成了selectOne selectList5）原来的别名设置在映射文件里面放在了核心配置文件里。","source":"_posts/mybatis.md","raw":"---\ntitle: Mybatis\ndate: 2018-03-22 23:47:43\ncategories: Java\ntags:\n  - web框架\n  - mybatis\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n参考链接：[mybatis入门](https://mybatis.org/mybatis-3/zh/getting-started.html)\n\n## mybatis常见问题\n\n### 1、什么是MyBatis？\n\nMyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。\n\n\n\n### 2、讲下MyBatis的缓存\n\nMyBatis的缓存分为一级缓存和二级缓存,一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/>\n\n<!--more-->\n\n### 3、Mybatis是如何进行分页的？分页插件的原理是什么？\n\n1. Mybatis使用RowBounds对象进行分页，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件。\n2. 分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。\n\n举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10\n\n\n\n### 4、简述Mybatis的插件运行原理，以及如何编写一个插件？\n\n1. Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。\n2. 实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。\n\n\n\n### 5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？\n\n1. Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。\n2. Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。\n3. 其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。\n\n\n\n### 6、#{}和${}的区别是什么？\n\n1. \\#{}是预编译处理，${}是字符串替换。\n2. Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；\n3. Mybatis在处理${}时，就是把${}替换成变量的值。\n4. 使用#{}可以有效的防止SQL注入，提高系统安全性。\n\n\n\n### 7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？\n\nHibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。\n\n\n\n### 8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\n\n1. Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。\n2. 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。\n\n\n\n### 9、MyBatis与Hibernate有哪些不同？\n\n1. Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。\n2. Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。\n3. Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。\n\n总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。\n\n\n\n### 10、MyBatis的好处是什么？\n\n1. MyBatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的维护带来了很大便利。\n2. MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。\n3. 因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。\n\n\n\n### 11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？\n\nMybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。\n\n\n\n### 12、什么是MyBatis的接口绑定,有什么好处？\n\n接口映射就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。\n\n\n\n### 13、接口绑定有几种实现方式,分别是怎么实现的?\n\n接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定,另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。\n\n\n\n### 14、什么情况下用注解绑定,什么情况下用xml绑定？\n\n当Sql语句比较简单时候,用注解绑定；当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多\n\n\n\n### 15、MyBatis实现一对一有几种方式?具体怎么操作的？\n\n有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置association节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。\n\n\n\n### 16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？\n\n能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。\n\n关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。\n\n\n\n### 17、MyBatis里面的动态Sql是怎么设定的?用什么语法?\n\nMyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。\n\n\n\n### 18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\n\n第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。\n\n第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。\n\n有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。\n\n\n\n### 19、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？\n\n还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。\n\n\n\n### 20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？\n\n1. 通过在查询的sql语句中定义字段名的别名。\n2. 通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。\n\n\n\n### 21、模糊查询like语句该怎么写\n\n1. 在java中拼接通配符，通过#{}赋值\n2. 在Sql语句中拼接通配符 （不安全 会引起Sql注入）\n\n\n\n### 22、通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？\n\n不能重载，因为通过Dao寻找Xml对应的sql的时候全限名+方法名的保存和寻找策略。接口工作原理为jdk动态代理原理，运行时会为dao生成proxy，代理对象会拦截接口方法，去执行对应的sql返回数据。\n\n\n\n### 23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？\n\n虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。\n\n\n\n### 24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？\n\n不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。原因就是namespace+id是作为Map<String, MappedStatement>的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。\n\n\n\n### 25、Mybatis中如何执行批处理？\n\n使用BatchExecutor完成批处理。\n\n\n\n### 26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？\n\nMybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。1）SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。2）ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map3）BatchExecutor：完成批处理。\n\n\n\n### 27、Mybatis中如何指定使用哪一种Executor执行器？\n\n在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。\n\n\n\n### 28、Mybatis执行批量插入，能返回数据库主键列表吗？\n\n能，JDBC都能，Mybatis当然也能。\n\n\n\n### 29、Mybatis是否可以映射Enum枚举类？\n\nMybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。\n\n\n\n### 30、如何获取自动生成的(主)键值？\n\n配置文件设置usegeneratedkeys 为 true。\n\n\n\n### 31、在mapper中如何传递多个参数？\n\n1. 直接在方法中传递参数，xml文件用#{0} #{1}来获取\n2. 使用 @param 注解:这样可以直接在xml文件中通过#{name}来获取\n\n\n\n### 32、resultType resultMap的区别？\n\n1. 类的名字和数据库相同时，可以直接设置resultType参数为Pojo类\n2. 若不同，需要设置resultMap 将结果名字和Pojo名字进行转换\n\n\n\n### 33、使用MyBatis的mapper接口调用时有哪些要求？\n\n1. Mapper接口方法名和mapper.xml中定义的每个sql的id相同\n2. Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同\n3. Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同\n4. Mapper.xml文件中的namespace即是mapper接口的类路径。\n\n\n\n### 34、Mybatis比IBatis比较大的几个改进是什么？\n\n1. 有接口绑定,包括注解绑定sql和xml绑定Sql。\n2. 动态sql由原来的节点配置变成OGNL表达式3） 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置。\n\n\n\n### 35、IBatis和MyBatis在核心处理类分别叫什么？\n\nIBatis里面的核心处理类交SqlMapClient,MyBatis里面的核心处理类叫做SqlSession。\n\n\n\n### 36、IBatis和MyBatis在细节上的不同有哪些？\n\n1. 在sql里面变量命名有原来的#变量# 变成了#{变量}。\n2. 原来的 \\$变量\\$ 变成了 ${变量}。\n3. 原来在sql节点里面的class都换名字交type。\n4. 原来的queryForObject queryForList 变成了selectOne selectList5）原来的别名设置在映射文件里面放在了核心配置文件里。","slug":"mybatis","published":1,"updated":"2020-02-02T09:27:08.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bjw003va6ybnoh59c2f","content":"<p>参考链接：<a href=\"https://mybatis.org/mybatis-3/zh/getting-started.html\" target=\"_blank\" rel=\"noopener\">mybatis入门</a></p>\n<h2 id=\"mybatis常见问题\"><a href=\"#mybatis常见问题\" class=\"headerlink\" title=\"mybatis常见问题\"></a>mybatis常见问题</h2><h3 id=\"1、什么是MyBatis？\"><a href=\"#1、什么是MyBatis？\" class=\"headerlink\" title=\"1、什么是MyBatis？\"></a>1、什么是MyBatis？</h3><p>MyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。</p>\n<h3 id=\"2、讲下MyBatis的缓存\"><a href=\"#2、讲下MyBatis的缓存\" class=\"headerlink\" title=\"2、讲下MyBatis的缓存\"></a>2、讲下MyBatis的缓存</h3><p>MyBatis的缓存分为一级缓存和二级缓存,一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache></cache></p>\n<a id=\"more\"></a>\n\n<h3 id=\"3、Mybatis是如何进行分页的？分页插件的原理是什么？\"><a href=\"#3、Mybatis是如何进行分页的？分页插件的原理是什么？\" class=\"headerlink\" title=\"3、Mybatis是如何进行分页的？分页插件的原理是什么？\"></a>3、Mybatis是如何进行分页的？分页插件的原理是什么？</h3><ol>\n<li>Mybatis使用RowBounds对象进行分页，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件。</li>\n<li>分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。</li>\n</ol>\n<p>举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10</p>\n<h3 id=\"4、简述Mybatis的插件运行原理，以及如何编写一个插件？\"><a href=\"#4、简述Mybatis的插件运行原理，以及如何编写一个插件？\" class=\"headerlink\" title=\"4、简述Mybatis的插件运行原理，以及如何编写一个插件？\"></a>4、简述Mybatis的插件运行原理，以及如何编写一个插件？</h3><ol>\n<li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li>\n<li>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</li>\n</ol>\n<h3 id=\"5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？\"><a href=\"#5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？\" class=\"headerlink\" title=\"5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？\"></a>5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><ol>\n<li>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。</li>\n<li>Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</li>\n<li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</li>\n</ol>\n<h3 id=\"6、-和-的区别是什么？\"><a href=\"#6、-和-的区别是什么？\" class=\"headerlink\" title=\"6、#{}和${}的区别是什么？\"></a>6、#{}和${}的区别是什么？</h3><ol>\n<li>#{}是预编译处理，${}是字符串替换。</li>\n<li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>\n<li>Mybatis在处理${}时，就是把${}替换成变量的值。</li>\n<li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li>\n</ol>\n<h3 id=\"7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？\"><a href=\"#7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？\" class=\"headerlink\" title=\"7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？\"></a>7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>\n<h3 id=\"8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\"><a href=\"#8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\" class=\"headerlink\" title=\"8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\"></a>8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><ol>\n<li>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</li>\n<li>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li>\n</ol>\n<h3 id=\"9、MyBatis与Hibernate有哪些不同？\"><a href=\"#9、MyBatis与Hibernate有哪些不同？\" class=\"headerlink\" title=\"9、MyBatis与Hibernate有哪些不同？\"></a>9、MyBatis与Hibernate有哪些不同？</h3><ol>\n<li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</li>\n<li>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</li>\n<li>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</li>\n</ol>\n<p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p>\n<h3 id=\"10、MyBatis的好处是什么？\"><a href=\"#10、MyBatis的好处是什么？\" class=\"headerlink\" title=\"10、MyBatis的好处是什么？\"></a>10、MyBatis的好处是什么？</h3><ol>\n<li>MyBatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的维护带来了很大便利。</li>\n<li>MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。</li>\n<li>因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。</li>\n</ol>\n<h3 id=\"11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？\"><a href=\"#11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？\" class=\"headerlink\" title=\"11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？\"></a>11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p>Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parametermap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultmap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</delete></update></insert></select></resultmap></parametermap></p>\n<h3 id=\"12、什么是MyBatis的接口绑定-有什么好处？\"><a href=\"#12、什么是MyBatis的接口绑定-有什么好处？\" class=\"headerlink\" title=\"12、什么是MyBatis的接口绑定,有什么好处？\"></a>12、什么是MyBatis的接口绑定,有什么好处？</h3><p>接口映射就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p>\n<h3 id=\"13、接口绑定有几种实现方式-分别是怎么实现的\"><a href=\"#13、接口绑定有几种实现方式-分别是怎么实现的\" class=\"headerlink\" title=\"13、接口绑定有几种实现方式,分别是怎么实现的?\"></a>13、接口绑定有几种实现方式,分别是怎么实现的?</h3><p>接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定,另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。</p>\n<h3 id=\"14、什么情况下用注解绑定-什么情况下用xml绑定？\"><a href=\"#14、什么情况下用注解绑定-什么情况下用xml绑定？\" class=\"headerlink\" title=\"14、什么情况下用注解绑定,什么情况下用xml绑定？\"></a>14、什么情况下用注解绑定,什么情况下用xml绑定？</h3><p>当Sql语句比较简单时候,用注解绑定；当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多</p>\n<h3 id=\"15、MyBatis实现一对一有几种方式-具体怎么操作的？\"><a href=\"#15、MyBatis实现一对一有几种方式-具体怎么操作的？\" class=\"headerlink\" title=\"15、MyBatis实现一对一有几种方式?具体怎么操作的？\"></a>15、MyBatis实现一对一有几种方式?具体怎么操作的？</h3><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置association节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。</p>\n<h3 id=\"16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？\"><a href=\"#16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？\" class=\"headerlink\" title=\"16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？\"></a>16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h3><p>能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。</p>\n<p>关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。</p>\n<h3 id=\"17、MyBatis里面的动态Sql是怎么设定的-用什么语法\"><a href=\"#17、MyBatis里面的动态Sql是怎么设定的-用什么语法\" class=\"headerlink\" title=\"17、MyBatis里面的动态Sql是怎么设定的?用什么语法?\"></a>17、MyBatis里面的动态Sql是怎么设定的?用什么语法?</h3><p>MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。</p>\n<h3 id=\"18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\"><a href=\"#18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\" class=\"headerlink\" title=\"18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\"></a>18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系。</resultmap></p>\n<p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p>\n<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>\n<h3 id=\"19、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？\"><a href=\"#19、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？\" class=\"headerlink\" title=\"19、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？\"></a>19、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h3><p>还有很多其他的标签，<resultmap>、<parametermap>、<sql>、<include>、<selectkey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectkey>为不支持自增的主键生成策略标签。</selectkey></include></sql></selectkey></include></sql></parametermap></resultmap></p>\n<h3 id=\"20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？\"><a href=\"#20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？\" class=\"headerlink\" title=\"20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？\"></a>20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？</h3><ol>\n<li>通过在查询的sql语句中定义字段名的别名。</li>\n<li>通过<resultmap>来映射字段名和实体类属性名的一一对应的关系。</resultmap></li>\n</ol>\n<h3 id=\"21、模糊查询like语句该怎么写\"><a href=\"#21、模糊查询like语句该怎么写\" class=\"headerlink\" title=\"21、模糊查询like语句该怎么写\"></a>21、模糊查询like语句该怎么写</h3><ol>\n<li>在java中拼接通配符，通过#{}赋值</li>\n<li>在Sql语句中拼接通配符 （不安全 会引起Sql注入）</li>\n</ol>\n<h3 id=\"22、通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？\"><a href=\"#22、通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？\" class=\"headerlink\" title=\"22、通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？\"></a>22、通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？</h3><p>不能重载，因为通过Dao寻找Xml对应的sql的时候全限名+方法名的保存和寻找策略。接口工作原理为jdk动态代理原理，运行时会为dao生成proxy，代理对象会拦截接口方法，去执行对应的sql返回数据。</p>\n<h3 id=\"23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？\"><a href=\"#23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？\" class=\"headerlink\" title=\"23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？\"></a>23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h3><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p>\n<h3 id=\"24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？\"><a href=\"#24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？\" class=\"headerlink\" title=\"24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？\"></a>24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h3><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>\n<h3 id=\"25、Mybatis中如何执行批处理？\"><a href=\"#25、Mybatis中如何执行批处理？\" class=\"headerlink\" title=\"25、Mybatis中如何执行批处理？\"></a>25、Mybatis中如何执行批处理？</h3><p>使用BatchExecutor完成批处理。</p>\n<h3 id=\"26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？\"><a href=\"#26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？\" class=\"headerlink\" title=\"26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？\"></a>26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。1）SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。2）ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map3）BatchExecutor：完成批处理。</p>\n<h3 id=\"27、Mybatis中如何指定使用哪一种Executor执行器？\"><a href=\"#27、Mybatis中如何指定使用哪一种Executor执行器？\" class=\"headerlink\" title=\"27、Mybatis中如何指定使用哪一种Executor执行器？\"></a>27、Mybatis中如何指定使用哪一种Executor执行器？</h3><p>在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>\n<h3 id=\"28、Mybatis执行批量插入，能返回数据库主键列表吗？\"><a href=\"#28、Mybatis执行批量插入，能返回数据库主键列表吗？\" class=\"headerlink\" title=\"28、Mybatis执行批量插入，能返回数据库主键列表吗？\"></a>28、Mybatis执行批量插入，能返回数据库主键列表吗？</h3><p>能，JDBC都能，Mybatis当然也能。</p>\n<h3 id=\"29、Mybatis是否可以映射Enum枚举类？\"><a href=\"#29、Mybatis是否可以映射Enum枚举类？\" class=\"headerlink\" title=\"29、Mybatis是否可以映射Enum枚举类？\"></a>29、Mybatis是否可以映射Enum枚举类？</h3><p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p>\n<h3 id=\"30、如何获取自动生成的-主-键值？\"><a href=\"#30、如何获取自动生成的-主-键值？\" class=\"headerlink\" title=\"30、如何获取自动生成的(主)键值？\"></a>30、如何获取自动生成的(主)键值？</h3><p>配置文件设置usegeneratedkeys 为 true。</p>\n<h3 id=\"31、在mapper中如何传递多个参数？\"><a href=\"#31、在mapper中如何传递多个参数？\" class=\"headerlink\" title=\"31、在mapper中如何传递多个参数？\"></a>31、在mapper中如何传递多个参数？</h3><ol>\n<li>直接在方法中传递参数，xml文件用#{0} #{1}来获取</li>\n<li>使用 @param 注解:这样可以直接在xml文件中通过#{name}来获取</li>\n</ol>\n<h3 id=\"32、resultType-resultMap的区别？\"><a href=\"#32、resultType-resultMap的区别？\" class=\"headerlink\" title=\"32、resultType resultMap的区别？\"></a>32、resultType resultMap的区别？</h3><ol>\n<li>类的名字和数据库相同时，可以直接设置resultType参数为Pojo类</li>\n<li>若不同，需要设置resultMap 将结果名字和Pojo名字进行转换</li>\n</ol>\n<h3 id=\"33、使用MyBatis的mapper接口调用时有哪些要求？\"><a href=\"#33、使用MyBatis的mapper接口调用时有哪些要求？\" class=\"headerlink\" title=\"33、使用MyBatis的mapper接口调用时有哪些要求？\"></a>33、使用MyBatis的mapper接口调用时有哪些要求？</h3><ol>\n<li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同</li>\n<li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</li>\n<li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</li>\n<li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li>\n</ol>\n<h3 id=\"34、Mybatis比IBatis比较大的几个改进是什么？\"><a href=\"#34、Mybatis比IBatis比较大的几个改进是什么？\" class=\"headerlink\" title=\"34、Mybatis比IBatis比较大的几个改进是什么？\"></a>34、Mybatis比IBatis比较大的几个改进是什么？</h3><ol>\n<li>有接口绑定,包括注解绑定sql和xml绑定Sql。</li>\n<li>动态sql由原来的节点配置变成OGNL表达式3） 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置。</li>\n</ol>\n<h3 id=\"35、IBatis和MyBatis在核心处理类分别叫什么？\"><a href=\"#35、IBatis和MyBatis在核心处理类分别叫什么？\" class=\"headerlink\" title=\"35、IBatis和MyBatis在核心处理类分别叫什么？\"></a>35、IBatis和MyBatis在核心处理类分别叫什么？</h3><p>IBatis里面的核心处理类交SqlMapClient,MyBatis里面的核心处理类叫做SqlSession。</p>\n<h3 id=\"36、IBatis和MyBatis在细节上的不同有哪些？\"><a href=\"#36、IBatis和MyBatis在细节上的不同有哪些？\" class=\"headerlink\" title=\"36、IBatis和MyBatis在细节上的不同有哪些？\"></a>36、IBatis和MyBatis在细节上的不同有哪些？</h3><ol>\n<li>在sql里面变量命名有原来的#变量# 变成了#{变量}。</li>\n<li>原来的 $变量$ 变成了 ${变量}。</li>\n<li>原来在sql节点里面的class都换名字交type。</li>\n<li>原来的queryForObject queryForList 变成了selectOne selectList5）原来的别名设置在映射文件里面放在了核心配置文件里。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>参考链接：<a href=\"https://mybatis.org/mybatis-3/zh/getting-started.html\" target=\"_blank\" rel=\"noopener\">mybatis入门</a></p>\n<h2 id=\"mybatis常见问题\"><a href=\"#mybatis常见问题\" class=\"headerlink\" title=\"mybatis常见问题\"></a>mybatis常见问题</h2><h3 id=\"1、什么是MyBatis？\"><a href=\"#1、什么是MyBatis？\" class=\"headerlink\" title=\"1、什么是MyBatis？\"></a>1、什么是MyBatis？</h3><p>MyBatis是一个可以自定义SQL、存储过程和高级映射的持久层框架。</p>\n<h3 id=\"2、讲下MyBatis的缓存\"><a href=\"#2、讲下MyBatis的缓存\" class=\"headerlink\" title=\"2、讲下MyBatis的缓存\"></a>2、讲下MyBatis的缓存</h3><p>MyBatis的缓存分为一级缓存和二级缓存,一级缓存放在session里面,默认就有,二级缓存放在它的命名空间里,默认是不打开的,使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache></cache></p>","more":"<h3 id=\"3、Mybatis是如何进行分页的？分页插件的原理是什么？\"><a href=\"#3、Mybatis是如何进行分页的？分页插件的原理是什么？\" class=\"headerlink\" title=\"3、Mybatis是如何进行分页的？分页插件的原理是什么？\"></a>3、Mybatis是如何进行分页的？分页插件的原理是什么？</h3><ol>\n<li>Mybatis使用RowBounds对象进行分页，也可以直接编写sql实现分页，也可以使用Mybatis的分页插件。</li>\n<li>分页插件的原理：实现Mybatis提供的接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql。</li>\n</ol>\n<p>举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10</p>\n<h3 id=\"4、简述Mybatis的插件运行原理，以及如何编写一个插件？\"><a href=\"#4、简述Mybatis的插件运行原理，以及如何编写一个插件？\" class=\"headerlink\" title=\"4、简述Mybatis的插件运行原理，以及如何编写一个插件？\"></a>4、简述Mybatis的插件运行原理，以及如何编写一个插件？</h3><ol>\n<li>Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis通过动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</li>\n<li>实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</li>\n</ol>\n<h3 id=\"5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？\"><a href=\"#5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？\" class=\"headerlink\" title=\"5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？\"></a>5、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h3><ol>\n<li>Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。</li>\n<li>Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind。</li>\n<li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</li>\n</ol>\n<h3 id=\"6、-和-的区别是什么？\"><a href=\"#6、-和-的区别是什么？\" class=\"headerlink\" title=\"6、#{}和${}的区别是什么？\"></a>6、#{}和${}的区别是什么？</h3><ol>\n<li>#{}是预编译处理，${}是字符串替换。</li>\n<li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>\n<li>Mybatis在处理${}时，就是把${}替换成变量的值。</li>\n<li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li>\n</ol>\n<h3 id=\"7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？\"><a href=\"#7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？\" class=\"headerlink\" title=\"7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？\"></a>7、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p>\n<h3 id=\"8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\"><a href=\"#8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\" class=\"headerlink\" title=\"8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？\"></a>8、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h3><ol>\n<li>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</li>\n<li>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</li>\n</ol>\n<h3 id=\"9、MyBatis与Hibernate有哪些不同？\"><a href=\"#9、MyBatis与Hibernate有哪些不同？\" class=\"headerlink\" title=\"9、MyBatis与Hibernate有哪些不同？\"></a>9、MyBatis与Hibernate有哪些不同？</h3><ol>\n<li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</li>\n<li>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</li>\n<li>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</li>\n</ol>\n<p>总之，按照用户的需求在有限的资源环境下只要能做出维护性、扩展性良好的软件架构都是好架构，所以框架只有适合才是最好。</p>\n<h3 id=\"10、MyBatis的好处是什么？\"><a href=\"#10、MyBatis的好处是什么？\" class=\"headerlink\" title=\"10、MyBatis的好处是什么？\"></a>10、MyBatis的好处是什么？</h3><ol>\n<li>MyBatis把sql语句从Java源程序中独立出来，放在单独的XML文件中编写，给程序的维护带来了很大便利。</li>\n<li>MyBatis封装了底层JDBC API的调用细节，并能自动将结果集转换成Java Bean对象，大大简化了Java数据库编程的重复工作。</li>\n<li>因为MyBatis需要程序员自己去编写sql语句，程序员可以结合数据库自身的特点灵活控制sql语句，因此能够实现比Hibernate等全自动orm框架更高的查询效率，能够完成复杂查询。</li>\n</ol>\n<h3 id=\"11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？\"><a href=\"#11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？\" class=\"headerlink\" title=\"11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？\"></a>11、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</h3><p>Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parametermap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultmap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</delete></update></insert></select></resultmap></parametermap></p>\n<h3 id=\"12、什么是MyBatis的接口绑定-有什么好处？\"><a href=\"#12、什么是MyBatis的接口绑定-有什么好处？\" class=\"headerlink\" title=\"12、什么是MyBatis的接口绑定,有什么好处？\"></a>12、什么是MyBatis的接口绑定,有什么好处？</h3><p>接口映射就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定,我们直接调用接口方法就可以,这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p>\n<h3 id=\"13、接口绑定有几种实现方式-分别是怎么实现的\"><a href=\"#13、接口绑定有几种实现方式-分别是怎么实现的\" class=\"headerlink\" title=\"13、接口绑定有几种实现方式,分别是怎么实现的?\"></a>13、接口绑定有几种实现方式,分别是怎么实现的?</h3><p>接口绑定有两种实现方式,一种是通过注解绑定,就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定,另外一种就是通过xml里面写SQL来绑定,在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。</p>\n<h3 id=\"14、什么情况下用注解绑定-什么情况下用xml绑定？\"><a href=\"#14、什么情况下用注解绑定-什么情况下用xml绑定？\" class=\"headerlink\" title=\"14、什么情况下用注解绑定,什么情况下用xml绑定？\"></a>14、什么情况下用注解绑定,什么情况下用xml绑定？</h3><p>当Sql语句比较简单时候,用注解绑定；当SQL语句比较复杂时候,用xml绑定,一般用xml绑定的比较多</p>\n<h3 id=\"15、MyBatis实现一对一有几种方式-具体怎么操作的？\"><a href=\"#15、MyBatis实现一对一有几种方式-具体怎么操作的？\" class=\"headerlink\" title=\"15、MyBatis实现一对一有几种方式?具体怎么操作的？\"></a>15、MyBatis实现一对一有几种方式?具体怎么操作的？</h3><p>有联合查询和嵌套查询,联合查询是几个表联合查询,只查询一次,通过在resultMap里面配置association节点配置一对一的类就可以完成;嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过association配置,但另外一个表的查询通过select属性配置。</p>\n<h3 id=\"16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？\"><a href=\"#16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？\" class=\"headerlink\" title=\"16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？\"></a>16、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别？</h3><p>能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。</p>\n<p>关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。</p>\n<h3 id=\"17、MyBatis里面的动态Sql是怎么设定的-用什么语法\"><a href=\"#17、MyBatis里面的动态Sql是怎么设定的-用什么语法\" class=\"headerlink\" title=\"17、MyBatis里面的动态Sql是怎么设定的?用什么语法?\"></a>17、MyBatis里面的动态Sql是怎么设定的?用什么语法?</h3><p>MyBatis里面的动态Sql一般是通过if节点来实现,通过OGNL语法来实现,但是如果要写的完整,必须配合where,trim节点,where节点是判断包含节点有内容就插入where,否则不插入,trim节点是用来判断如果动态语句是以and 或or开始,那么会自动把这个and或者or取掉。</p>\n<h3 id=\"18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\"><a href=\"#18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\" class=\"headerlink\" title=\"18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？\"></a>18、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</h3><p>第一种是使用<resultmap>标签，逐一定义列名和对象属性名之间的映射关系。</resultmap></p>\n<p>第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p>\n<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>\n<h3 id=\"19、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？\"><a href=\"#19、Xml映射文件中，除了常见的select-insert-updae-delete标签之外，还有哪些标签？\" class=\"headerlink\" title=\"19、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？\"></a>19、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</h3><p>还有很多其他的标签，<resultmap>、<parametermap>、<sql>、<include>、<selectkey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectkey>为不支持自增的主键生成策略标签。</selectkey></include></sql></selectkey></include></sql></parametermap></resultmap></p>\n<h3 id=\"20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？\"><a href=\"#20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？\" class=\"headerlink\" title=\"20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？\"></a>20、当实体类中的属性名和表中的字段名不一样，如果将查询的结果封装到指定pojo？</h3><ol>\n<li>通过在查询的sql语句中定义字段名的别名。</li>\n<li>通过<resultmap>来映射字段名和实体类属性名的一一对应的关系。</resultmap></li>\n</ol>\n<h3 id=\"21、模糊查询like语句该怎么写\"><a href=\"#21、模糊查询like语句该怎么写\" class=\"headerlink\" title=\"21、模糊查询like语句该怎么写\"></a>21、模糊查询like语句该怎么写</h3><ol>\n<li>在java中拼接通配符，通过#{}赋值</li>\n<li>在Sql语句中拼接通配符 （不安全 会引起Sql注入）</li>\n</ol>\n<h3 id=\"22、通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？\"><a href=\"#22、通常一个Xml映射文件，都会写一个Dao接口与之对应-Dao的工作原理，是否可以重载？\" class=\"headerlink\" title=\"22、通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？\"></a>22、通常一个Xml映射文件，都会写一个Dao接口与之对应, Dao的工作原理，是否可以重载？</h3><p>不能重载，因为通过Dao寻找Xml对应的sql的时候全限名+方法名的保存和寻找策略。接口工作原理为jdk动态代理原理，运行时会为dao生成proxy，代理对象会拦截接口方法，去执行对应的sql返回数据。</p>\n<h3 id=\"23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？\"><a href=\"#23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？\" class=\"headerlink\" title=\"23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？\"></a>23、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</h3><p>虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p>\n<h3 id=\"24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？\"><a href=\"#24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？\" class=\"headerlink\" title=\"24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？\"></a>24、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h3><p>不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p>\n<h3 id=\"25、Mybatis中如何执行批处理？\"><a href=\"#25、Mybatis中如何执行批处理？\" class=\"headerlink\" title=\"25、Mybatis中如何执行批处理？\"></a>25、Mybatis中如何执行批处理？</h3><p>使用BatchExecutor完成批处理。</p>\n<h3 id=\"26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？\"><a href=\"#26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？\" class=\"headerlink\" title=\"26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？\"></a>26、Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h3><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。1）SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。2）ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map3）BatchExecutor：完成批处理。</p>\n<h3 id=\"27、Mybatis中如何指定使用哪一种Executor执行器？\"><a href=\"#27、Mybatis中如何指定使用哪一种Executor执行器？\" class=\"headerlink\" title=\"27、Mybatis中如何指定使用哪一种Executor执行器？\"></a>27、Mybatis中如何指定使用哪一种Executor执行器？</h3><p>在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。</p>\n<h3 id=\"28、Mybatis执行批量插入，能返回数据库主键列表吗？\"><a href=\"#28、Mybatis执行批量插入，能返回数据库主键列表吗？\" class=\"headerlink\" title=\"28、Mybatis执行批量插入，能返回数据库主键列表吗？\"></a>28、Mybatis执行批量插入，能返回数据库主键列表吗？</h3><p>能，JDBC都能，Mybatis当然也能。</p>\n<h3 id=\"29、Mybatis是否可以映射Enum枚举类？\"><a href=\"#29、Mybatis是否可以映射Enum枚举类？\" class=\"headerlink\" title=\"29、Mybatis是否可以映射Enum枚举类？\"></a>29、Mybatis是否可以映射Enum枚举类？</h3><p>Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p>\n<h3 id=\"30、如何获取自动生成的-主-键值？\"><a href=\"#30、如何获取自动生成的-主-键值？\" class=\"headerlink\" title=\"30、如何获取自动生成的(主)键值？\"></a>30、如何获取自动生成的(主)键值？</h3><p>配置文件设置usegeneratedkeys 为 true。</p>\n<h3 id=\"31、在mapper中如何传递多个参数？\"><a href=\"#31、在mapper中如何传递多个参数？\" class=\"headerlink\" title=\"31、在mapper中如何传递多个参数？\"></a>31、在mapper中如何传递多个参数？</h3><ol>\n<li>直接在方法中传递参数，xml文件用#{0} #{1}来获取</li>\n<li>使用 @param 注解:这样可以直接在xml文件中通过#{name}来获取</li>\n</ol>\n<h3 id=\"32、resultType-resultMap的区别？\"><a href=\"#32、resultType-resultMap的区别？\" class=\"headerlink\" title=\"32、resultType resultMap的区别？\"></a>32、resultType resultMap的区别？</h3><ol>\n<li>类的名字和数据库相同时，可以直接设置resultType参数为Pojo类</li>\n<li>若不同，需要设置resultMap 将结果名字和Pojo名字进行转换</li>\n</ol>\n<h3 id=\"33、使用MyBatis的mapper接口调用时有哪些要求？\"><a href=\"#33、使用MyBatis的mapper接口调用时有哪些要求？\" class=\"headerlink\" title=\"33、使用MyBatis的mapper接口调用时有哪些要求？\"></a>33、使用MyBatis的mapper接口调用时有哪些要求？</h3><ol>\n<li>Mapper接口方法名和mapper.xml中定义的每个sql的id相同</li>\n<li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同</li>\n<li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同</li>\n<li>Mapper.xml文件中的namespace即是mapper接口的类路径。</li>\n</ol>\n<h3 id=\"34、Mybatis比IBatis比较大的几个改进是什么？\"><a href=\"#34、Mybatis比IBatis比较大的几个改进是什么？\" class=\"headerlink\" title=\"34、Mybatis比IBatis比较大的几个改进是什么？\"></a>34、Mybatis比IBatis比较大的几个改进是什么？</h3><ol>\n<li>有接口绑定,包括注解绑定sql和xml绑定Sql。</li>\n<li>动态sql由原来的节点配置变成OGNL表达式3） 在一对一,一对多的时候引进了association,在一对多的时候引入了collection节点,不过都是在resultMap里面配置。</li>\n</ol>\n<h3 id=\"35、IBatis和MyBatis在核心处理类分别叫什么？\"><a href=\"#35、IBatis和MyBatis在核心处理类分别叫什么？\" class=\"headerlink\" title=\"35、IBatis和MyBatis在核心处理类分别叫什么？\"></a>35、IBatis和MyBatis在核心处理类分别叫什么？</h3><p>IBatis里面的核心处理类交SqlMapClient,MyBatis里面的核心处理类叫做SqlSession。</p>\n<h3 id=\"36、IBatis和MyBatis在细节上的不同有哪些？\"><a href=\"#36、IBatis和MyBatis在细节上的不同有哪些？\" class=\"headerlink\" title=\"36、IBatis和MyBatis在细节上的不同有哪些？\"></a>36、IBatis和MyBatis在细节上的不同有哪些？</h3><ol>\n<li>在sql里面变量命名有原来的#变量# 变成了#{变量}。</li>\n<li>原来的 $变量$ 变成了 ${变量}。</li>\n<li>原来在sql节点里面的class都换名字交type。</li>\n<li>原来的queryForObject queryForList 变成了selectOne selectList5）原来的别名设置在映射文件里面放在了核心配置文件里。</li>\n</ol>"},{"title":"ZooKeeper相关","date":"2018-06-03T04:42:46.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## zookeeper特点\n### zookeeper是什么\n\nzookeeper 是一个开源的分布式协调服务，是分布式数据一致性的解决方案。\n\nzookeeper 本质上是一个分布式的小文件存储系统，提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理，从而用来维护和监控你存储的数据的状态变化，通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。\n\n### zookeeper能做什么\n\n简单来说，zookeeper 主要做两件事，数据管理和监听服务。\n\n分布式应用程序可以基于 zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、leader 选举、分布式锁和分布式队列等功能。\n\nzookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。 服务生产者将自己提供的服务注册到 zookeeper 中心，服务的消费者在进行服务调用的时候先到 zookeeper 中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo 架构中 zookeeper 就担任了注册中心这一角色。为了保证高可用，最好是以集群形态来部署 zookeeper，只要半数以上节点存活，zookeeper  就能正常服务。\n\n<!-- more -->\n\n\nzookeeper 主要提供下面几个功能：\n\n1. 集群管理：容错、负载均衡。\n2. 配置文件的集中管理。\n3. 集群的入口。\n\n### Session会话\n\nSession 指的是 zookeeper  服务器与客户端会话。在 zookeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过**心跳检测**与服务器保持有效的会话，也能够向 zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的**Watch事件通知**。 \n\nSession 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。\n\n在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID 是 zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。\n\n### 心跳检测机制\n\n机器间的心跳检测机制是指在分布式环境中，不同机器（或进程）之间需要检测到彼此是否在正常运行，例如A机器需要知道B机器是否正常运行。在传统的开发中，我们通常是通过主机直接是否可以相互PING通来判断，更复杂一点的话，则会通过在机器之间建立长连接，通过TCP连接固有的心跳检测机制来实现上层机器的心跳检测，这些都是非常常见的心跳检测方法。\n\n下面来看看如何使用ZK来实现分布式机器（进程）间的心跳检测。\n基于ZK的临时节点的特性，可以让不同的进程都在ZK的一个指定节点下创建临时子节点，不同的进程直接可以根据这个临时子节点来判断对应的进程是否存活。通过这种方式，检测和被检测系统直接并不需要直接相关联，而是通过ZK上的某个节点进行关联，大大减少了系统耦合。\n\n### Watcher监听事件\n\n1. 监听的 Znode 被创建、删除、版本后变更(或数据变更)、子节点发生变更 会触发事件。\n2. Watcher 是一次性的，一旦触发将会永久失效，如果需要反复监听就需要反复注册。\n\n### Znode节点\n\n在 zookeeper 中，“节点\"分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。\n\n* 持久节点：一旦创建将一直存在于服务端，除非客户端删除。\n* 持久顺序节点： 在持久节点基础上，通过节点路径后缀一串序号来区分多个子节点创建的先后顺序。\n* 临时节点：生命周期与客户端会话保持一致。\n* 临时顺序节点：\n\n### Stat节点状态\n\nzookeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，zookeeper 都会为其维护一个叫作 Stat 的数据结构，Stat 中记录了这个 ZNode 的三个数据版本：\n* version（当前ZNode的版本）\n* cversion（当前ZNode子节点的版本）\n* cversion（当前ZNode的ACL版本）\n\n### ACL权限控制\n\nzookeeper 有以下五种权限：\n* CREATE：创建子节点的权限。\n* READ：获取子节点和子节点列表的权限。\n* WRITE：更新节点数据的权限。\n* DELETE：删除子节点的权限。\n* ADMIN：设置节点ACL的权限。\n其中需要注意的是，CREATE 和 DELETE 这两种权限都是针对**子节点**的权限控制。\n\n## zookeeper支持的协议\n\n### ZAB协议 & Paxos算法\n\nPaxos 算法应该可以说是  zookeeper 的灵魂了。但是，zookeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在zookeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 zookeeper 设计的崩溃可恢复的原子消息广播算法。\n\n### ZAB协议\n\nZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，zookeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。\n\n### ZAB协议的崩溃恢复和原子广播\n\n在整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。\n\n当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。 当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。\n\n## zookeeper集群\n\n### 集群角色\n\n* leader：负责进行投票的发起和决议，更新系统状态。\n* follower：参与leader选举投票或事务请求投票，处理读请求 和 转发写请求给 leader。\n* observer：弱化版的follower，不参与投票，只同步 leader 的状态，提高读取速度。\n\n### 单机模式的安装\n\n* Step1：配置JAVA环境，检验环境：java -version\n* Step2：下载并解压zookeeper\n```xml\ncd /usr/local\nwget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz\ntar -zxvf zookeeper-3.4.12.tar.gz\ncd zookeeper-3.4.12\n```\n* Step3：重命名配置文件zoo_sample.cfg\n```xml\ncp conf/zoo_sample.cfg conf/zoo.cfg\n```\n* Step4：启动zookeeper\n```xml\nbin/zkServer.sh start\n```\n* Step5：检测是否成功启动，用zookeeper客户端连接下服务端\n```xml\nbin/zkCli.sh\n```\n\n### 集群模式的搭建\n\n本例搭建的是伪集群模式，即一台机器上启动三个zookeeper实例组成集群，真正的集群模式无非就是实例IP地址不同，搭建方法没有区别\nStep1：配置JAVA环境，检验环境：java -version\nStep2：下载并解压zookeeper\n```xml\n# cd /usr/local\n# wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz\n# tar -zxvf zookeeper-3.4.12.tar.gz\n# cd zookeeper-3.4.12\n```\nStep3：重命名 zoo_sample.cfg文件\n```xml\n# cp conf/zoo_sample.cfg conf/zoo-1.cfg\n```\nStep4：修改配置文件zoo-1.cfg，原配置文件里有的，修改成下面的值，没有的则加上\n```xml\n# vim conf/zoo-1.cfg\n```\n\ndataDir=/tmp/zookeeper-1\nclientPort=2181\nserver.1=127.0.0.1:2888:3888\nserver.2=127.0.0.1:2889:3889\nserver.3=127.0.0.1:2890:3890\n\nStep5：再从zoo-1.cfg复制两个配置文件zoo-2.cfg和zoo-3.cfg，只需修改dataDir和clientPort不同即可\n```\n# cp conf/zoo-1.cfg conf/zoo-2.cfg\n# cp conf/zoo-1.cfg conf/zoo-3.cfg\n# vim conf/zoo-2.cfg\n```\ndataDir=/tmp/zookeeper-2\nclientPort=2182\n\n```\n# vim conf/zoo-2.cfg\n```\ndataDir=/tmp/zookeeper-3\nclientPort=2183\n\nStep6：标识Server ID\n创建三个文件夹/tmp/zookeeper-1，/tmp/zookeeper-2，/tmp/zookeeper-2，在每个目录中创建文件myid 文件，写入当前实例的server id，即1.2.3\n\n```xml\n# cd /tmp/zookeeper-1\n# vim myid\n1\n# cd /tmp/zookeeper-2\n# vim myid\n2\n# cd /tmp/zookeeper-3\n# vim myid\n3\n```\n\nStep7：启动三个zookeeper实例\n```xml\n# bin/zkServer.sh start conf/zoo-1.cfg\n# bin/zkServer.sh start conf/zoo-2.cfg\n# bin/zkServer.sh start conf/zoo-3.cfg\n```\n### 集群中leader的选举\n\n选举场景：1、集群刚启动时   2、leader退出\n\n1. 第一次每个 follower 都会选自己为 leader 服务器，也就是投出的是自己的服务器 ID 和 ZXID。\n2. 每个 follower 都会受到来自其他 follower 的信息，并先按 ZXID 再按服务器 ID 最大选择选出新的选票，再次发出去。\n3. 若某台服务器得到超半数的选票将当选为新的 leader。\n\n### 集群数据同步流程\n\n完成 leader 选举后，leader 等待 follower 来连接进行同步\n1. leader 等待 follower 连接。\n2. follower 将最大的 zxid 发送给 leader。\n3. leader 根据 zxid 确定同步点。\n4. 完成同步后，leader 给 follower 发送 uptodate 消息。\n5. follower 收到 uptodate 后，又可以重新接受 client 连接请求了。\n\n### 集群中事务请求处理流程\n\n1. 所有事务请求都交由 leader 服务器来处理，leader 服务器会将一个事务请求转为一个proposal，并为其生成一个ZXID(事务ID)。\n2. 之后 leader 服务器会将 proposal 放入每个 follower 的队列中（leader会为每个follower分配一个队列），并发送给 follower。\n3. follower收到 proposal 后，会将事务日志写入磁盘，并在成功后返回 leader 一个ACK。\n4. leader 只要收到过半的 follower 的ACK响应，就会广播一个 commit 消息给 follower 通知进行 proposal 的提交，同时自身也会完成。\n\n\n\n## zookeeper的应用场景\n\n### 实现命名服务(Name Service)\n\n命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务，远程对象等等——这些我们都可以统称他们为名字（Name）。\n\n其中较为常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表。通过在 zookeeper里创建顺序节点，能够很容易创建一个全局唯一的路径，这个路径就可以作为一个名字。\n\nzookeeper 的命名服务即生成全局唯一的ID。\n\n### 实现分布式协调/通知\n\nzookeeper 中特有 Watcher 注册与异步通知机制，能够很好的实现分布式环境下不同机器，甚至不同系统之间的通知与协调，从而实现对数据变更的实时处理。使用方法通常是不同的客户端都对ZK上同一个 ZNode 进行注册，监听 ZNode 的变化（包括ZNode本身内容及子节点的），如果 ZNode 发生了变化，那么所有订阅的客户端都能够接收到相应的Watcher通知，并做出相应的处理。\n\nZK的分布式协调/通知，是一种通用的分布式系统机器间的通信方式。\n\n### 实现分布式锁\n\n有两种实现：\n1. 集群中所有机器都去竞争创建某个节点，创建成功的机器相当于获取了这个锁。\n2. 所有机器都去某个父节点下创建子节点，序号最小的机器获取锁。\n\n### 实现分布式队列\n\n1. 同步队列：在指定目录下创建 watcher，当监控到子节点数目达到指定值后再开始使用，进行读取消费。\n2. FIFO队列：读取序列号最小的节点进行消费，例如实现生产者和消费者模型。\n在此场景下，znode 节点值存储的可能就是消息本身。\n","source":"_posts/zookeeper.md","raw":"---\ntitle: ZooKeeper相关\ndate: 2018-06-03 12:42:46\ncategories: Java\ntags:\n  - 分布式\n  - zookeeper\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## zookeeper特点\n### zookeeper是什么\n\nzookeeper 是一个开源的分布式协调服务，是分布式数据一致性的解决方案。\n\nzookeeper 本质上是一个分布式的小文件存储系统，提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理，从而用来维护和监控你存储的数据的状态变化，通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。\n\n### zookeeper能做什么\n\n简单来说，zookeeper 主要做两件事，数据管理和监听服务。\n\n分布式应用程序可以基于 zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、leader 选举、分布式锁和分布式队列等功能。\n\nzookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。 服务生产者将自己提供的服务注册到 zookeeper 中心，服务的消费者在进行服务调用的时候先到 zookeeper 中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo 架构中 zookeeper 就担任了注册中心这一角色。为了保证高可用，最好是以集群形态来部署 zookeeper，只要半数以上节点存活，zookeeper  就能正常服务。\n\n<!-- more -->\n\n\nzookeeper 主要提供下面几个功能：\n\n1. 集群管理：容错、负载均衡。\n2. 配置文件的集中管理。\n3. 集群的入口。\n\n### Session会话\n\nSession 指的是 zookeeper  服务器与客户端会话。在 zookeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过**心跳检测**与服务器保持有效的会话，也能够向 zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的**Watch事件通知**。 \n\nSession 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。\n\n在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID 是 zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。\n\n### 心跳检测机制\n\n机器间的心跳检测机制是指在分布式环境中，不同机器（或进程）之间需要检测到彼此是否在正常运行，例如A机器需要知道B机器是否正常运行。在传统的开发中，我们通常是通过主机直接是否可以相互PING通来判断，更复杂一点的话，则会通过在机器之间建立长连接，通过TCP连接固有的心跳检测机制来实现上层机器的心跳检测，这些都是非常常见的心跳检测方法。\n\n下面来看看如何使用ZK来实现分布式机器（进程）间的心跳检测。\n基于ZK的临时节点的特性，可以让不同的进程都在ZK的一个指定节点下创建临时子节点，不同的进程直接可以根据这个临时子节点来判断对应的进程是否存活。通过这种方式，检测和被检测系统直接并不需要直接相关联，而是通过ZK上的某个节点进行关联，大大减少了系统耦合。\n\n### Watcher监听事件\n\n1. 监听的 Znode 被创建、删除、版本后变更(或数据变更)、子节点发生变更 会触发事件。\n2. Watcher 是一次性的，一旦触发将会永久失效，如果需要反复监听就需要反复注册。\n\n### Znode节点\n\n在 zookeeper 中，“节点\"分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。\n\n* 持久节点：一旦创建将一直存在于服务端，除非客户端删除。\n* 持久顺序节点： 在持久节点基础上，通过节点路径后缀一串序号来区分多个子节点创建的先后顺序。\n* 临时节点：生命周期与客户端会话保持一致。\n* 临时顺序节点：\n\n### Stat节点状态\n\nzookeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，zookeeper 都会为其维护一个叫作 Stat 的数据结构，Stat 中记录了这个 ZNode 的三个数据版本：\n* version（当前ZNode的版本）\n* cversion（当前ZNode子节点的版本）\n* cversion（当前ZNode的ACL版本）\n\n### ACL权限控制\n\nzookeeper 有以下五种权限：\n* CREATE：创建子节点的权限。\n* READ：获取子节点和子节点列表的权限。\n* WRITE：更新节点数据的权限。\n* DELETE：删除子节点的权限。\n* ADMIN：设置节点ACL的权限。\n其中需要注意的是，CREATE 和 DELETE 这两种权限都是针对**子节点**的权限控制。\n\n## zookeeper支持的协议\n\n### ZAB协议 & Paxos算法\n\nPaxos 算法应该可以说是  zookeeper 的灵魂了。但是，zookeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在zookeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 zookeeper 设计的崩溃可恢复的原子消息广播算法。\n\n### ZAB协议\n\nZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，zookeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。\n\n### ZAB协议的崩溃恢复和原子广播\n\n在整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。\n\n当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。 当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。\n\n## zookeeper集群\n\n### 集群角色\n\n* leader：负责进行投票的发起和决议，更新系统状态。\n* follower：参与leader选举投票或事务请求投票，处理读请求 和 转发写请求给 leader。\n* observer：弱化版的follower，不参与投票，只同步 leader 的状态，提高读取速度。\n\n### 单机模式的安装\n\n* Step1：配置JAVA环境，检验环境：java -version\n* Step2：下载并解压zookeeper\n```xml\ncd /usr/local\nwget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz\ntar -zxvf zookeeper-3.4.12.tar.gz\ncd zookeeper-3.4.12\n```\n* Step3：重命名配置文件zoo_sample.cfg\n```xml\ncp conf/zoo_sample.cfg conf/zoo.cfg\n```\n* Step4：启动zookeeper\n```xml\nbin/zkServer.sh start\n```\n* Step5：检测是否成功启动，用zookeeper客户端连接下服务端\n```xml\nbin/zkCli.sh\n```\n\n### 集群模式的搭建\n\n本例搭建的是伪集群模式，即一台机器上启动三个zookeeper实例组成集群，真正的集群模式无非就是实例IP地址不同，搭建方法没有区别\nStep1：配置JAVA环境，检验环境：java -version\nStep2：下载并解压zookeeper\n```xml\n# cd /usr/local\n# wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz\n# tar -zxvf zookeeper-3.4.12.tar.gz\n# cd zookeeper-3.4.12\n```\nStep3：重命名 zoo_sample.cfg文件\n```xml\n# cp conf/zoo_sample.cfg conf/zoo-1.cfg\n```\nStep4：修改配置文件zoo-1.cfg，原配置文件里有的，修改成下面的值，没有的则加上\n```xml\n# vim conf/zoo-1.cfg\n```\n\ndataDir=/tmp/zookeeper-1\nclientPort=2181\nserver.1=127.0.0.1:2888:3888\nserver.2=127.0.0.1:2889:3889\nserver.3=127.0.0.1:2890:3890\n\nStep5：再从zoo-1.cfg复制两个配置文件zoo-2.cfg和zoo-3.cfg，只需修改dataDir和clientPort不同即可\n```\n# cp conf/zoo-1.cfg conf/zoo-2.cfg\n# cp conf/zoo-1.cfg conf/zoo-3.cfg\n# vim conf/zoo-2.cfg\n```\ndataDir=/tmp/zookeeper-2\nclientPort=2182\n\n```\n# vim conf/zoo-2.cfg\n```\ndataDir=/tmp/zookeeper-3\nclientPort=2183\n\nStep6：标识Server ID\n创建三个文件夹/tmp/zookeeper-1，/tmp/zookeeper-2，/tmp/zookeeper-2，在每个目录中创建文件myid 文件，写入当前实例的server id，即1.2.3\n\n```xml\n# cd /tmp/zookeeper-1\n# vim myid\n1\n# cd /tmp/zookeeper-2\n# vim myid\n2\n# cd /tmp/zookeeper-3\n# vim myid\n3\n```\n\nStep7：启动三个zookeeper实例\n```xml\n# bin/zkServer.sh start conf/zoo-1.cfg\n# bin/zkServer.sh start conf/zoo-2.cfg\n# bin/zkServer.sh start conf/zoo-3.cfg\n```\n### 集群中leader的选举\n\n选举场景：1、集群刚启动时   2、leader退出\n\n1. 第一次每个 follower 都会选自己为 leader 服务器，也就是投出的是自己的服务器 ID 和 ZXID。\n2. 每个 follower 都会受到来自其他 follower 的信息，并先按 ZXID 再按服务器 ID 最大选择选出新的选票，再次发出去。\n3. 若某台服务器得到超半数的选票将当选为新的 leader。\n\n### 集群数据同步流程\n\n完成 leader 选举后，leader 等待 follower 来连接进行同步\n1. leader 等待 follower 连接。\n2. follower 将最大的 zxid 发送给 leader。\n3. leader 根据 zxid 确定同步点。\n4. 完成同步后，leader 给 follower 发送 uptodate 消息。\n5. follower 收到 uptodate 后，又可以重新接受 client 连接请求了。\n\n### 集群中事务请求处理流程\n\n1. 所有事务请求都交由 leader 服务器来处理，leader 服务器会将一个事务请求转为一个proposal，并为其生成一个ZXID(事务ID)。\n2. 之后 leader 服务器会将 proposal 放入每个 follower 的队列中（leader会为每个follower分配一个队列），并发送给 follower。\n3. follower收到 proposal 后，会将事务日志写入磁盘，并在成功后返回 leader 一个ACK。\n4. leader 只要收到过半的 follower 的ACK响应，就会广播一个 commit 消息给 follower 通知进行 proposal 的提交，同时自身也会完成。\n\n\n\n## zookeeper的应用场景\n\n### 实现命名服务(Name Service)\n\n命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务，远程对象等等——这些我们都可以统称他们为名字（Name）。\n\n其中较为常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表。通过在 zookeeper里创建顺序节点，能够很容易创建一个全局唯一的路径，这个路径就可以作为一个名字。\n\nzookeeper 的命名服务即生成全局唯一的ID。\n\n### 实现分布式协调/通知\n\nzookeeper 中特有 Watcher 注册与异步通知机制，能够很好的实现分布式环境下不同机器，甚至不同系统之间的通知与协调，从而实现对数据变更的实时处理。使用方法通常是不同的客户端都对ZK上同一个 ZNode 进行注册，监听 ZNode 的变化（包括ZNode本身内容及子节点的），如果 ZNode 发生了变化，那么所有订阅的客户端都能够接收到相应的Watcher通知，并做出相应的处理。\n\nZK的分布式协调/通知，是一种通用的分布式系统机器间的通信方式。\n\n### 实现分布式锁\n\n有两种实现：\n1. 集群中所有机器都去竞争创建某个节点，创建成功的机器相当于获取了这个锁。\n2. 所有机器都去某个父节点下创建子节点，序号最小的机器获取锁。\n\n### 实现分布式队列\n\n1. 同步队列：在指定目录下创建 watcher，当监控到子节点数目达到指定值后再开始使用，进行读取消费。\n2. FIFO队列：读取序列号最小的节点进行消费，例如实现生产者和消费者模型。\n在此场景下，znode 节点值存储的可能就是消息本身。\n","slug":"zookeeper","published":1,"updated":"2020-01-13T02:46:36.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61bjx003xa6ybjfgvguy3","content":"<h2 id=\"zookeeper特点\"><a href=\"#zookeeper特点\" class=\"headerlink\" title=\"zookeeper特点\"></a>zookeeper特点</h2><h3 id=\"zookeeper是什么\"><a href=\"#zookeeper是什么\" class=\"headerlink\" title=\"zookeeper是什么\"></a>zookeeper是什么</h3><p>zookeeper 是一个开源的分布式协调服务，是分布式数据一致性的解决方案。</p>\n<p>zookeeper 本质上是一个分布式的小文件存储系统，提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理，从而用来维护和监控你存储的数据的状态变化，通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。</p>\n<h3 id=\"zookeeper能做什么\"><a href=\"#zookeeper能做什么\" class=\"headerlink\" title=\"zookeeper能做什么\"></a>zookeeper能做什么</h3><p>简单来说，zookeeper 主要做两件事，数据管理和监听服务。</p>\n<p>分布式应用程序可以基于 zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、leader 选举、分布式锁和分布式队列等功能。</p>\n<p>zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。 服务生产者将自己提供的服务注册到 zookeeper 中心，服务的消费者在进行服务调用的时候先到 zookeeper 中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo 架构中 zookeeper 就担任了注册中心这一角色。为了保证高可用，最好是以集群形态来部署 zookeeper，只要半数以上节点存活，zookeeper  就能正常服务。</p>\n<a id=\"more\"></a>\n\n\n<p>zookeeper 主要提供下面几个功能：</p>\n<ol>\n<li>集群管理：容错、负载均衡。</li>\n<li>配置文件的集中管理。</li>\n<li>集群的入口。</li>\n</ol>\n<h3 id=\"Session会话\"><a href=\"#Session会话\" class=\"headerlink\" title=\"Session会话\"></a>Session会话</h3><p>Session 指的是 zookeeper  服务器与客户端会话。在 zookeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过<strong>心跳检测</strong>与服务器保持有效的会话，也能够向 zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的<strong>Watch事件通知</strong>。 </p>\n<p>Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>\n<p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID 是 zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</p>\n<h3 id=\"心跳检测机制\"><a href=\"#心跳检测机制\" class=\"headerlink\" title=\"心跳检测机制\"></a>心跳检测机制</h3><p>机器间的心跳检测机制是指在分布式环境中，不同机器（或进程）之间需要检测到彼此是否在正常运行，例如A机器需要知道B机器是否正常运行。在传统的开发中，我们通常是通过主机直接是否可以相互PING通来判断，更复杂一点的话，则会通过在机器之间建立长连接，通过TCP连接固有的心跳检测机制来实现上层机器的心跳检测，这些都是非常常见的心跳检测方法。</p>\n<p>下面来看看如何使用ZK来实现分布式机器（进程）间的心跳检测。<br>基于ZK的临时节点的特性，可以让不同的进程都在ZK的一个指定节点下创建临时子节点，不同的进程直接可以根据这个临时子节点来判断对应的进程是否存活。通过这种方式，检测和被检测系统直接并不需要直接相关联，而是通过ZK上的某个节点进行关联，大大减少了系统耦合。</p>\n<h3 id=\"Watcher监听事件\"><a href=\"#Watcher监听事件\" class=\"headerlink\" title=\"Watcher监听事件\"></a>Watcher监听事件</h3><ol>\n<li>监听的 Znode 被创建、删除、版本后变更(或数据变更)、子节点发生变更 会触发事件。</li>\n<li>Watcher 是一次性的，一旦触发将会永久失效，如果需要反复监听就需要反复注册。</li>\n</ol>\n<h3 id=\"Znode节点\"><a href=\"#Znode节点\" class=\"headerlink\" title=\"Znode节点\"></a>Znode节点</h3><p>在 zookeeper 中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。</p>\n<ul>\n<li>持久节点：一旦创建将一直存在于服务端，除非客户端删除。</li>\n<li>持久顺序节点： 在持久节点基础上，通过节点路径后缀一串序号来区分多个子节点创建的先后顺序。</li>\n<li>临时节点：生命周期与客户端会话保持一致。</li>\n<li>临时顺序节点：</li>\n</ul>\n<h3 id=\"Stat节点状态\"><a href=\"#Stat节点状态\" class=\"headerlink\" title=\"Stat节点状态\"></a>Stat节点状态</h3><p>zookeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，zookeeper 都会为其维护一个叫作 Stat 的数据结构，Stat 中记录了这个 ZNode 的三个数据版本：</p>\n<ul>\n<li>version（当前ZNode的版本）</li>\n<li>cversion（当前ZNode子节点的版本）</li>\n<li>cversion（当前ZNode的ACL版本）</li>\n</ul>\n<h3 id=\"ACL权限控制\"><a href=\"#ACL权限控制\" class=\"headerlink\" title=\"ACL权限控制\"></a>ACL权限控制</h3><p>zookeeper 有以下五种权限：</p>\n<ul>\n<li>CREATE：创建子节点的权限。</li>\n<li>READ：获取子节点和子节点列表的权限。</li>\n<li>WRITE：更新节点数据的权限。</li>\n<li>DELETE：删除子节点的权限。</li>\n<li>ADMIN：设置节点ACL的权限。<br>其中需要注意的是，CREATE 和 DELETE 这两种权限都是针对<strong>子节点</strong>的权限控制。</li>\n</ul>\n<h2 id=\"zookeeper支持的协议\"><a href=\"#zookeeper支持的协议\" class=\"headerlink\" title=\"zookeeper支持的协议\"></a>zookeeper支持的协议</h2><h3 id=\"ZAB协议-amp-Paxos算法\"><a href=\"#ZAB协议-amp-Paxos算法\" class=\"headerlink\" title=\"ZAB协议 &amp; Paxos算法\"></a>ZAB协议 &amp; Paxos算法</h3><p>Paxos 算法应该可以说是  zookeeper 的灵魂了。但是，zookeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在zookeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 zookeeper 设计的崩溃可恢复的原子消息广播算法。</p>\n<h3 id=\"ZAB协议\"><a href=\"#ZAB协议\" class=\"headerlink\" title=\"ZAB协议\"></a>ZAB协议</h3><p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，zookeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p>\n<h3 id=\"ZAB协议的崩溃恢复和原子广播\"><a href=\"#ZAB协议的崩溃恢复和原子广播\" class=\"headerlink\" title=\"ZAB协议的崩溃恢复和原子广播\"></a>ZAB协议的崩溃恢复和原子广播</h3><p>在整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。</p>\n<p>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。 当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p>\n<h2 id=\"zookeeper集群\"><a href=\"#zookeeper集群\" class=\"headerlink\" title=\"zookeeper集群\"></a>zookeeper集群</h2><h3 id=\"集群角色\"><a href=\"#集群角色\" class=\"headerlink\" title=\"集群角色\"></a>集群角色</h3><ul>\n<li>leader：负责进行投票的发起和决议，更新系统状态。</li>\n<li>follower：参与leader选举投票或事务请求投票，处理读请求 和 转发写请求给 leader。</li>\n<li>observer：弱化版的follower，不参与投票，只同步 leader 的状态，提高读取速度。</li>\n</ul>\n<h3 id=\"单机模式的安装\"><a href=\"#单机模式的安装\" class=\"headerlink\" title=\"单机模式的安装\"></a>单机模式的安装</h3><ul>\n<li><p>Step1：配置JAVA环境，检验环境：java -version</p>\n</li>\n<li><p>Step2：下载并解压zookeeper</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local</span><br><span class=\"line\">wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz</span><br><span class=\"line\">tar -zxvf zookeeper-3.4.12.tar.gz</span><br><span class=\"line\">cd zookeeper-3.4.12</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Step3：重命名配置文件zoo_sample.cfg</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp conf/zoo_sample.cfg conf/zoo.cfg</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Step4：启动zookeeper</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/zkServer.sh start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Step5：检测是否成功启动，用zookeeper客户端连接下服务端</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/zkCli.sh</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"集群模式的搭建\"><a href=\"#集群模式的搭建\" class=\"headerlink\" title=\"集群模式的搭建\"></a>集群模式的搭建</h3><p>本例搭建的是伪集群模式，即一台机器上启动三个zookeeper实例组成集群，真正的集群模式无非就是实例IP地址不同，搭建方法没有区别<br>Step1：配置JAVA环境，检验环境：java -version<br>Step2：下载并解压zookeeper</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cd /usr/local</span><br><span class=\"line\"># wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz</span><br><span class=\"line\"># tar -zxvf zookeeper-3.4.12.tar.gz</span><br><span class=\"line\"># cd zookeeper-3.4.12</span><br></pre></td></tr></table></figure>\n\n<p>Step3：重命名 zoo_sample.cfg文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cp conf/zoo_sample.cfg conf/zoo-1.cfg</span><br></pre></td></tr></table></figure>\n\n<p>Step4：修改配置文件zoo-1.cfg，原配置文件里有的，修改成下面的值，没有的则加上</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim conf/zoo-1.cfg</span><br></pre></td></tr></table></figure>\n\n<p>dataDir=/tmp/zookeeper-1<br>clientPort=2181<br>server.1=127.0.0.1:2888:3888<br>server.2=127.0.0.1:2889:3889<br>server.3=127.0.0.1:2890:3890</p>\n<p>Step5：再从zoo-1.cfg复制两个配置文件zoo-2.cfg和zoo-3.cfg，只需修改dataDir和clientPort不同即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cp conf/zoo-1.cfg conf/zoo-2.cfg</span><br><span class=\"line\"># cp conf/zoo-1.cfg conf/zoo-3.cfg</span><br><span class=\"line\"># vim conf/zoo-2.cfg</span><br></pre></td></tr></table></figure>\n\n<p>dataDir=/tmp/zookeeper-2<br>clientPort=2182</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim conf/zoo-2.cfg</span><br></pre></td></tr></table></figure>\n\n<p>dataDir=/tmp/zookeeper-3<br>clientPort=2183</p>\n<p>Step6：标识Server ID<br>创建三个文件夹/tmp/zookeeper-1，/tmp/zookeeper-2，/tmp/zookeeper-2，在每个目录中创建文件myid 文件，写入当前实例的server id，即1.2.3</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cd /tmp/zookeeper-1</span><br><span class=\"line\"># vim myid</span><br><span class=\"line\">1</span><br><span class=\"line\"># cd /tmp/zookeeper-2</span><br><span class=\"line\"># vim myid</span><br><span class=\"line\">2</span><br><span class=\"line\"># cd /tmp/zookeeper-3</span><br><span class=\"line\"># vim myid</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p>Step7：启动三个zookeeper实例</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># bin/zkServer.sh start conf/zoo-1.cfg</span><br><span class=\"line\"># bin/zkServer.sh start conf/zoo-2.cfg</span><br><span class=\"line\"># bin/zkServer.sh start conf/zoo-3.cfg</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集群中leader的选举\"><a href=\"#集群中leader的选举\" class=\"headerlink\" title=\"集群中leader的选举\"></a>集群中leader的选举</h3><p>选举场景：1、集群刚启动时   2、leader退出</p>\n<ol>\n<li>第一次每个 follower 都会选自己为 leader 服务器，也就是投出的是自己的服务器 ID 和 ZXID。</li>\n<li>每个 follower 都会受到来自其他 follower 的信息，并先按 ZXID 再按服务器 ID 最大选择选出新的选票，再次发出去。</li>\n<li>若某台服务器得到超半数的选票将当选为新的 leader。</li>\n</ol>\n<h3 id=\"集群数据同步流程\"><a href=\"#集群数据同步流程\" class=\"headerlink\" title=\"集群数据同步流程\"></a>集群数据同步流程</h3><p>完成 leader 选举后，leader 等待 follower 来连接进行同步</p>\n<ol>\n<li>leader 等待 follower 连接。</li>\n<li>follower 将最大的 zxid 发送给 leader。</li>\n<li>leader 根据 zxid 确定同步点。</li>\n<li>完成同步后，leader 给 follower 发送 uptodate 消息。</li>\n<li>follower 收到 uptodate 后，又可以重新接受 client 连接请求了。</li>\n</ol>\n<h3 id=\"集群中事务请求处理流程\"><a href=\"#集群中事务请求处理流程\" class=\"headerlink\" title=\"集群中事务请求处理流程\"></a>集群中事务请求处理流程</h3><ol>\n<li>所有事务请求都交由 leader 服务器来处理，leader 服务器会将一个事务请求转为一个proposal，并为其生成一个ZXID(事务ID)。</li>\n<li>之后 leader 服务器会将 proposal 放入每个 follower 的队列中（leader会为每个follower分配一个队列），并发送给 follower。</li>\n<li>follower收到 proposal 后，会将事务日志写入磁盘，并在成功后返回 leader 一个ACK。</li>\n<li>leader 只要收到过半的 follower 的ACK响应，就会广播一个 commit 消息给 follower 通知进行 proposal 的提交，同时自身也会完成。</li>\n</ol>\n<h2 id=\"zookeeper的应用场景\"><a href=\"#zookeeper的应用场景\" class=\"headerlink\" title=\"zookeeper的应用场景\"></a>zookeeper的应用场景</h2><h3 id=\"实现命名服务-Name-Service\"><a href=\"#实现命名服务-Name-Service\" class=\"headerlink\" title=\"实现命名服务(Name Service)\"></a>实现命名服务(Name Service)</h3><p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务，远程对象等等——这些我们都可以统称他们为名字（Name）。</p>\n<p>其中较为常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表。通过在 zookeeper里创建顺序节点，能够很容易创建一个全局唯一的路径，这个路径就可以作为一个名字。</p>\n<p>zookeeper 的命名服务即生成全局唯一的ID。</p>\n<h3 id=\"实现分布式协调-通知\"><a href=\"#实现分布式协调-通知\" class=\"headerlink\" title=\"实现分布式协调/通知\"></a>实现分布式协调/通知</h3><p>zookeeper 中特有 Watcher 注册与异步通知机制，能够很好的实现分布式环境下不同机器，甚至不同系统之间的通知与协调，从而实现对数据变更的实时处理。使用方法通常是不同的客户端都对ZK上同一个 ZNode 进行注册，监听 ZNode 的变化（包括ZNode本身内容及子节点的），如果 ZNode 发生了变化，那么所有订阅的客户端都能够接收到相应的Watcher通知，并做出相应的处理。</p>\n<p>ZK的分布式协调/通知，是一种通用的分布式系统机器间的通信方式。</p>\n<h3 id=\"实现分布式锁\"><a href=\"#实现分布式锁\" class=\"headerlink\" title=\"实现分布式锁\"></a>实现分布式锁</h3><p>有两种实现：</p>\n<ol>\n<li>集群中所有机器都去竞争创建某个节点，创建成功的机器相当于获取了这个锁。</li>\n<li>所有机器都去某个父节点下创建子节点，序号最小的机器获取锁。</li>\n</ol>\n<h3 id=\"实现分布式队列\"><a href=\"#实现分布式队列\" class=\"headerlink\" title=\"实现分布式队列\"></a>实现分布式队列</h3><ol>\n<li>同步队列：在指定目录下创建 watcher，当监控到子节点数目达到指定值后再开始使用，进行读取消费。</li>\n<li>FIFO队列：读取序列号最小的节点进行消费，例如实现生产者和消费者模型。<br>在此场景下，znode 节点值存储的可能就是消息本身。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"zookeeper特点\"><a href=\"#zookeeper特点\" class=\"headerlink\" title=\"zookeeper特点\"></a>zookeeper特点</h2><h3 id=\"zookeeper是什么\"><a href=\"#zookeeper是什么\" class=\"headerlink\" title=\"zookeeper是什么\"></a>zookeeper是什么</h3><p>zookeeper 是一个开源的分布式协调服务，是分布式数据一致性的解决方案。</p>\n<p>zookeeper 本质上是一个分布式的小文件存储系统，提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理，从而用来维护和监控你存储的数据的状态变化，通过监控这些数据状态的变化，从而可以达到基于数据的集群管理。</p>\n<h3 id=\"zookeeper能做什么\"><a href=\"#zookeeper能做什么\" class=\"headerlink\" title=\"zookeeper能做什么\"></a>zookeeper能做什么</h3><p>简单来说，zookeeper 主要做两件事，数据管理和监听服务。</p>\n<p>分布式应用程序可以基于 zookeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、leader 选举、分布式锁和分布式队列等功能。</p>\n<p>zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心。 服务生产者将自己提供的服务注册到 zookeeper 中心，服务的消费者在进行服务调用的时候先到 zookeeper 中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo 架构中 zookeeper 就担任了注册中心这一角色。为了保证高可用，最好是以集群形态来部署 zookeeper，只要半数以上节点存活，zookeeper  就能正常服务。</p>","more":"<p>zookeeper 主要提供下面几个功能：</p>\n<ol>\n<li>集群管理：容错、负载均衡。</li>\n<li>配置文件的集中管理。</li>\n<li>集群的入口。</li>\n</ol>\n<h3 id=\"Session会话\"><a href=\"#Session会话\" class=\"headerlink\" title=\"Session会话\"></a>Session会话</h3><p>Session 指的是 zookeeper  服务器与客户端会话。在 zookeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过<strong>心跳检测</strong>与服务器保持有效的会话，也能够向 zookeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的<strong>Watch事件通知</strong>。 </p>\n<p>Session 的 sessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 sessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>\n<p>在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 sessionID。由于 sessionID 是 zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</p>\n<h3 id=\"心跳检测机制\"><a href=\"#心跳检测机制\" class=\"headerlink\" title=\"心跳检测机制\"></a>心跳检测机制</h3><p>机器间的心跳检测机制是指在分布式环境中，不同机器（或进程）之间需要检测到彼此是否在正常运行，例如A机器需要知道B机器是否正常运行。在传统的开发中，我们通常是通过主机直接是否可以相互PING通来判断，更复杂一点的话，则会通过在机器之间建立长连接，通过TCP连接固有的心跳检测机制来实现上层机器的心跳检测，这些都是非常常见的心跳检测方法。</p>\n<p>下面来看看如何使用ZK来实现分布式机器（进程）间的心跳检测。<br>基于ZK的临时节点的特性，可以让不同的进程都在ZK的一个指定节点下创建临时子节点，不同的进程直接可以根据这个临时子节点来判断对应的进程是否存活。通过这种方式，检测和被检测系统直接并不需要直接相关联，而是通过ZK上的某个节点进行关联，大大减少了系统耦合。</p>\n<h3 id=\"Watcher监听事件\"><a href=\"#Watcher监听事件\" class=\"headerlink\" title=\"Watcher监听事件\"></a>Watcher监听事件</h3><ol>\n<li>监听的 Znode 被创建、删除、版本后变更(或数据变更)、子节点发生变更 会触发事件。</li>\n<li>Watcher 是一次性的，一旦触发将会永久失效，如果需要反复监听就需要反复注册。</li>\n</ol>\n<h3 id=\"Znode节点\"><a href=\"#Znode节点\" class=\"headerlink\" title=\"Znode节点\"></a>Znode节点</h3><p>在 zookeeper 中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。</p>\n<ul>\n<li>持久节点：一旦创建将一直存在于服务端，除非客户端删除。</li>\n<li>持久顺序节点： 在持久节点基础上，通过节点路径后缀一串序号来区分多个子节点创建的先后顺序。</li>\n<li>临时节点：生命周期与客户端会话保持一致。</li>\n<li>临时顺序节点：</li>\n</ul>\n<h3 id=\"Stat节点状态\"><a href=\"#Stat节点状态\" class=\"headerlink\" title=\"Stat节点状态\"></a>Stat节点状态</h3><p>zookeeper 的每个 ZNode 上都会存储数据，对应于每个 ZNode，zookeeper 都会为其维护一个叫作 Stat 的数据结构，Stat 中记录了这个 ZNode 的三个数据版本：</p>\n<ul>\n<li>version（当前ZNode的版本）</li>\n<li>cversion（当前ZNode子节点的版本）</li>\n<li>cversion（当前ZNode的ACL版本）</li>\n</ul>\n<h3 id=\"ACL权限控制\"><a href=\"#ACL权限控制\" class=\"headerlink\" title=\"ACL权限控制\"></a>ACL权限控制</h3><p>zookeeper 有以下五种权限：</p>\n<ul>\n<li>CREATE：创建子节点的权限。</li>\n<li>READ：获取子节点和子节点列表的权限。</li>\n<li>WRITE：更新节点数据的权限。</li>\n<li>DELETE：删除子节点的权限。</li>\n<li>ADMIN：设置节点ACL的权限。<br>其中需要注意的是，CREATE 和 DELETE 这两种权限都是针对<strong>子节点</strong>的权限控制。</li>\n</ul>\n<h2 id=\"zookeeper支持的协议\"><a href=\"#zookeeper支持的协议\" class=\"headerlink\" title=\"zookeeper支持的协议\"></a>zookeeper支持的协议</h2><h3 id=\"ZAB协议-amp-Paxos算法\"><a href=\"#ZAB协议-amp-Paxos算法\" class=\"headerlink\" title=\"ZAB协议 &amp; Paxos算法\"></a>ZAB协议 &amp; Paxos算法</h3><p>Paxos 算法应该可以说是  zookeeper 的灵魂了。但是，zookeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在zookeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为 zookeeper 设计的崩溃可恢复的原子消息广播算法。</p>\n<h3 id=\"ZAB协议\"><a href=\"#ZAB协议\" class=\"headerlink\" title=\"ZAB协议\"></a>ZAB协议</h3><p>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，zookeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</p>\n<h3 id=\"ZAB协议的崩溃恢复和原子广播\"><a href=\"#ZAB协议的崩溃恢复和原子广播\" class=\"headerlink\" title=\"ZAB协议的崩溃恢复和原子广播\"></a>ZAB协议的崩溃恢复和原子广播</h3><p>在整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的 Leader 服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。</p>\n<p>当集群中已经有过半的 Follower 服务器完成了和 Leader 服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。 当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到 Leader 所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。</p>\n<h2 id=\"zookeeper集群\"><a href=\"#zookeeper集群\" class=\"headerlink\" title=\"zookeeper集群\"></a>zookeeper集群</h2><h3 id=\"集群角色\"><a href=\"#集群角色\" class=\"headerlink\" title=\"集群角色\"></a>集群角色</h3><ul>\n<li>leader：负责进行投票的发起和决议，更新系统状态。</li>\n<li>follower：参与leader选举投票或事务请求投票，处理读请求 和 转发写请求给 leader。</li>\n<li>observer：弱化版的follower，不参与投票，只同步 leader 的状态，提高读取速度。</li>\n</ul>\n<h3 id=\"单机模式的安装\"><a href=\"#单机模式的安装\" class=\"headerlink\" title=\"单机模式的安装\"></a>单机模式的安装</h3><ul>\n<li><p>Step1：配置JAVA环境，检验环境：java -version</p>\n</li>\n<li><p>Step2：下载并解压zookeeper</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local</span><br><span class=\"line\">wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz</span><br><span class=\"line\">tar -zxvf zookeeper-3.4.12.tar.gz</span><br><span class=\"line\">cd zookeeper-3.4.12</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Step3：重命名配置文件zoo_sample.cfg</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp conf/zoo_sample.cfg conf/zoo.cfg</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Step4：启动zookeeper</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/zkServer.sh start</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Step5：检测是否成功启动，用zookeeper客户端连接下服务端</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bin/zkCli.sh</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"集群模式的搭建\"><a href=\"#集群模式的搭建\" class=\"headerlink\" title=\"集群模式的搭建\"></a>集群模式的搭建</h3><p>本例搭建的是伪集群模式，即一台机器上启动三个zookeeper实例组成集群，真正的集群模式无非就是实例IP地址不同，搭建方法没有区别<br>Step1：配置JAVA环境，检验环境：java -version<br>Step2：下载并解压zookeeper</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cd /usr/local</span><br><span class=\"line\"># wget http://mirror.bit.edu.cn/apache/zookeeper/stable/zookeeper-3.4.12.tar.gz</span><br><span class=\"line\"># tar -zxvf zookeeper-3.4.12.tar.gz</span><br><span class=\"line\"># cd zookeeper-3.4.12</span><br></pre></td></tr></table></figure>\n\n<p>Step3：重命名 zoo_sample.cfg文件</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cp conf/zoo_sample.cfg conf/zoo-1.cfg</span><br></pre></td></tr></table></figure>\n\n<p>Step4：修改配置文件zoo-1.cfg，原配置文件里有的，修改成下面的值，没有的则加上</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim conf/zoo-1.cfg</span><br></pre></td></tr></table></figure>\n\n<p>dataDir=/tmp/zookeeper-1<br>clientPort=2181<br>server.1=127.0.0.1:2888:3888<br>server.2=127.0.0.1:2889:3889<br>server.3=127.0.0.1:2890:3890</p>\n<p>Step5：再从zoo-1.cfg复制两个配置文件zoo-2.cfg和zoo-3.cfg，只需修改dataDir和clientPort不同即可</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cp conf/zoo-1.cfg conf/zoo-2.cfg</span><br><span class=\"line\"># cp conf/zoo-1.cfg conf/zoo-3.cfg</span><br><span class=\"line\"># vim conf/zoo-2.cfg</span><br></pre></td></tr></table></figure>\n\n<p>dataDir=/tmp/zookeeper-2<br>clientPort=2182</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># vim conf/zoo-2.cfg</span><br></pre></td></tr></table></figure>\n\n<p>dataDir=/tmp/zookeeper-3<br>clientPort=2183</p>\n<p>Step6：标识Server ID<br>创建三个文件夹/tmp/zookeeper-1，/tmp/zookeeper-2，/tmp/zookeeper-2，在每个目录中创建文件myid 文件，写入当前实例的server id，即1.2.3</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># cd /tmp/zookeeper-1</span><br><span class=\"line\"># vim myid</span><br><span class=\"line\">1</span><br><span class=\"line\"># cd /tmp/zookeeper-2</span><br><span class=\"line\"># vim myid</span><br><span class=\"line\">2</span><br><span class=\"line\"># cd /tmp/zookeeper-3</span><br><span class=\"line\"># vim myid</span><br><span class=\"line\">3</span><br></pre></td></tr></table></figure>\n\n<p>Step7：启动三个zookeeper实例</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># bin/zkServer.sh start conf/zoo-1.cfg</span><br><span class=\"line\"># bin/zkServer.sh start conf/zoo-2.cfg</span><br><span class=\"line\"># bin/zkServer.sh start conf/zoo-3.cfg</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集群中leader的选举\"><a href=\"#集群中leader的选举\" class=\"headerlink\" title=\"集群中leader的选举\"></a>集群中leader的选举</h3><p>选举场景：1、集群刚启动时   2、leader退出</p>\n<ol>\n<li>第一次每个 follower 都会选自己为 leader 服务器，也就是投出的是自己的服务器 ID 和 ZXID。</li>\n<li>每个 follower 都会受到来自其他 follower 的信息，并先按 ZXID 再按服务器 ID 最大选择选出新的选票，再次发出去。</li>\n<li>若某台服务器得到超半数的选票将当选为新的 leader。</li>\n</ol>\n<h3 id=\"集群数据同步流程\"><a href=\"#集群数据同步流程\" class=\"headerlink\" title=\"集群数据同步流程\"></a>集群数据同步流程</h3><p>完成 leader 选举后，leader 等待 follower 来连接进行同步</p>\n<ol>\n<li>leader 等待 follower 连接。</li>\n<li>follower 将最大的 zxid 发送给 leader。</li>\n<li>leader 根据 zxid 确定同步点。</li>\n<li>完成同步后，leader 给 follower 发送 uptodate 消息。</li>\n<li>follower 收到 uptodate 后，又可以重新接受 client 连接请求了。</li>\n</ol>\n<h3 id=\"集群中事务请求处理流程\"><a href=\"#集群中事务请求处理流程\" class=\"headerlink\" title=\"集群中事务请求处理流程\"></a>集群中事务请求处理流程</h3><ol>\n<li>所有事务请求都交由 leader 服务器来处理，leader 服务器会将一个事务请求转为一个proposal，并为其生成一个ZXID(事务ID)。</li>\n<li>之后 leader 服务器会将 proposal 放入每个 follower 的队列中（leader会为每个follower分配一个队列），并发送给 follower。</li>\n<li>follower收到 proposal 后，会将事务日志写入磁盘，并在成功后返回 leader 一个ACK。</li>\n<li>leader 只要收到过半的 follower 的ACK响应，就会广播一个 commit 消息给 follower 通知进行 proposal 的提交，同时自身也会完成。</li>\n</ol>\n<h2 id=\"zookeeper的应用场景\"><a href=\"#zookeeper的应用场景\" class=\"headerlink\" title=\"zookeeper的应用场景\"></a>zookeeper的应用场景</h2><h3 id=\"实现命名服务-Name-Service\"><a href=\"#实现命名服务-Name-Service\" class=\"headerlink\" title=\"实现命名服务(Name Service)\"></a>实现命名服务(Name Service)</h3><p>命名服务也是分布式系统中比较常见的一类场景。在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。被命名的实体通常可以是集群中的机器，提供的服务，远程对象等等——这些我们都可以统称他们为名字（Name）。</p>\n<p>其中较为常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表。通过在 zookeeper里创建顺序节点，能够很容易创建一个全局唯一的路径，这个路径就可以作为一个名字。</p>\n<p>zookeeper 的命名服务即生成全局唯一的ID。</p>\n<h3 id=\"实现分布式协调-通知\"><a href=\"#实现分布式协调-通知\" class=\"headerlink\" title=\"实现分布式协调/通知\"></a>实现分布式协调/通知</h3><p>zookeeper 中特有 Watcher 注册与异步通知机制，能够很好的实现分布式环境下不同机器，甚至不同系统之间的通知与协调，从而实现对数据变更的实时处理。使用方法通常是不同的客户端都对ZK上同一个 ZNode 进行注册，监听 ZNode 的变化（包括ZNode本身内容及子节点的），如果 ZNode 发生了变化，那么所有订阅的客户端都能够接收到相应的Watcher通知，并做出相应的处理。</p>\n<p>ZK的分布式协调/通知，是一种通用的分布式系统机器间的通信方式。</p>\n<h3 id=\"实现分布式锁\"><a href=\"#实现分布式锁\" class=\"headerlink\" title=\"实现分布式锁\"></a>实现分布式锁</h3><p>有两种实现：</p>\n<ol>\n<li>集群中所有机器都去竞争创建某个节点，创建成功的机器相当于获取了这个锁。</li>\n<li>所有机器都去某个父节点下创建子节点，序号最小的机器获取锁。</li>\n</ol>\n<h3 id=\"实现分布式队列\"><a href=\"#实现分布式队列\" class=\"headerlink\" title=\"实现分布式队列\"></a>实现分布式队列</h3><ol>\n<li>同步队列：在指定目录下创建 watcher，当监控到子节点数目达到指定值后再开始使用，进行读取消费。</li>\n<li>FIFO队列：读取序列号最小的节点进行消费，例如实现生产者和消费者模型。<br>在此场景下，znode 节点值存储的可能就是消息本身。</li>\n</ol>"},{"title":"八大排序算法整理","date":"2019-06-17T14:11:20.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## 排序的定义\n\n对一序列对象根据某个关键字进行排序。\n\n## 术语说明\n\n- **稳定：**如果a原本在b前面，而a=b，排序之后a仍然在b的前面；\n- **不稳定：**如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；\n- **内排序：**所有排序操作都在内存中完成；\n- **外排序：**由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；\n- **时间复杂度：**一个算法执行所耗费的时间。\n- **空间复杂度：**运行完一个程序所需内存的大小。\n\n<!-- More -->\n\n## 算法分类\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazd21f5gxj30om0ggmza.jpg)\n\n### 比较排序\n\n常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。**在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。**\n\n在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。\n\n比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。\n\n### 非比较排序\n\n计数排序、基数排序、桶排序则属于非比较排序。**非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。**\n\n非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。\n\n**非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。**\n\n## 八大排序算法\n\n### 冒泡排序（稳定）\n\n冒泡排序（Bubble-Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\n\n这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n#### 算法描述\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n2. 对每一对相邻元素做同样的工作，从第一对到最后一对，这样在最后的元素应该会是最大的数；\n3. 针对所有的元素重复以上的步骤，除了最后一个；\n4. 重复步骤1~3，直到排序完成。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdca6v64g30hs05jwnk.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 冒泡排序\n     *\n     * @param array\n     * @return\n     */\n    public static int[] bubbleSort(int[] array) {\n        if (array.length == 0)\n            return array;\n        for (int i = 0; i < array.length; i++)\n            for (int j = 0; j < array.length - 1 - i; j++)\n                if (array[j + 1] < array[j]) {\n                    int temp = array[j + 1];\n                    array[j + 1] = array[j];\n                    array[j] = temp;\n                }\n        return array;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(n) \n- 最差情况：T(n) = O(n2) \n- 平均情况：T(n) = O(n2)\n\n------\n\n### 选择排序（不稳定）\n\n表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。\n\n选择排序(Selection-Sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n#### 算法描述\n\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n\n- 初始状态：无序区为R[1..n]，有序区为空；\n- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n- n-1趟结束，数组有序化了。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdj1odlug30hq05f49s.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 选择排序\n     * @param array\n     * @return\n     */\n    public static int[] selectionSort(int[] array) {\n        if (array.length == 0)\n            return array;\n        for (int i = 0; i < array.length; i++) {\n            int minIndex = i;\n            for (int j = i; j < array.length; j++) {\n                if (array[j] < array[minIndex]) //找到最小的数\n                    minIndex = j; //将最小数的索引保存\n            }\n            int temp = array[minIndex];\n            array[minIndex] = array[i];\n            array[i] = temp;\n        }\n        return array;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(n2) \n- 最差情况：T(n) = O(n2) \n- 平均情况：T(n) = O(n2)\n\n------\n\n### 插入排序（稳定）\n\n插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n\n#### 算法描述\n\n一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：\n\n1. 从第一个元素开始，该元素可以认为已经被排序；\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n5. 将新元素插入到该位置后；\n6. 重复步骤2~5。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdn0r4w4g30hr0b2k1q.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 插入排序\n     * @param array\n     * @return\n     */\n    public static int[] insertionSort(int[] array) {\n        if (array.length == 0)\n            return array;\n        int current;\n        for (int i = 0; i < array.length - 1; i++) {\n            current = array[i + 1];\n            int preIndex = i;\n            while (preIndex >= 0 && current < array[preIndex]) {\n                array[preIndex + 1] = array[preIndex];\n                preIndex--;\n            }\n            array[preIndex + 1] = current;\n        }\n        return array;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(n) \n- 最坏情况：T(n) = O(n2) \n- 平均情况：T(n) = O(n2)\n\n------\n\n### 希尔排序（不稳定）\n\n希尔排序是希尔（Donald-Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。\n\n**希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。**\n\n#### 算法描述\n\n我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。\n\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\n\n- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\n- 按增量序列个数k，对序列进行k 趟排序；\n- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdrsaujjj30hx0je7fd.jpg)\n\n#### 代码实现\n\n```java\n/**\n     * 希尔排序\n     *\n     * @param array\n     * @return\n     */\n    public static int[] ShellSort(int[] array) {\n        int len = array.length;\n        int temp, gap = len / 2;\n        while (gap > 0) {\n            for (int i = gap; i < len; i++) {\n                temp = array[i];\n                int preIndex = i - gap;\n                while (preIndex >= 0 && array[preIndex] > temp) {\n                    array[preIndex + gap] = array[preIndex];\n                    preIndex -= gap;\n                }\n                array[preIndex + gap] = temp;\n            }\n            gap /= 2;\n        }\n        return array;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(nlog2 n) \n- 最坏情况：T(n) = O(nlog2 n) \n- 平均情况：T(n) =O(nlog2n)　\n\n------\n\n### 归并排序（稳定）\n\n和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。\n\n**归并排序（Merge-Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。**\n\n#### 算法描述\n\n- 把长度为n的输入序列分成两个长度为n/2的子序列；\n- 对这两个子序列分别采用归并排序；\n- 将两个排序好的子序列合并成一个最终的排序序列。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdvclbg8g30hr0b248f.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 归并排序\n     *\n     * @param array\n     * @return\n     */\n    public static int[] MergeSort(int[] array) {\n        if (array.length < 2) return array;\n        int mid = array.length / 2;\n        int[] left = Arrays.copyOfRange(array, 0, mid);\n        int[] right = Arrays.copyOfRange(array, mid, array.length);\n        return merge(MergeSort(left), MergeSort(right));\n    }\n    /**\n     * 归并排序——将两段排序好的数组结合成一个排序数组\n     *\n     * @param left\n     * @param right\n     * @return\n     */\n    public static int[] merge(int[] left, int[] right) {\n        int[] result = new int[left.length + right.length];\n        for (int index = 0, i = 0, j = 0; index < result.length; index++) {\n            if (i >= left.length)\n                result[index] = right[j++];\n            else if (j >= right.length)\n                result[index] = left[i++];\n            else if (left[i] > right[j])\n                result[index] = right[j++];\n            else\n                result[index] = left[i++];\n        }\n        return result;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(n) \n- 最差情况：T(n) = O(nlogn) \n- 平均情况：T(n) = O(nlogn)\n\n------\n\n### 快速排序（不稳定）\n\n快速排序（Quick-Sort）通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\n\n#### 算法描述\n\n快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\n\n- 从数列中挑出一个元素，称为 “基准”（pivot）；\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdyg13w7g30hp05iqbj.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 快速排序方法\n     * @param array\n     * @param start\n     * @param end\n     * @return\n     */\n    public static int[] QuickSort(int[] array, int start, int end) {\n        if (array.length < 1 || start < 0 || end >= array.length || start > end) return null;\n        int smallIndex = partition(array, start, end);\n        if (smallIndex > start)\n            QuickSort(array, start, smallIndex - 1);\n        if (smallIndex < end)\n            QuickSort(array, smallIndex + 1, end);\n        return array;\n    }\n    /**\n     * 快速排序算法——partition\n     * @param array\n     * @param start\n     * @param end\n     * @return\n     */\n    public static int partition(int[] array, int start, int end) {\n        int pivot = (int) (start + Math.random() * (end - start + 1));\n        int smallIndex = start - 1;\n        swap(array, pivot, end);\n        for (int i = start; i <= end; i++)\n            if (array[i] <= array[end]) {\n                smallIndex++;\n                if (i > smallIndex)\n                    swap(array, i, smallIndex);\n            }\n        return smallIndex;\n    }\n\n    /**\n     * 交换数组内两个元素\n     * @param array\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(nlogn) \n- 最差情况：T(n) = O(n2) \n- 平均情况：T(n) = O(nlogn)　\n\n------\n\n### 堆排序（不稳定）\n\n堆排序（Heap-Sort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n\n#### 算法描述\n\n- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\n- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；\n- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaze1k0uc8g30f70a44qp.gif)\n\n#### 代码实现\n\n```java\n//声明全局变量，用于记录数组array的长度；\nstatic int len;\n    /**\n     * 堆排序算法\n     *\n     * @param array\n     * @return\n     */\n    public static int[] HeapSort(int[] array) {\n        len = array.length;\n        if (len < 1) return array;\n        //1.构建一个最大堆\n        buildMaxHeap(array);\n        //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆\n        while (len > 0) {\n            swap(array, 0, len - 1);\n            len--;\n            adjustHeap(array, 0);\n        }\n        return array;\n    }\n    /**\n     * 建立最大堆\n     *\n     * @param array\n     */\n    public static void buildMaxHeap(int[] array) {\n        //从最后一个非叶子节点开始向上构造最大堆\n        for (int i = (len/2 - 1); i >= 0; i--) { //感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) \n            adjustHeap(array, i);\n        }\n    }\n    /**\n     * 调整使之成为最大堆\n     *\n     * @param array\n     * @param i\n     */\n    public static void adjustHeap(int[] array, int i) {\n        int maxIndex = i;\n        //如果有左子树，且左子树大于父节点，则将最大指针指向左子树\n        if (i * 2 < len && array[i * 2] > array[maxIndex])\n            maxIndex = i * 2;\n        //如果有右子树，且右子树大于父节点，则将最大指针指向右子树\n        if (i * 2 + 1 < len && array[i * 2 + 1] > array[maxIndex])\n            maxIndex = i * 2 + 1;\n        //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。\n        if (maxIndex != i) {\n            swap(array, maxIndex, i);\n            adjustHeap(array, maxIndex);\n        }\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(nlogn) \n- 最差情况：T(n) = O(nlogn) \n- 平均情况：T(n) = O(nlogn)\n\n------\n\n### 基数排序（稳定）\n\n基数排序（Radix-Sort）也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn)，为数组长度，k为数组中的数的最大的位数。\n\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。\n\n#### 算法描述\n\n- 取得数组中的最大数，并取得位数；\n- arr为原始数组，从最低位开始取每个位组成radix数组；\n- 对radix进行计数排序(利用计数排序适用于小范围数的特点)；\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaze4srwjig30hs0a3kjl.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 基数排序\n     * @param array\n     * @return\n     */\n    public static int[] RadixSort(int[] array) {\n        if (array == null || array.length < 2)\n            return array;\n        // 1.先算出最大数的位数；\n        int max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            max = Math.max(max, array[i]);\n        }\n        int maxDigit = 0;\n        while (max != 0) {\n            max /= 10;\n            maxDigit++;\n        }\n        int mod = 10, div = 1;\n        ArrayList<ArrayList<Integer>> bucketList = new ArrayList<ArrayList<Integer>>();\n        for (int i = 0; i < 10; i++)\n            bucketList.add(new ArrayList<Integer>());\n        for (int i = 0; i < maxDigit; i++, mod *= 10, div *= 10) {\n            for (int j = 0; j < array.length; j++) {\n                int num = (array[j] % mod) / div;\n                bucketList.get(num).add(array[j]);\n            }\n            int index = 0;\n            for (int j = 0; j < bucketList.size(); j++) {\n                for (int k = 0; k < bucketList.get(j).size(); k++)\n                    array[index++] = bucketList.get(j).get(k);\n                bucketList.get(j).clear();\n            }\n        }\n        return array;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(n * k) \n- 最差情况：T(n) = O(n * k) \n- 平均情况：T(n) = O(n * k)\n\n基数排序有两种方法：\n\n- MSD 从高位开始进行排序\n- LSD 从低位开始进行排序","source":"_posts/Sort.md","raw":"---\ntitle: 八大排序算法整理\ndate: 2019-06-17 22:11:20\ncategories: \n  - Java\n  - 算法\ntags:\n  - 算法\n  - 八大排序算法\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## 排序的定义\n\n对一序列对象根据某个关键字进行排序。\n\n## 术语说明\n\n- **稳定：**如果a原本在b前面，而a=b，排序之后a仍然在b的前面；\n- **不稳定：**如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；\n- **内排序：**所有排序操作都在内存中完成；\n- **外排序：**由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；\n- **时间复杂度：**一个算法执行所耗费的时间。\n- **空间复杂度：**运行完一个程序所需内存的大小。\n\n<!-- More -->\n\n## 算法分类\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazd21f5gxj30om0ggmza.jpg)\n\n### 比较排序\n\n常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。**在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。**\n\n在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。\n\n比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。\n\n### 非比较排序\n\n计数排序、基数排序、桶排序则属于非比较排序。**非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。**\n\n非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。\n\n**非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。**\n\n## 八大排序算法\n\n### 冒泡排序（稳定）\n\n冒泡排序（Bubble-Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。\n\n这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\n\n#### 算法描述\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个；\n2. 对每一对相邻元素做同样的工作，从第一对到最后一对，这样在最后的元素应该会是最大的数；\n3. 针对所有的元素重复以上的步骤，除了最后一个；\n4. 重复步骤1~3，直到排序完成。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdca6v64g30hs05jwnk.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 冒泡排序\n     *\n     * @param array\n     * @return\n     */\n    public static int[] bubbleSort(int[] array) {\n        if (array.length == 0)\n            return array;\n        for (int i = 0; i < array.length; i++)\n            for (int j = 0; j < array.length - 1 - i; j++)\n                if (array[j + 1] < array[j]) {\n                    int temp = array[j + 1];\n                    array[j + 1] = array[j];\n                    array[j] = temp;\n                }\n        return array;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(n) \n- 最差情况：T(n) = O(n2) \n- 平均情况：T(n) = O(n2)\n\n------\n\n### 选择排序（不稳定）\n\n表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。\n\n选择排序(Selection-Sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n\n#### 算法描述\n\nn个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\n\n- 初始状态：无序区为R[1..n]，有序区为空；\n- 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\n- n-1趟结束，数组有序化了。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdj1odlug30hq05f49s.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 选择排序\n     * @param array\n     * @return\n     */\n    public static int[] selectionSort(int[] array) {\n        if (array.length == 0)\n            return array;\n        for (int i = 0; i < array.length; i++) {\n            int minIndex = i;\n            for (int j = i; j < array.length; j++) {\n                if (array[j] < array[minIndex]) //找到最小的数\n                    minIndex = j; //将最小数的索引保存\n            }\n            int temp = array[minIndex];\n            array[minIndex] = array[i];\n            array[i] = temp;\n        }\n        return array;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(n2) \n- 最差情况：T(n) = O(n2) \n- 平均情况：T(n) = O(n2)\n\n------\n\n### 插入排序（稳定）\n\n插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n\n#### 算法描述\n\n一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：\n\n1. 从第一个元素开始，该元素可以认为已经被排序；\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\n5. 将新元素插入到该位置后；\n6. 重复步骤2~5。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdn0r4w4g30hr0b2k1q.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 插入排序\n     * @param array\n     * @return\n     */\n    public static int[] insertionSort(int[] array) {\n        if (array.length == 0)\n            return array;\n        int current;\n        for (int i = 0; i < array.length - 1; i++) {\n            current = array[i + 1];\n            int preIndex = i;\n            while (preIndex >= 0 && current < array[preIndex]) {\n                array[preIndex + 1] = array[preIndex];\n                preIndex--;\n            }\n            array[preIndex + 1] = current;\n        }\n        return array;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(n) \n- 最坏情况：T(n) = O(n2) \n- 平均情况：T(n) = O(n2)\n\n------\n\n### 希尔排序（不稳定）\n\n希尔排序是希尔（Donald-Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。\n\n**希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。**\n\n#### 算法描述\n\n我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。\n\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\n\n- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；\n- 按增量序列个数k，对序列进行k 趟排序；\n- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdrsaujjj30hx0je7fd.jpg)\n\n#### 代码实现\n\n```java\n/**\n     * 希尔排序\n     *\n     * @param array\n     * @return\n     */\n    public static int[] ShellSort(int[] array) {\n        int len = array.length;\n        int temp, gap = len / 2;\n        while (gap > 0) {\n            for (int i = gap; i < len; i++) {\n                temp = array[i];\n                int preIndex = i - gap;\n                while (preIndex >= 0 && array[preIndex] > temp) {\n                    array[preIndex + gap] = array[preIndex];\n                    preIndex -= gap;\n                }\n                array[preIndex + gap] = temp;\n            }\n            gap /= 2;\n        }\n        return array;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(nlog2 n) \n- 最坏情况：T(n) = O(nlog2 n) \n- 平均情况：T(n) =O(nlog2n)　\n\n------\n\n### 归并排序（稳定）\n\n和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。\n\n**归并排序（Merge-Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。**\n\n#### 算法描述\n\n- 把长度为n的输入序列分成两个长度为n/2的子序列；\n- 对这两个子序列分别采用归并排序；\n- 将两个排序好的子序列合并成一个最终的排序序列。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdvclbg8g30hr0b248f.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 归并排序\n     *\n     * @param array\n     * @return\n     */\n    public static int[] MergeSort(int[] array) {\n        if (array.length < 2) return array;\n        int mid = array.length / 2;\n        int[] left = Arrays.copyOfRange(array, 0, mid);\n        int[] right = Arrays.copyOfRange(array, mid, array.length);\n        return merge(MergeSort(left), MergeSort(right));\n    }\n    /**\n     * 归并排序——将两段排序好的数组结合成一个排序数组\n     *\n     * @param left\n     * @param right\n     * @return\n     */\n    public static int[] merge(int[] left, int[] right) {\n        int[] result = new int[left.length + right.length];\n        for (int index = 0, i = 0, j = 0; index < result.length; index++) {\n            if (i >= left.length)\n                result[index] = right[j++];\n            else if (j >= right.length)\n                result[index] = left[i++];\n            else if (left[i] > right[j])\n                result[index] = right[j++];\n            else\n                result[index] = left[i++];\n        }\n        return result;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(n) \n- 最差情况：T(n) = O(nlogn) \n- 平均情况：T(n) = O(nlogn)\n\n------\n\n### 快速排序（不稳定）\n\n快速排序（Quick-Sort）通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\n\n#### 算法描述\n\n快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\n\n- 从数列中挑出一个元素，称为 “基准”（pivot）；\n- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\n- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazdyg13w7g30hp05iqbj.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 快速排序方法\n     * @param array\n     * @param start\n     * @param end\n     * @return\n     */\n    public static int[] QuickSort(int[] array, int start, int end) {\n        if (array.length < 1 || start < 0 || end >= array.length || start > end) return null;\n        int smallIndex = partition(array, start, end);\n        if (smallIndex > start)\n            QuickSort(array, start, smallIndex - 1);\n        if (smallIndex < end)\n            QuickSort(array, smallIndex + 1, end);\n        return array;\n    }\n    /**\n     * 快速排序算法——partition\n     * @param array\n     * @param start\n     * @param end\n     * @return\n     */\n    public static int partition(int[] array, int start, int end) {\n        int pivot = (int) (start + Math.random() * (end - start + 1));\n        int smallIndex = start - 1;\n        swap(array, pivot, end);\n        for (int i = start; i <= end; i++)\n            if (array[i] <= array[end]) {\n                smallIndex++;\n                if (i > smallIndex)\n                    swap(array, i, smallIndex);\n            }\n        return smallIndex;\n    }\n\n    /**\n     * 交换数组内两个元素\n     * @param array\n     * @param i\n     * @param j\n     */\n    public static void swap(int[] array, int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(nlogn) \n- 最差情况：T(n) = O(n2) \n- 平均情况：T(n) = O(nlogn)　\n\n------\n\n### 堆排序（不稳定）\n\n堆排序（Heap-Sort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n\n#### 算法描述\n\n- 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；\n- 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；\n- 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaze1k0uc8g30f70a44qp.gif)\n\n#### 代码实现\n\n```java\n//声明全局变量，用于记录数组array的长度；\nstatic int len;\n    /**\n     * 堆排序算法\n     *\n     * @param array\n     * @return\n     */\n    public static int[] HeapSort(int[] array) {\n        len = array.length;\n        if (len < 1) return array;\n        //1.构建一个最大堆\n        buildMaxHeap(array);\n        //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆\n        while (len > 0) {\n            swap(array, 0, len - 1);\n            len--;\n            adjustHeap(array, 0);\n        }\n        return array;\n    }\n    /**\n     * 建立最大堆\n     *\n     * @param array\n     */\n    public static void buildMaxHeap(int[] array) {\n        //从最后一个非叶子节点开始向上构造最大堆\n        for (int i = (len/2 - 1); i >= 0; i--) { //感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) \n            adjustHeap(array, i);\n        }\n    }\n    /**\n     * 调整使之成为最大堆\n     *\n     * @param array\n     * @param i\n     */\n    public static void adjustHeap(int[] array, int i) {\n        int maxIndex = i;\n        //如果有左子树，且左子树大于父节点，则将最大指针指向左子树\n        if (i * 2 < len && array[i * 2] > array[maxIndex])\n            maxIndex = i * 2;\n        //如果有右子树，且右子树大于父节点，则将最大指针指向右子树\n        if (i * 2 + 1 < len && array[i * 2 + 1] > array[maxIndex])\n            maxIndex = i * 2 + 1;\n        //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。\n        if (maxIndex != i) {\n            swap(array, maxIndex, i);\n            adjustHeap(array, maxIndex);\n        }\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(nlogn) \n- 最差情况：T(n) = O(nlogn) \n- 平均情况：T(n) = O(nlogn)\n\n------\n\n### 基数排序（稳定）\n\n基数排序（Radix-Sort）也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn)，为数组长度，k为数组中的数的最大的位数。\n\n基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。\n\n#### 算法描述\n\n- 取得数组中的最大数，并取得位数；\n- arr为原始数组，从最低位开始取每个位组成radix数组；\n- 对radix进行计数排序(利用计数排序适用于小范围数的特点)；\n\n#### 过程演示\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gaze4srwjig30hs0a3kjl.gif)\n\n#### 代码实现\n\n```java\n/**\n     * 基数排序\n     * @param array\n     * @return\n     */\n    public static int[] RadixSort(int[] array) {\n        if (array == null || array.length < 2)\n            return array;\n        // 1.先算出最大数的位数；\n        int max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            max = Math.max(max, array[i]);\n        }\n        int maxDigit = 0;\n        while (max != 0) {\n            max /= 10;\n            maxDigit++;\n        }\n        int mod = 10, div = 1;\n        ArrayList<ArrayList<Integer>> bucketList = new ArrayList<ArrayList<Integer>>();\n        for (int i = 0; i < 10; i++)\n            bucketList.add(new ArrayList<Integer>());\n        for (int i = 0; i < maxDigit; i++, mod *= 10, div *= 10) {\n            for (int j = 0; j < array.length; j++) {\n                int num = (array[j] % mod) / div;\n                bucketList.get(num).add(array[j]);\n            }\n            int index = 0;\n            for (int j = 0; j < bucketList.size(); j++) {\n                for (int k = 0; k < bucketList.get(j).size(); k++)\n                    array[index++] = bucketList.get(j).get(k);\n                bucketList.get(j).clear();\n            }\n        }\n        return array;\n    }\n```\n\n#### 算法分析\n\n- 最佳情况：T(n) = O(n * k) \n- 最差情况：T(n) = O(n * k) \n- 平均情况：T(n) = O(n * k)\n\n基数排序有两种方法：\n\n- MSD 从高位开始进行排序\n- LSD 从低位开始进行排序","slug":"Sort","published":1,"updated":"2020-01-17T05:06:57.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61cna004ia6ybkwdzdhzi","content":"<h2 id=\"排序的定义\"><a href=\"#排序的定义\" class=\"headerlink\" title=\"排序的定义\"></a>排序的定义</h2><p>对一序列对象根据某个关键字进行排序。</p>\n<h2 id=\"术语说明\"><a href=\"#术语说明\" class=\"headerlink\" title=\"术语说明\"></a>术语说明</h2><ul>\n<li><strong>稳定：</strong>如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>\n<li><strong>不稳定：</strong>如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>\n<li><strong>内排序：</strong>所有排序操作都在内存中完成；</li>\n<li><strong>外排序：</strong>由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>\n<li><strong>时间复杂度：</strong>一个算法执行所耗费的时间。</li>\n<li><strong>空间复杂度：</strong>运行完一个程序所需内存的大小。</li>\n</ul>\n<a id=\"more\"></a>\n\n<h2 id=\"算法分类\"><a href=\"#算法分类\" class=\"headerlink\" title=\"算法分类\"></a>算法分类</h2><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazd21f5gxj30om0ggmza.jpg\" alt></p>\n<h3 id=\"比较排序\"><a href=\"#比较排序\" class=\"headerlink\" title=\"比较排序\"></a>比较排序</h3><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。<strong>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong></p>\n<p>在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。</p>\n<p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>\n<h3 id=\"非比较排序\"><a href=\"#非比较排序\" class=\"headerlink\" title=\"非比较排序\"></a>非比较排序</h3><p>计数排序、基数排序、桶排序则属于非比较排序。<strong>非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</strong></p>\n<p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。</p>\n<p><strong>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</strong></p>\n<h2 id=\"八大排序算法\"><a href=\"#八大排序算法\" class=\"headerlink\" title=\"八大排序算法\"></a>八大排序算法</h2><h3 id=\"冒泡排序（稳定）\"><a href=\"#冒泡排序（稳定）\" class=\"headerlink\" title=\"冒泡排序（稳定）\"></a>冒泡排序（稳定）</h3><p>冒泡排序（Bubble-Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>\n<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<h4 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素做同样的工作，从第一对到最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤1~3，直到排序完成。</li>\n</ol>\n<h4 id=\"过程演示\"><a href=\"#过程演示\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdca6v64g30hs05jwnk.gif\" alt></p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] bubbleSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; array.length - <span class=\"number\">1</span> - i; j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j + <span class=\"number\">1</span>] &lt; array[j]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = array[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">                    array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">                    array[j] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n) </li>\n<li>最差情况：T(n) = O(n2) </li>\n<li>平均情况：T(n) = O(n2)</li>\n</ul>\n<hr>\n<h3 id=\"选择排序（不稳定）\"><a href=\"#选择排序（不稳定）\" class=\"headerlink\" title=\"选择排序（不稳定）\"></a>选择排序（不稳定）</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。</p>\n<p>选择排序(Selection-Sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<h4 id=\"算法描述-1\"><a href=\"#算法描述-1\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>\n<ul>\n<li>初始状态：无序区为R[1..n]，有序区为空；</li>\n<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>\n<li>n-1趟结束，数组有序化了。</li>\n</ul>\n<h4 id=\"过程演示-1\"><a href=\"#过程演示-1\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdj1odlug30hq05f49s.gif\" alt></p>\n<h4 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 选择排序</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] selectionSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> minIndex = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt; array[minIndex]) <span class=\"comment\">//找到最小的数</span></span><br><span class=\"line\">                    minIndex = j; <span class=\"comment\">//将最小数的索引保存</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = array[minIndex];</span><br><span class=\"line\">            array[minIndex] = array[i];</span><br><span class=\"line\">            array[i] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n2) </li>\n<li>最差情况：T(n) = O(n2) </li>\n<li>平均情况：T(n) = O(n2)</li>\n</ul>\n<hr>\n<h3 id=\"插入排序（稳定）\"><a href=\"#插入排序（稳定）\" class=\"headerlink\" title=\"插入排序（稳定）\"></a>插入排序（稳定）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>\n<h4 id=\"算法描述-2\"><a href=\"#算法描述-2\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>\n<li>将新元素插入到该位置后；</li>\n<li>重复步骤2~5。</li>\n</ol>\n<h4 id=\"过程演示-2\"><a href=\"#过程演示-2\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdn0r4w4g30hr0b2k1q.gif\" alt></p>\n<h4 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 插入排序</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] insertionSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> current;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            current = array[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> preIndex = i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class=\"line\">                array[preIndex + <span class=\"number\">1</span>] = array[preIndex];</span><br><span class=\"line\">                preIndex--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[preIndex + <span class=\"number\">1</span>] = current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-2\"><a href=\"#算法分析-2\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n) </li>\n<li>最坏情况：T(n) = O(n2) </li>\n<li>平均情况：T(n) = O(n2)</li>\n</ul>\n<hr>\n<h3 id=\"希尔排序（不稳定）\"><a href=\"#希尔排序（不稳定）\" class=\"headerlink\" title=\"希尔排序（不稳定）\"></a>希尔排序（不稳定）</h3><p>希尔排序是希尔（Donald-Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>\n<p><strong>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p>\n<h4 id=\"算法描述-3\"><a href=\"#算法描述-3\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>\n<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>\n<ul>\n<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>\n<li>按增量序列个数k，对序列进行k 趟排序；</li>\n<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ul>\n<h4 id=\"过程演示-3\"><a href=\"#过程演示-3\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdrsaujjj30hx0je7fd.jpg\" alt></p>\n<h4 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 希尔排序</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] ShellSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = array.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp, gap = len / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (gap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">                temp = array[i];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> preIndex = i - gap;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; array[preIndex] &gt; temp) &#123;</span><br><span class=\"line\">                    array[preIndex + gap] = array[preIndex];</span><br><span class=\"line\">                    preIndex -= gap;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                array[preIndex + gap] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            gap /= <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-3\"><a href=\"#算法分析-3\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlog2 n) </li>\n<li>最坏情况：T(n) = O(nlog2 n) </li>\n<li>平均情况：T(n) =O(nlog2n)　</li>\n</ul>\n<hr>\n<h3 id=\"归并排序（稳定）\"><a href=\"#归并排序（稳定）\" class=\"headerlink\" title=\"归并排序（稳定）\"></a>归并排序（稳定）</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>\n<p><strong>归并排序（Merge-Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</strong></p>\n<h4 id=\"算法描述-4\"><a href=\"#算法描述-4\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。</li>\n</ul>\n<h4 id=\"过程演示-4\"><a href=\"#过程演示-4\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdvclbg8g30hr0b248f.gif\" alt></p>\n<h4 id=\"代码实现-4\"><a href=\"#代码实现-4\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 归并排序</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] MergeSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = array.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] left = Arrays.copyOfRange(array, <span class=\"number\">0</span>, mid);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 归并排序——将两段排序好的数组结合成一个排序数组</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> left</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> right</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] merge(<span class=\"keyword\">int</span>[] left, <span class=\"keyword\">int</span>[] right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[left.length + right.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>, i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; index &lt; result.length; index++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;= left.length)</span><br><span class=\"line\">                result[index] = right[j++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &gt;= right.length)</span><br><span class=\"line\">                result[index] = left[i++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left[i] &gt; right[j])</span><br><span class=\"line\">                result[index] = right[j++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                result[index] = left[i++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-4\"><a href=\"#算法分析-4\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n) </li>\n<li>最差情况：T(n) = O(nlogn) </li>\n<li>平均情况：T(n) = O(nlogn)</li>\n</ul>\n<hr>\n<h3 id=\"快速排序（不稳定）\"><a href=\"#快速排序（不稳定）\" class=\"headerlink\" title=\"快速排序（不稳定）\"></a>快速排序（不稳定）</h3><p>快速排序（Quick-Sort）通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n<h4 id=\"算法描述-5\"><a href=\"#算法描述-5\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>\n<ul>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ul>\n<h4 id=\"过程演示-5\"><a href=\"#过程演示-5\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdyg13w7g30hp05iqbj.gif\" alt></p>\n<h4 id=\"代码实现-5\"><a href=\"#代码实现-5\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 快速排序方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> start</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] QuickSort(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">1</span> || start &lt; <span class=\"number\">0</span> || end &gt;= array.length || start &gt; end) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> smallIndex = partition(array, start, end);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (smallIndex &gt; start)</span><br><span class=\"line\">            QuickSort(array, start, smallIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (smallIndex &lt; end)</span><br><span class=\"line\">            QuickSort(array, smallIndex + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 快速排序算法——partition</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> start</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pivot = (<span class=\"keyword\">int</span>) (start + Math.random() * (end - start + <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> smallIndex = start - <span class=\"number\">1</span>;</span><br><span class=\"line\">        swap(array, pivot, end);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt;= end; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[i] &lt;= array[end]) &#123;</span><br><span class=\"line\">                smallIndex++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt; smallIndex)</span><br><span class=\"line\">                    swap(array, i, smallIndex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> smallIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 交换数组内两个元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> i</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> j</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = array[i];</span><br><span class=\"line\">        array[i] = array[j];</span><br><span class=\"line\">        array[j] = temp;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-5\"><a href=\"#算法分析-5\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn) </li>\n<li>最差情况：T(n) = O(n2) </li>\n<li>平均情况：T(n) = O(nlogn)　</li>\n</ul>\n<hr>\n<h3 id=\"堆排序（不稳定）\"><a href=\"#堆排序（不稳定）\" class=\"headerlink\" title=\"堆排序（不稳定）\"></a>堆排序（不稳定）</h3><p>堆排序（Heap-Sort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>\n<h4 id=\"算法描述-6\"><a href=\"#算法描述-6\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>\n<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>\n</ul>\n<h4 id=\"过程演示-6\"><a href=\"#过程演示-6\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaze1k0uc8g30f70a44qp.gif\" alt></p>\n<h4 id=\"代码实现-6\"><a href=\"#代码实现-6\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明全局变量，用于记录数组array的长度；</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 堆排序算法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] HeapSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        len = array.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"comment\">//1.构建一个最大堆</span></span><br><span class=\"line\">        buildMaxHeap(array);</span><br><span class=\"line\">        <span class=\"comment\">//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            swap(array, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            len--;</span><br><span class=\"line\">            adjustHeap(array, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 建立最大堆</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">buildMaxHeap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//从最后一个非叶子节点开始向上构造最大堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (len/<span class=\"number\">2</span> - <span class=\"number\">1</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123; <span class=\"comment\">//感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) </span></span><br><span class=\"line\">            adjustHeap(array, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 调整使之成为最大堆</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> i</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">adjustHeap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxIndex = i;</span><br><span class=\"line\">        <span class=\"comment\">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i * <span class=\"number\">2</span> &lt; len &amp;&amp; array[i * <span class=\"number\">2</span>] &gt; array[maxIndex])</span><br><span class=\"line\">            maxIndex = i * <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i * <span class=\"number\">2</span> + <span class=\"number\">1</span> &lt; len &amp;&amp; array[i * <span class=\"number\">2</span> + <span class=\"number\">1</span>] &gt; array[maxIndex])</span><br><span class=\"line\">            maxIndex = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxIndex != i) &#123;</span><br><span class=\"line\">            swap(array, maxIndex, i);</span><br><span class=\"line\">            adjustHeap(array, maxIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-6\"><a href=\"#算法分析-6\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn) </li>\n<li>最差情况：T(n) = O(nlogn) </li>\n<li>平均情况：T(n) = O(nlogn)</li>\n</ul>\n<hr>\n<h3 id=\"基数排序（稳定）\"><a href=\"#基数排序（稳定）\" class=\"headerlink\" title=\"基数排序（稳定）\"></a>基数排序（稳定）</h3><p>基数排序（Radix-Sort）也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn)，为数组长度，k为数组中的数的最大的位数。</p>\n<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>\n<h4 id=\"算法描述-7\"><a href=\"#算法描述-7\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>\n<li>对radix进行计数排序(利用计数排序适用于小范围数的特点)；</li>\n</ul>\n<h4 id=\"过程演示-7\"><a href=\"#过程演示-7\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaze4srwjig30hs0a3kjl.gif\" alt></p>\n<h4 id=\"代码实现-7\"><a href=\"#代码实现-7\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 基数排序</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] RadixSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array == <span class=\"keyword\">null</span> || array.length &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"comment\">// 1.先算出最大数的位数；</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            max = Math.max(max, array[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxDigit = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (max != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            max /= <span class=\"number\">10</span>;</span><br><span class=\"line\">            maxDigit++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mod = <span class=\"number\">10</span>, div = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class=\"keyword\">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">            bucketList.add(<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxDigit; i++, mod *= <span class=\"number\">10</span>, div *= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> num = (array[j] % mod) / div;</span><br><span class=\"line\">                bucketList.get(num).add(array[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class=\"line\">                    array[index++] = bucketList.get(j).get(k);</span><br><span class=\"line\">                bucketList.get(j).clear();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-7\"><a href=\"#算法分析-7\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n * k) </li>\n<li>最差情况：T(n) = O(n * k) </li>\n<li>平均情况：T(n) = O(n * k)</li>\n</ul>\n<p>基数排序有两种方法：</p>\n<ul>\n<li>MSD 从高位开始进行排序</li>\n<li>LSD 从低位开始进行排序</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"排序的定义\"><a href=\"#排序的定义\" class=\"headerlink\" title=\"排序的定义\"></a>排序的定义</h2><p>对一序列对象根据某个关键字进行排序。</p>\n<h2 id=\"术语说明\"><a href=\"#术语说明\" class=\"headerlink\" title=\"术语说明\"></a>术语说明</h2><ul>\n<li><strong>稳定：</strong>如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>\n<li><strong>不稳定：</strong>如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>\n<li><strong>内排序：</strong>所有排序操作都在内存中完成；</li>\n<li><strong>外排序：</strong>由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>\n<li><strong>时间复杂度：</strong>一个算法执行所耗费的时间。</li>\n<li><strong>空间复杂度：</strong>运行完一个程序所需内存的大小。</li>\n</ul>","more":"<h2 id=\"算法分类\"><a href=\"#算法分类\" class=\"headerlink\" title=\"算法分类\"></a>算法分类</h2><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazd21f5gxj30om0ggmza.jpg\" alt></p>\n<h3 id=\"比较排序\"><a href=\"#比较排序\" class=\"headerlink\" title=\"比较排序\"></a>比较排序</h3><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。<strong>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong></p>\n<p>在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。</p>\n<p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>\n<h3 id=\"非比较排序\"><a href=\"#非比较排序\" class=\"headerlink\" title=\"非比较排序\"></a>非比较排序</h3><p>计数排序、基数排序、桶排序则属于非比较排序。<strong>非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</strong></p>\n<p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。</p>\n<p><strong>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</strong></p>\n<h2 id=\"八大排序算法\"><a href=\"#八大排序算法\" class=\"headerlink\" title=\"八大排序算法\"></a>八大排序算法</h2><h3 id=\"冒泡排序（稳定）\"><a href=\"#冒泡排序（稳定）\" class=\"headerlink\" title=\"冒泡排序（稳定）\"></a>冒泡排序（稳定）</h3><p>冒泡排序（Bubble-Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p>\n<p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>\n<h4 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>\n<li>对每一对相邻元素做同样的工作，从第一对到最后一对，这样在最后的元素应该会是最大的数；</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个；</li>\n<li>重复步骤1~3，直到排序完成。</li>\n</ol>\n<h4 id=\"过程演示\"><a href=\"#过程演示\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdca6v64g30hs05jwnk.gif\" alt></p>\n<h4 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 冒泡排序</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] bubbleSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; array.length - <span class=\"number\">1</span> - i; j++)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j + <span class=\"number\">1</span>] &lt; array[j]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> temp = array[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">                    array[j + <span class=\"number\">1</span>] = array[j];</span><br><span class=\"line\">                    array[j] = temp;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析\"><a href=\"#算法分析\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n) </li>\n<li>最差情况：T(n) = O(n2) </li>\n<li>平均情况：T(n) = O(n2)</li>\n</ul>\n<hr>\n<h3 id=\"选择排序（不稳定）\"><a href=\"#选择排序（不稳定）\" class=\"headerlink\" title=\"选择排序（不稳定）\"></a>选择排序（不稳定）</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。</p>\n<p>选择排序(Selection-Sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>\n<h4 id=\"算法描述-1\"><a href=\"#算法描述-1\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>\n<ul>\n<li>初始状态：无序区为R[1..n]，有序区为空；</li>\n<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>\n<li>n-1趟结束，数组有序化了。</li>\n</ul>\n<h4 id=\"过程演示-1\"><a href=\"#过程演示-1\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdj1odlug30hq05f49s.gif\" alt></p>\n<h4 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 选择排序</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] selectionSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> minIndex = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (array[j] &lt; array[minIndex]) <span class=\"comment\">//找到最小的数</span></span><br><span class=\"line\">                    minIndex = j; <span class=\"comment\">//将最小数的索引保存</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = array[minIndex];</span><br><span class=\"line\">            array[minIndex] = array[i];</span><br><span class=\"line\">            array[i] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-1\"><a href=\"#算法分析-1\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n2) </li>\n<li>最差情况：T(n) = O(n2) </li>\n<li>平均情况：T(n) = O(n2)</li>\n</ul>\n<hr>\n<h3 id=\"插入排序（稳定）\"><a href=\"#插入排序（稳定）\" class=\"headerlink\" title=\"插入排序（稳定）\"></a>插入排序（稳定）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>\n<h4 id=\"算法描述-2\"><a href=\"#算法描述-2\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>\n<ol>\n<li>从第一个元素开始，该元素可以认为已经被排序；</li>\n<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>\n<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>\n<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>\n<li>将新元素插入到该位置后；</li>\n<li>重复步骤2~5。</li>\n</ol>\n<h4 id=\"过程演示-2\"><a href=\"#过程演示-2\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdn0r4w4g30hr0b2k1q.gif\" alt></p>\n<h4 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 插入排序</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] insertionSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> current;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            current = array[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">int</span> preIndex = i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class=\"line\">                array[preIndex + <span class=\"number\">1</span>] = array[preIndex];</span><br><span class=\"line\">                preIndex--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            array[preIndex + <span class=\"number\">1</span>] = current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-2\"><a href=\"#算法分析-2\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n) </li>\n<li>最坏情况：T(n) = O(n2) </li>\n<li>平均情况：T(n) = O(n2)</li>\n</ul>\n<hr>\n<h3 id=\"希尔排序（不稳定）\"><a href=\"#希尔排序（不稳定）\" class=\"headerlink\" title=\"希尔排序（不稳定）\"></a>希尔排序（不稳定）</h3><p>希尔排序是希尔（Donald-Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>\n<p><strong>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p>\n<h4 id=\"算法描述-3\"><a href=\"#算法描述-3\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>\n<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>\n<ul>\n<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>\n<li>按增量序列个数k，对序列进行k 趟排序；</li>\n<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ul>\n<h4 id=\"过程演示-3\"><a href=\"#过程演示-3\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdrsaujjj30hx0je7fd.jpg\" alt></p>\n<h4 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 希尔排序</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] ShellSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = array.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp, gap = len / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (gap &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class=\"line\">                temp = array[i];</span><br><span class=\"line\">                <span class=\"keyword\">int</span> preIndex = i - gap;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (preIndex &gt;= <span class=\"number\">0</span> &amp;&amp; array[preIndex] &gt; temp) &#123;</span><br><span class=\"line\">                    array[preIndex + gap] = array[preIndex];</span><br><span class=\"line\">                    preIndex -= gap;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                array[preIndex + gap] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            gap /= <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-3\"><a href=\"#算法分析-3\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlog2 n) </li>\n<li>最坏情况：T(n) = O(nlog2 n) </li>\n<li>平均情况：T(n) =O(nlog2n)　</li>\n</ul>\n<hr>\n<h3 id=\"归并排序（稳定）\"><a href=\"#归并排序（稳定）\" class=\"headerlink\" title=\"归并排序（稳定）\"></a>归并排序（稳定）</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p>\n<p><strong>归并排序（Merge-Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</strong></p>\n<h4 id=\"算法描述-4\"><a href=\"#算法描述-4\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li>把长度为n的输入序列分成两个长度为n/2的子序列；</li>\n<li>对这两个子序列分别采用归并排序；</li>\n<li>将两个排序好的子序列合并成一个最终的排序序列。</li>\n</ul>\n<h4 id=\"过程演示-4\"><a href=\"#过程演示-4\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdvclbg8g30hr0b248f.gif\" alt></p>\n<h4 id=\"代码实现-4\"><a href=\"#代码实现-4\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 归并排序</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] MergeSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = array.length / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] left = Arrays.copyOfRange(array, <span class=\"number\">0</span>, mid);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 归并排序——将两段排序好的数组结合成一个排序数组</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> left</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> right</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] merge(<span class=\"keyword\">int</span>[] left, <span class=\"keyword\">int</span>[] right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[left.length + right.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = <span class=\"number\">0</span>, i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>; index &lt; result.length; index++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;= left.length)</span><br><span class=\"line\">                result[index] = right[j++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (j &gt;= right.length)</span><br><span class=\"line\">                result[index] = left[i++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left[i] &gt; right[j])</span><br><span class=\"line\">                result[index] = right[j++];</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                result[index] = left[i++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-4\"><a href=\"#算法分析-4\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n) </li>\n<li>最差情况：T(n) = O(nlogn) </li>\n<li>平均情况：T(n) = O(nlogn)</li>\n</ul>\n<hr>\n<h3 id=\"快速排序（不稳定）\"><a href=\"#快速排序（不稳定）\" class=\"headerlink\" title=\"快速排序（不稳定）\"></a>快速排序（不稳定）</h3><p>快速排序（Quick-Sort）通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>\n<h4 id=\"算法描述-5\"><a href=\"#算法描述-5\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>\n<ul>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）；</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>\n</ul>\n<h4 id=\"过程演示-5\"><a href=\"#过程演示-5\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gazdyg13w7g30hp05iqbj.gif\" alt></p>\n<h4 id=\"代码实现-5\"><a href=\"#代码实现-5\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 快速排序方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> start</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] QuickSort(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array.length &lt; <span class=\"number\">1</span> || start &lt; <span class=\"number\">0</span> || end &gt;= array.length || start &gt; end) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> smallIndex = partition(array, start, end);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (smallIndex &gt; start)</span><br><span class=\"line\">            QuickSort(array, start, smallIndex - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (smallIndex &lt; end)</span><br><span class=\"line\">            QuickSort(array, smallIndex + <span class=\"number\">1</span>, end);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 快速排序算法——partition</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> start</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> pivot = (<span class=\"keyword\">int</span>) (start + Math.random() * (end - start + <span class=\"number\">1</span>));</span><br><span class=\"line\">        <span class=\"keyword\">int</span> smallIndex = start - <span class=\"number\">1</span>;</span><br><span class=\"line\">        swap(array, pivot, end);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = start; i &lt;= end; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (array[i] &lt;= array[end]) &#123;</span><br><span class=\"line\">                smallIndex++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt; smallIndex)</span><br><span class=\"line\">                    swap(array, i, smallIndex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> smallIndex;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 交换数组内两个元素</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> i</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> j</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = array[i];</span><br><span class=\"line\">        array[i] = array[j];</span><br><span class=\"line\">        array[j] = temp;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-5\"><a href=\"#算法分析-5\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn) </li>\n<li>最差情况：T(n) = O(n2) </li>\n<li>平均情况：T(n) = O(nlogn)　</li>\n</ul>\n<hr>\n<h3 id=\"堆排序（不稳定）\"><a href=\"#堆排序（不稳定）\" class=\"headerlink\" title=\"堆排序（不稳定）\"></a>堆排序（不稳定）</h3><p>堆排序（Heap-Sort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>\n<h4 id=\"算法描述-6\"><a href=\"#算法描述-6\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li>\n<li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li>\n<li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li>\n</ul>\n<h4 id=\"过程演示-6\"><a href=\"#过程演示-6\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaze1k0uc8g30f70a44qp.gif\" alt></p>\n<h4 id=\"代码实现-6\"><a href=\"#代码实现-6\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//声明全局变量，用于记录数组array的长度；</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 堆排序算法</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] HeapSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        len = array.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"comment\">//1.构建一个最大堆</span></span><br><span class=\"line\">        buildMaxHeap(array);</span><br><span class=\"line\">        <span class=\"comment\">//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            swap(array, <span class=\"number\">0</span>, len - <span class=\"number\">1</span>);</span><br><span class=\"line\">            len--;</span><br><span class=\"line\">            adjustHeap(array, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 建立最大堆</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">buildMaxHeap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//从最后一个非叶子节点开始向上构造最大堆</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = (len/<span class=\"number\">2</span> - <span class=\"number\">1</span>); i &gt;= <span class=\"number\">0</span>; i--) &#123; <span class=\"comment\">//感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) </span></span><br><span class=\"line\">            adjustHeap(array, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 调整使之成为最大堆</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> i</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">adjustHeap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxIndex = i;</span><br><span class=\"line\">        <span class=\"comment\">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i * <span class=\"number\">2</span> &lt; len &amp;&amp; array[i * <span class=\"number\">2</span>] &gt; array[maxIndex])</span><br><span class=\"line\">            maxIndex = i * <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i * <span class=\"number\">2</span> + <span class=\"number\">1</span> &lt; len &amp;&amp; array[i * <span class=\"number\">2</span> + <span class=\"number\">1</span>] &gt; array[maxIndex])</span><br><span class=\"line\">            maxIndex = i * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (maxIndex != i) &#123;</span><br><span class=\"line\">            swap(array, maxIndex, i);</span><br><span class=\"line\">            adjustHeap(array, maxIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-6\"><a href=\"#算法分析-6\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(nlogn) </li>\n<li>最差情况：T(n) = O(nlogn) </li>\n<li>平均情况：T(n) = O(nlogn)</li>\n</ul>\n<hr>\n<h3 id=\"基数排序（稳定）\"><a href=\"#基数排序（稳定）\" class=\"headerlink\" title=\"基数排序（稳定）\"></a>基数排序（稳定）</h3><p>基数排序（Radix-Sort）也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn)，为数组长度，k为数组中的数的最大的位数。</p>\n<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>\n<h4 id=\"算法描述-7\"><a href=\"#算法描述-7\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h4><ul>\n<li>取得数组中的最大数，并取得位数；</li>\n<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>\n<li>对radix进行计数排序(利用计数排序适用于小范围数的特点)；</li>\n</ul>\n<h4 id=\"过程演示-7\"><a href=\"#过程演示-7\" class=\"headerlink\" title=\"过程演示\"></a>过程演示</h4><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gaze4srwjig30hs0a3kjl.gif\" alt></p>\n<h4 id=\"代码实现-7\"><a href=\"#代码实现-7\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 基数排序</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> array</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] RadixSort(<span class=\"keyword\">int</span>[] array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (array == <span class=\"keyword\">null</span> || array.length &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">        <span class=\"comment\">// 1.先算出最大数的位数；</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">            max = Math.max(max, array[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> maxDigit = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (max != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            max /= <span class=\"number\">10</span>;</span><br><span class=\"line\">            maxDigit++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mod = <span class=\"number\">10</span>, div = <span class=\"number\">1</span>;</span><br><span class=\"line\">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class=\"keyword\">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)</span><br><span class=\"line\">            bucketList.add(<span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; maxDigit; i++, mod *= <span class=\"number\">10</span>, div *= <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; array.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> num = (array[j] % mod) / div;</span><br><span class=\"line\">                bucketList.get(num).add(array[j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class=\"line\">                    array[index++] = bucketList.get(j).get(k);</span><br><span class=\"line\">                bucketList.get(j).clear();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"算法分析-7\"><a href=\"#算法分析-7\" class=\"headerlink\" title=\"算法分析\"></a>算法分析</h4><ul>\n<li>最佳情况：T(n) = O(n * k) </li>\n<li>最差情况：T(n) = O(n * k) </li>\n<li>平均情况：T(n) = O(n * k)</li>\n</ul>\n<p>基数排序有两种方法：</p>\n<ul>\n<li>MSD 从高位开始进行排序</li>\n<li>LSD 从低位开始进行排序</li>\n</ul>"},{"title":"线程池实现原理与源码分析","date":"2019-03-11T13:26:44.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## 线程池原理\n\n### 使用线程池的好处\n\n1. **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n2. **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n3. **提高线程的可管理性**。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。\n\n### 线程池的实现原理\n\n1. 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。\n2. \n   线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。\n3. \n   线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<!--more-->\n\n对应到代码层面就是`ThreadPoolExecutor`执行`execute()`方法\n\n1. 当<kbd>workerCount</kbd> < <kbd>corePoolSize</kbd>，创建新线程执行任务。\n2. 当<kbd>workerCount</kbd> >= <kbd>corePoolSize</kbd>，并且阻塞队列workQueue未满，把新的任务放入阻塞队列。\n3. 当workQueue已满，并且<kbd>workerCount</kbd> >= <kbd>corePoolSize</kbd>，并且<kbd>workerCount</kbd> < <kbd>maximumPoolSize</kbd>，创建新线程执行任务。\n4. 当workQueue已满，并且<kbd>workerCount</kbd> >= <kbd>maximumPoolSize</kbd>，采取拒绝策略,根据不同的拒绝策略处理,默认拒绝策略是直接抛异常。\n\n由于创建新线程时（第1步、第3步）需要获取全局锁，所以ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。\n\n### 线程池状态转换模型\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb1qb2e8lbj31lo0jiu0x.jpg)\n\n- `RUNNING` 自然是运行状态，指可以接受任务执行队列里的任务\n- `SHUTDOWN` 指调用了 `shutdown()` 方法，不再接受新任务了，但是队列里的任务得执行完毕。\n- `STOP` 指调用了 `shutdownNow()` 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。\n- `TIDYING` 所有任务都执行完毕，在调用 `shutdown()/shutdownNow()` 中都会尝试更新为这个状态。\n- `TERMINATED` 终止状态，当执行 `terminated()` 后会更新为这个状态。\n\n## 线程池的使用\n\n### 创建线程池\n\n我们可以通过ThreadPoolExecutor的**构造方法**来创建线程池\n\n```java\npublic ThreadPoolExecutor(\n   int corePoolSize,\n   int maximumPoolSize,                              \n      long keepAliveTime,\n   TimeUnit unit,\n   BlockingQueue<Runnable> workQueue,\n   ThreadFactory threadFactory,\n   RejectedExecutionHandler handler){\n}\n```\n\n下面介绍一下代码中的参数：\n\n1. corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，如果当前poolSize<corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。\n\n2. maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。\n\n3. keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。\n\n4. TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。\n\n5. runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。\n\n   - ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。\n\n   - LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。\n   - SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。\n   - PriorityBlockingQueue：一个具有优先级的无限阻塞队列。\n\n6. ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线\n   程设置有意义的名字，代码如下。\n\n   ```java\n   new ThreadFactoryBuilder().setNameFormat(\"XX-task-%d\").build();\n   ```\n\n7. RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。\n\n   - AbortPolicy：直接抛出异常。(默认)\n   - CallerRunsPolicy：只用调用者所在线程来运行任务。\n   - DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。\n   - DiscardPolicy：不处理，丢弃掉。\n\n\n当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。\n\n### 向线程池提交任务\n\n可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。\n\n区别:\n\n- execute()方法用于提交**不需要返回值**的任务;\n- submit()方法用于提交**需要返回值**的任务。\n\nexecute方法：\n\n\nexecute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。\n\n```java\nthreadsPool.execute(new Runnable() {\n  @Override\n  public void run() {\n  \t// TODO Auto-generated method stub\n  }\n});\n```\n\nsubmit方法：\n\n\n线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方\n法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。\n\n```java\nFuture<Object> future = executor.submit(haveReturnValuetask);\ntry {\n\tObject s = future.get();\n} catch (InterruptedException e) {\n\t// 处理中断异常\n} catch (ExecutionException e) {\n\t// 处理无法执行任务异常\n} finally {\n\t// 关闭线程池\n\texecutor.shutdown();\n}\n```\n\n### 关闭线程池\n\n- shutdown()\n- shutdownNow()\n\n它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。\n\n区别：\n\nshutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。\n\n总结：\n\n至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。\n\n### 线程池实例Demo\n\n1. 首先构造一个线程池，用ArrayBlockingQueue作为其等待队列，队列初始化容量为1。该线程池核心容量为 10，最大容量为20，线程存活时间为1分钟。\n\n   ```java\n   static BlockingQueue blockingQueue=new ArrayBlockingQueue<>(1);\n   static ThreadPoolExecutor threadPoolExecutor=new ThreadPoolExecutor(10, 20, 1, TimeUnit.MINUTES, blockingQueue);\n   ```\n\n2. 另外构造了一个实现Runable接口的类TaskBusyWithoutResult类，其模拟一个繁忙的任务：\n\n   ```java\n   static class TaskBusyWithoutResult implements Runnable\n   {\n      public TaskBusyWithoutResult()\n      {\n      }\n      @Override\n      public void run() \n      {\n          System.out.println(\"线程\"+Thread.currentThread()+\"开始运行\");\n          int i=10000*10000;\n          while(i>0)\n          {\n              i--;\n          }\n          System.out.println(\"线程\"+Thread.currentThread()+\"运行结束\");\n      }\n   }\n   ```\n\n3. 向线程池提交20个任务，执行任务\n\n   ```java\n   public static void main(String[] args) {\n       for (int i = 0; i < 20; i++) {\n           Runnable runnable = new TaskBusyWithoutResult();\n           threadPoolExecutor.submit(runnable);\n       }\n   }\n   ```\n\n## 线程池源码分析\n\n**基于JDK1.8**\n\n### ctl 变量\n\n后面execute方法会用到ctl，这个变量是为了把工作线程数量和线程池状态放在一个int型变量存储而设置的一个原子类型的变量。 在ctl中，低位的29位表示工作线程的数量，高位用来表示RUNNING、SHUTDOWN、STOP等状态。上面定义的三个方法只是为了计算得到线程池的状态和工作线程的数量，以及得到ctl。\n\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n   private static final int COUNT_BITS = Integer.SIZE - 3;\n   private static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n   // runState is stored in the high-order bits\n   private static final int RUNNING    = -1 << COUNT_BITS;\n   private static final int SHUTDOWN   =  0 << COUNT_BITS;\n   private static final int STOP       =  1 << COUNT_BITS;\n   private static final int TIDYING    =  2 << COUNT_BITS;\n   private static final int TERMINATED =  3 << COUNT_BITS;\n\n   // Packing and unpacking ctl\n   private static int runStateOf(int c)     { return c & ~CAPACITY; }\n   private static int workerCountOf(int c)  { return c & CAPACITY; }\n   private static int ctlOf(int rs, int wc) { return rs | wc; }\n```\n\n### execute()方法\n\n- if (! isRunning(recheck) && remove(command))这句。由于&&是短路与，意思就是前面如果非真，后面不会执行。所以如果线程池不是Running状态时，才把现成移出工作队列，再使用饱和策略。\n- addWorker(command, false)：我们看到有addWorker(command, true)和addWorker(command, false)。true和false分别代表在检查工作线程数量的时候是应该与corePoolSize对比还是应该maximumPoolSize对比。只有第一个if时，也就是当前线程数小于corePoolSize时才用addWorker(command, true)。\n\n```java\npublic void execute(Runnable command) {\n   //如果提交了空的任务 抛出异常\n if (command == null)\n   throw new NullPointerException();\n int c = ctl.get();//获取当前线程池的状态\n   //检查当前工作线程数量是否小于核心线程数量\n if (workerCountOf(c) < corePoolSize) {\n   //通过addWorker方法提交任务\n   if (addWorker(command, true))\n     return;\n   c = ctl.get();//如果提交失败 需要二次检查状态\n }\n //向工作线程提交任务 \n if (isRunning(c) && workQueue.offer(command)) {\n   // 再次检查状态\n      int recheck = ctl.get();\n      \n      if (! isRunning(recheck) && remove(command))\n        reject(command);\n      else if (workerCountOf(recheck) == 0)\n        addWorker(null, false);\n }\n //扩容失败 则拒绝任务\n else if (!addWorker(command, false))\n   reject(command);\n}\n```\n\n### addWorker()方法\n\n这个方法是任务提交的一个核心方法，在里面完成了状态检查、新建任务、执行任务等一系列动作，主要工作是在线程池中创建一个新的线程并执行。\n\n这个方法可以分为两个阶段来看，第一个阶段是判断是否有必要新增一个工作线程，如果有则利用CAS更新工作线程的数量；第二部分是将提交的任务封装成一个工作线程Worker然后加入到线程池的容器中，开始执行新提交的任务。这个Worker在执行完任务后，还会循环地获取工作队列里的任务来执行。\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n       retry:\n   //死循环更新状态\n       for (;;) {\n           int c = ctl.get();\n           int rs = runStateOf(c);//获取运行状态\n\n       //检查线程池是否处于关闭状态\n           if (rs >= SHUTDOWN &&\n               ! (rs == SHUTDOWN &&\n                  firstTask == null &&\n                  ! workQueue.isEmpty()))\n               return false;\n   \n           for (;;) {\n         //获取当前工作线程数量\n               int wc = workerCountOf(c);\n       //如果已经超过corePoolSize获取maximumPoolSize 返回false\n               if (wc >= CAPACITY ||\n                   wc >= (core ? corePoolSize : maximumPoolSize))\n                   return false;\n       //CAS增加一个工作线程\n               if (compareAndIncrementWorkerCount(c))\n                break retry;\n       //再次获取状态\n               c = ctl.get();  // Re-read ctl\n       //如果状态更新失败 则循环更新\n               if (runStateOf(c) != rs)\n                   continue retry;\n               // else CAS failed due to workerCount change; retry inner loop\n           }\n       }\n\n       boolean workerStarted = false;\n       boolean workerAdded = false;\n       Worker w = null;\n       try {\n           w = new Worker(firstTask);//初始化一个工作线程\n           final Thread t = w.thread;\n           if (t != null) {\n        //获得锁\n               final ReentrantLock mainLock = this.mainLock;\n               mainLock.lock();\n               try {\n                   // Recheck while holding lock.\n                   // Back out on ThreadFactory failure or if\n                   // shut down before lock acquired.\n                   int rs = runStateOf(ctl.get());\n\n                   if (rs < SHUTDOWN ||\n                       (rs == SHUTDOWN && firstTask == null)) {\n                       if (t.isAlive()) // precheck that t is startable\n                           throw new IllegalThreadStateException();\n           //添加工作这到hashset中保存\n                       workers.add(w);\n                       int s = workers.size();\n                       if (s > largestPoolSize)\n                           largestPoolSize = s;\n                       workerAdded = true;\n                   }\n               } finally {\n                   mainLock.unlock();\n               }\n               if (workerAdded) {\n       //工作线程启动 执行第一个任务 就是新提交的任务\n                   t.start();\n                   workerStarted = true;\n               }\n           }\n       } finally {\n           if (! workerStarted)\n               addWorkerFailed(w);\n       }\n       return workerStarted;\n   }\n```\n\nWorker的构造方法如下：\n\n```java\n/**\n * Creates with given first task and thread from ThreadFactory.\n * @param firstTask the first task (null if none)\n */\nWorker(Runnable firstTask) {\n    setState(-1); // inhibit interrupts until runWorker\n    this.firstTask = firstTask;\n    this.thread = getThreadFactory().newThread(this);\n}\n```\n\n### runWorker()方法\n\n在addWorker方法快要结束的地方，调用了t.start()方法，我们知道它实际执行的就是Worker对象的run()方法，而worker的run()方法是这样定义的：\n\n```java\n/** Delegates main run loop to outer runWorker  */\npublic void run() {\n    runWorker(this);\n}\n```\n\n它实际上是将自己委托给线程池的runWorker方法\n\n```java\nfinal void runWorker(Worker w) {\n       \n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n       try {\n       //不断地从blockingQueue获取任务\n           while (task != null || (task = getTask()) != null) {\n               w.lock();\n               // If pool is stopping, ensure thread is interrupted;\n               // if not, ensure thread is not interrupted.  This\n               // requires a recheck in second case to deal with\n               // shutdownNow race while clearing interrupt\n               if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() &&\n                     runStateAtLeast(ctl.get(), STOP))) &&\n                   !wt.isInterrupted())\n                   wt.interrupt();\n               try {\n           //执行beforeExecute方法\n                   beforeExecute(wt, task);\n                   Throwable thrown = null;\n                   try {\n           //调用Runable的run方法\n                       task.run();\n                   } catch (RuntimeException x) {\n                       thrown = x; throw x;\n                   } catch (Error x) {\n                       thrown = x; throw x;\n                   } catch (Throwable x) {\n                       thrown = x; throw new Error(x);\n                   } finally {\n           // 执行aferExecute方法\n                       afterExecute(task, thrown);\n                   }\n               } finally {\n                   task = null;\n                   w.completedTasks++;\n                   w.unlock();\n               }\n           }\n           completedAbruptly = false;\n       } finally {\n           processWorkerExit(w, completedAbruptly);\n       }\n}\n```\n\n总结一下runWorker方法的执行过程：\n\n1. while循环中，不断地通过getTask()方法从workerQueue中获取任务\n2. 如果线程池正在停止，则中断线程。否则调用3.\n3. 调用task.run()执行任务；\n4. 如果task为null则跳出循环，执行processWorkerExit()方法，销毁线程workers.remove(w);\n\n它在不断执行我们提交的任务的run方法。而这个任务可能是我们新提交的，也有可能是从等待队列中获取的。这样就实现了线程池的完成逻辑。\n\n## ExecutorService\n\n**创建线程池的5个方法：**\n\n### newSingleThreadExecutor\n\n只有一个线程的线程池，因此所有提交的任务是**顺序执行**。\n\n```java\nExecutorService executorService = Executors.newSingleThreadExecutor();\n```\n\n构造方法源码\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n\n这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。\n\n返回单线程的Executor，将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n\n------\n\n### newCachedThreadPool\n\n缓存型线程池，先查看池中有没有以前建立的线程，如果有，就重用，如果没有，就建一个新的线程加入池中。如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n\n```java\nExecutorService executorService = Executors.newCachedThreadPool();\n```\n\n构造方法源码\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0,//线程池维护线程的最少数量\n                Integer.MAX_VALUE,//线程池维护线程的最大数量\n                60L,//线程池维护线程所允许的空闲时间，60秒\n                TimeUnit.SECONDS,//线程池维护线程所允许的空闲时间的单位\n                new SynchronousQueue<Runnable>());\n}\n```\n\n实例\n\n```java\npublic static void main(String[] args){\n        ExecutorService exe= Executors.newCachedThreadPool();\n        for(int i=1;i<6;i++){\n            final int taskID=i;\n            exe.execute(new Runnable() {\n                public void run() {\n                    for(int j=1;j<4;j++){\n                        try {\n                            Thread.sleep(500);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(\"线程ID：\"+taskID+\",执行第 \"+j+\" 次\");\n                    }\n                }\n            });\n        }\n    }\n```\n\n执行结果\n\n```xml\n线程ID：3，执行第 1 次\n线程ID：4，执行第 1 次\n线程ID：2，执行第 1 次\n线程ID：5，执行第 1 次\n线程ID：1，执行第 1 次\n\n线程ID：2，执行第 2 次\n线程ID：3，执行第 2 次\n线程ID：4，执行第 2 次\n线程ID：1，执行第 2 次\n线程ID：5，执行第 2 次\n\n线程ID：2，执行第 3 次\n线程ID：3，执行第 3 次\n线程ID：4，执行第 3 次\n线程ID：5，执行第 3 次\n线程ID：1，执行第 3 次\n```\n\n可以看到执行结果是5个任务在交替进行的\n\nnewCachedThreadPool的总结：\n\n1. 重用：缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。\n2. 使用场景：缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。\n3. 超时：能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。\n4. 结束：注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。\n\n------\n\n### newFixedThreadPool\n\n定长线程池，可控制线程最大并发数。如果当前需要执行的任务超过池大小，那么多出的任务处于等待状态，直到有空闲下来的线程执行任务，如果当前需要执行的任务小于池大小，空闲的线程也不会去销毁。\n\n```java\nExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);\n```\n\n构造方法源码：有两个重载方法\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(\n                nThreads,//线程池维护线程的最少数量\n                nThreads,//线程池维护线程的最大数量\n                0L, //线程池维护线程所允许的空闲时间\n                TimeUnit.MILLISECONDS,//线程池维护线程所允许的空闲时间的单位\n                new LinkedBlockingQueue<Runnable>());\n}\npublic static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n }\n```\n\n实例\n\n```java\npublic static void main(String[] args) {\n        ExecutorService exe = Executors.newFixedThreadPool(3);\n        for (int i = 1; i < 6; i++) {\n            final int taskID = i;\n            exe.execute(new Runnable() {\n                public void run() {\n                    for (int j = 1; j < 4; j++) {\n                        try {\n                            Thread.sleep(500);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(\"线程ID：\" + taskID + \"，执行第 \" + j + \" 次\");\n                    }\n                }\n            });\n        }\n    }\n```\n\n执行结果\n\n```xml\n线程ID：2，执行第 1 次\n线程ID：1，执行第 1 次\n线程ID：3，执行第 1 次\n\n线程ID：2，执行第 2 次\n线程ID：3，执行第 2 次\n线程ID：1，执行第 2 次\n\n线程ID：2，执行第 3 次\n线程ID：3，执行第 3 次\n线程ID：1，执行第 3 次\n\n线程ID：4，执行第 1 次\n线程ID：5，执行第 1 次\n线程ID：4，执行第 2 次\n\n线程ID：5，执行第 2 次\n线程ID：4，执行第 3 次\n线程ID：5，执行第 3 次\n```\n\n创建了一个固定大小的线程池，容量为3，然后循环执行了5个任务。由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4,5个任务。\nnewFixedThreadPool的总结：\n\n1. 重用：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。\n2. 固定数目：其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。\n3. 超时：和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的）。\n4. 使用场景：所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。\n\n------\n\n### newScheduledThreadPool\n\n调度型线程池,支持定时及周期性任务执行，也是一个固定长度的线程池。\n\n```java\nScheduledExecutorService exe= Executors.newScheduledThreadPool(3);\n```\n\n构造方法源码\n\n```java\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, // 线程池维护线程的最少数量\n        Integer.MAX_VALUE, //线程池维护线程的最大数量\n        0, // 线程池维护线程所允许的空闲时间\n        NANOSECONDS,//线程池维护线程所允许的空闲时间的单位\n        new DelayedWorkQueue());\n    }\n```\n\n实例\n\n```java\npublic static void main(String[] args){\n        ScheduledExecutorService exe= Executors.newScheduledThreadPool(3);\n            for(int i=1;i<6;i++){\n                final int taskID=i;\n                exe.scheduleAtFixedRate(new Runnable() {\n                    public void run() {\n                        try {\n                            Thread.sleep(2000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(\"线程：\"+taskID+\",时间：\"+ LocalDateTime.now()+\" 执行一次\");\n                    }\n                }, 0, 2, TimeUnit.SECONDS);\n            }\n    }\n```\n\n代码scheduleAtFixedRate后面的参数 0 表示立即执行，2表示2秒执行一次调度。执行结果：\n\n```xml\n线程：1,时间：2016-12-11T13:09:18.544 执行一次\n线程：2,时间：2016-12-11T13:09:18.544 执行一次\n线程：3,时间：2016-12-11T13:09:18.544 执行一次\n\n线程：5,时间：2016-12-11T13:09:20.557 执行一次\n线程：1,时间：2016-12-11T13:09:20.557 执行一次\n线程：4,时间：2016-12-11T13:09:20.557 执行一次\n\n线程：4,时间：2016-12-11T13:09:22.572 执行一次\n线程：2,时间：2016-12-11T13:09:22.572 执行一次\n线程：3,时间：2016-12-11T13:09:22.572 执行一次\n\n线程：5,时间：2016-12-11T13:09:24.586 执行一次\n线程：1,时间：2016-12-11T13:09:24.586 执行一次\n线程：2,时间：2016-12-11T13:09:24.586 执行一次\n```\n\nnewScheduledThreadPool的线程池大小只设置了3，所以一次只能执行3个线程，然后可以看到每2秒执行一次任务调度。\n\n------\n\n### newSingleThreadScheduledPool\n\n单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。\n\n```java\nExecutorService exe= Executors.newSingleThreadExecutor();\n```\n\n构造方法源码\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n\n实例\n\n```java\npublic static void main(String[] args){\n        ExecutorService exe= Executors.newSingleThreadExecutor();\n        for(int i=1;i<6;i++){\n            final int taskID=i;\n            exe.execute(new Runnable() {\n                public void run() {\n                    for(int j=1;j<4;j++){\n                        try {\n                            Thread.sleep(500);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(\"线程ID：\"+taskID+\"，执行第 \"+j+\" 次\");\n                    }\n                }\n            });\n        }\n    }\n```\n\n执行结果\n\n```xml\n线程ID：1，执行第 1 次\n线程ID：1，执行第 2 次\n线程ID：1，执行第 3 次\n线程ID：2，执行第 1 次\n线程ID：2，执行第 2 次\n线程ID：2，执行第 3 次\n线程ID：3，执行第 1 次\n线程ID：3，执行第 2 次\n线程ID：3，执行第 3 次\n线程ID：4，执行第 1 次\n线程ID：4，执行第 2 次\n线程ID：4，执行第 3 次\n线程ID：5，执行第 1 次\n线程ID：5，执行第 2 次\n线程ID：5，执行第 3 次\n```\n\n每个结果都是相隔0.5秒打印出来的，顺序执行下去。\n\n\n\n- \n\n","source":"_posts/Thread-Pool.md","raw":"---\ntitle: 线程池实现原理与源码分析\ndate: 2019-03-11 21:26:44\ncategories: \n  - Java\n  - 高并发\ntags: \n  - 高并发\n  - 线程池\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## 线程池原理\n\n### 使用线程池的好处\n\n1. **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n2. **提高响应速度**。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n3. **提高线程的可管理性**。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。\n\n### 线程池的实现原理\n\n1. 线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。\n2. \n   线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。\n3. \n   线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<!--more-->\n\n对应到代码层面就是`ThreadPoolExecutor`执行`execute()`方法\n\n1. 当<kbd>workerCount</kbd> < <kbd>corePoolSize</kbd>，创建新线程执行任务。\n2. 当<kbd>workerCount</kbd> >= <kbd>corePoolSize</kbd>，并且阻塞队列workQueue未满，把新的任务放入阻塞队列。\n3. 当workQueue已满，并且<kbd>workerCount</kbd> >= <kbd>corePoolSize</kbd>，并且<kbd>workerCount</kbd> < <kbd>maximumPoolSize</kbd>，创建新线程执行任务。\n4. 当workQueue已满，并且<kbd>workerCount</kbd> >= <kbd>maximumPoolSize</kbd>，采取拒绝策略,根据不同的拒绝策略处理,默认拒绝策略是直接抛异常。\n\n由于创建新线程时（第1步、第3步）需要获取全局锁，所以ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。\n\n### 线程池状态转换模型\n\n![](https://tva1.sinaimg.cn/large/006tNbRwgy1gb1qb2e8lbj31lo0jiu0x.jpg)\n\n- `RUNNING` 自然是运行状态，指可以接受任务执行队列里的任务\n- `SHUTDOWN` 指调用了 `shutdown()` 方法，不再接受新任务了，但是队列里的任务得执行完毕。\n- `STOP` 指调用了 `shutdownNow()` 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。\n- `TIDYING` 所有任务都执行完毕，在调用 `shutdown()/shutdownNow()` 中都会尝试更新为这个状态。\n- `TERMINATED` 终止状态，当执行 `terminated()` 后会更新为这个状态。\n\n## 线程池的使用\n\n### 创建线程池\n\n我们可以通过ThreadPoolExecutor的**构造方法**来创建线程池\n\n```java\npublic ThreadPoolExecutor(\n   int corePoolSize,\n   int maximumPoolSize,                              \n      long keepAliveTime,\n   TimeUnit unit,\n   BlockingQueue<Runnable> workQueue,\n   ThreadFactory threadFactory,\n   RejectedExecutionHandler handler){\n}\n```\n\n下面介绍一下代码中的参数：\n\n1. corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，如果当前poolSize<corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。\n\n2. maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。\n\n3. keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。\n\n4. TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。\n\n5. runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。\n\n   - ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。\n\n   - LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。\n   - SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。\n   - PriorityBlockingQueue：一个具有优先级的无限阻塞队列。\n\n6. ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线\n   程设置有意义的名字，代码如下。\n\n   ```java\n   new ThreadFactoryBuilder().setNameFormat(\"XX-task-%d\").build();\n   ```\n\n7. RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。\n\n   - AbortPolicy：直接抛出异常。(默认)\n   - CallerRunsPolicy：只用调用者所在线程来运行任务。\n   - DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。\n   - DiscardPolicy：不处理，丢弃掉。\n\n\n当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。\n\n### 向线程池提交任务\n\n可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。\n\n区别:\n\n- execute()方法用于提交**不需要返回值**的任务;\n- submit()方法用于提交**需要返回值**的任务。\n\nexecute方法：\n\n\nexecute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。\n\n```java\nthreadsPool.execute(new Runnable() {\n  @Override\n  public void run() {\n  \t// TODO Auto-generated method stub\n  }\n});\n```\n\nsubmit方法：\n\n\n线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方\n法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。\n\n```java\nFuture<Object> future = executor.submit(haveReturnValuetask);\ntry {\n\tObject s = future.get();\n} catch (InterruptedException e) {\n\t// 处理中断异常\n} catch (ExecutionException e) {\n\t// 处理无法执行任务异常\n} finally {\n\t// 关闭线程池\n\texecutor.shutdown();\n}\n```\n\n### 关闭线程池\n\n- shutdown()\n- shutdownNow()\n\n它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。\n\n区别：\n\nshutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。\n\n总结：\n\n至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。\n\n### 线程池实例Demo\n\n1. 首先构造一个线程池，用ArrayBlockingQueue作为其等待队列，队列初始化容量为1。该线程池核心容量为 10，最大容量为20，线程存活时间为1分钟。\n\n   ```java\n   static BlockingQueue blockingQueue=new ArrayBlockingQueue<>(1);\n   static ThreadPoolExecutor threadPoolExecutor=new ThreadPoolExecutor(10, 20, 1, TimeUnit.MINUTES, blockingQueue);\n   ```\n\n2. 另外构造了一个实现Runable接口的类TaskBusyWithoutResult类，其模拟一个繁忙的任务：\n\n   ```java\n   static class TaskBusyWithoutResult implements Runnable\n   {\n      public TaskBusyWithoutResult()\n      {\n      }\n      @Override\n      public void run() \n      {\n          System.out.println(\"线程\"+Thread.currentThread()+\"开始运行\");\n          int i=10000*10000;\n          while(i>0)\n          {\n              i--;\n          }\n          System.out.println(\"线程\"+Thread.currentThread()+\"运行结束\");\n      }\n   }\n   ```\n\n3. 向线程池提交20个任务，执行任务\n\n   ```java\n   public static void main(String[] args) {\n       for (int i = 0; i < 20; i++) {\n           Runnable runnable = new TaskBusyWithoutResult();\n           threadPoolExecutor.submit(runnable);\n       }\n   }\n   ```\n\n## 线程池源码分析\n\n**基于JDK1.8**\n\n### ctl 变量\n\n后面execute方法会用到ctl，这个变量是为了把工作线程数量和线程池状态放在一个int型变量存储而设置的一个原子类型的变量。 在ctl中，低位的29位表示工作线程的数量，高位用来表示RUNNING、SHUTDOWN、STOP等状态。上面定义的三个方法只是为了计算得到线程池的状态和工作线程的数量，以及得到ctl。\n\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\n   private static final int COUNT_BITS = Integer.SIZE - 3;\n   private static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n   // runState is stored in the high-order bits\n   private static final int RUNNING    = -1 << COUNT_BITS;\n   private static final int SHUTDOWN   =  0 << COUNT_BITS;\n   private static final int STOP       =  1 << COUNT_BITS;\n   private static final int TIDYING    =  2 << COUNT_BITS;\n   private static final int TERMINATED =  3 << COUNT_BITS;\n\n   // Packing and unpacking ctl\n   private static int runStateOf(int c)     { return c & ~CAPACITY; }\n   private static int workerCountOf(int c)  { return c & CAPACITY; }\n   private static int ctlOf(int rs, int wc) { return rs | wc; }\n```\n\n### execute()方法\n\n- if (! isRunning(recheck) && remove(command))这句。由于&&是短路与，意思就是前面如果非真，后面不会执行。所以如果线程池不是Running状态时，才把现成移出工作队列，再使用饱和策略。\n- addWorker(command, false)：我们看到有addWorker(command, true)和addWorker(command, false)。true和false分别代表在检查工作线程数量的时候是应该与corePoolSize对比还是应该maximumPoolSize对比。只有第一个if时，也就是当前线程数小于corePoolSize时才用addWorker(command, true)。\n\n```java\npublic void execute(Runnable command) {\n   //如果提交了空的任务 抛出异常\n if (command == null)\n   throw new NullPointerException();\n int c = ctl.get();//获取当前线程池的状态\n   //检查当前工作线程数量是否小于核心线程数量\n if (workerCountOf(c) < corePoolSize) {\n   //通过addWorker方法提交任务\n   if (addWorker(command, true))\n     return;\n   c = ctl.get();//如果提交失败 需要二次检查状态\n }\n //向工作线程提交任务 \n if (isRunning(c) && workQueue.offer(command)) {\n   // 再次检查状态\n      int recheck = ctl.get();\n      \n      if (! isRunning(recheck) && remove(command))\n        reject(command);\n      else if (workerCountOf(recheck) == 0)\n        addWorker(null, false);\n }\n //扩容失败 则拒绝任务\n else if (!addWorker(command, false))\n   reject(command);\n}\n```\n\n### addWorker()方法\n\n这个方法是任务提交的一个核心方法，在里面完成了状态检查、新建任务、执行任务等一系列动作，主要工作是在线程池中创建一个新的线程并执行。\n\n这个方法可以分为两个阶段来看，第一个阶段是判断是否有必要新增一个工作线程，如果有则利用CAS更新工作线程的数量；第二部分是将提交的任务封装成一个工作线程Worker然后加入到线程池的容器中，开始执行新提交的任务。这个Worker在执行完任务后，还会循环地获取工作队列里的任务来执行。\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n       retry:\n   //死循环更新状态\n       for (;;) {\n           int c = ctl.get();\n           int rs = runStateOf(c);//获取运行状态\n\n       //检查线程池是否处于关闭状态\n           if (rs >= SHUTDOWN &&\n               ! (rs == SHUTDOWN &&\n                  firstTask == null &&\n                  ! workQueue.isEmpty()))\n               return false;\n   \n           for (;;) {\n         //获取当前工作线程数量\n               int wc = workerCountOf(c);\n       //如果已经超过corePoolSize获取maximumPoolSize 返回false\n               if (wc >= CAPACITY ||\n                   wc >= (core ? corePoolSize : maximumPoolSize))\n                   return false;\n       //CAS增加一个工作线程\n               if (compareAndIncrementWorkerCount(c))\n                break retry;\n       //再次获取状态\n               c = ctl.get();  // Re-read ctl\n       //如果状态更新失败 则循环更新\n               if (runStateOf(c) != rs)\n                   continue retry;\n               // else CAS failed due to workerCount change; retry inner loop\n           }\n       }\n\n       boolean workerStarted = false;\n       boolean workerAdded = false;\n       Worker w = null;\n       try {\n           w = new Worker(firstTask);//初始化一个工作线程\n           final Thread t = w.thread;\n           if (t != null) {\n        //获得锁\n               final ReentrantLock mainLock = this.mainLock;\n               mainLock.lock();\n               try {\n                   // Recheck while holding lock.\n                   // Back out on ThreadFactory failure or if\n                   // shut down before lock acquired.\n                   int rs = runStateOf(ctl.get());\n\n                   if (rs < SHUTDOWN ||\n                       (rs == SHUTDOWN && firstTask == null)) {\n                       if (t.isAlive()) // precheck that t is startable\n                           throw new IllegalThreadStateException();\n           //添加工作这到hashset中保存\n                       workers.add(w);\n                       int s = workers.size();\n                       if (s > largestPoolSize)\n                           largestPoolSize = s;\n                       workerAdded = true;\n                   }\n               } finally {\n                   mainLock.unlock();\n               }\n               if (workerAdded) {\n       //工作线程启动 执行第一个任务 就是新提交的任务\n                   t.start();\n                   workerStarted = true;\n               }\n           }\n       } finally {\n           if (! workerStarted)\n               addWorkerFailed(w);\n       }\n       return workerStarted;\n   }\n```\n\nWorker的构造方法如下：\n\n```java\n/**\n * Creates with given first task and thread from ThreadFactory.\n * @param firstTask the first task (null if none)\n */\nWorker(Runnable firstTask) {\n    setState(-1); // inhibit interrupts until runWorker\n    this.firstTask = firstTask;\n    this.thread = getThreadFactory().newThread(this);\n}\n```\n\n### runWorker()方法\n\n在addWorker方法快要结束的地方，调用了t.start()方法，我们知道它实际执行的就是Worker对象的run()方法，而worker的run()方法是这样定义的：\n\n```java\n/** Delegates main run loop to outer runWorker  */\npublic void run() {\n    runWorker(this);\n}\n```\n\n它实际上是将自己委托给线程池的runWorker方法\n\n```java\nfinal void runWorker(Worker w) {\n       \n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n       try {\n       //不断地从blockingQueue获取任务\n           while (task != null || (task = getTask()) != null) {\n               w.lock();\n               // If pool is stopping, ensure thread is interrupted;\n               // if not, ensure thread is not interrupted.  This\n               // requires a recheck in second case to deal with\n               // shutdownNow race while clearing interrupt\n               if ((runStateAtLeast(ctl.get(), STOP) ||\n                    (Thread.interrupted() &&\n                     runStateAtLeast(ctl.get(), STOP))) &&\n                   !wt.isInterrupted())\n                   wt.interrupt();\n               try {\n           //执行beforeExecute方法\n                   beforeExecute(wt, task);\n                   Throwable thrown = null;\n                   try {\n           //调用Runable的run方法\n                       task.run();\n                   } catch (RuntimeException x) {\n                       thrown = x; throw x;\n                   } catch (Error x) {\n                       thrown = x; throw x;\n                   } catch (Throwable x) {\n                       thrown = x; throw new Error(x);\n                   } finally {\n           // 执行aferExecute方法\n                       afterExecute(task, thrown);\n                   }\n               } finally {\n                   task = null;\n                   w.completedTasks++;\n                   w.unlock();\n               }\n           }\n           completedAbruptly = false;\n       } finally {\n           processWorkerExit(w, completedAbruptly);\n       }\n}\n```\n\n总结一下runWorker方法的执行过程：\n\n1. while循环中，不断地通过getTask()方法从workerQueue中获取任务\n2. 如果线程池正在停止，则中断线程。否则调用3.\n3. 调用task.run()执行任务；\n4. 如果task为null则跳出循环，执行processWorkerExit()方法，销毁线程workers.remove(w);\n\n它在不断执行我们提交的任务的run方法。而这个任务可能是我们新提交的，也有可能是从等待队列中获取的。这样就实现了线程池的完成逻辑。\n\n## ExecutorService\n\n**创建线程池的5个方法：**\n\n### newSingleThreadExecutor\n\n只有一个线程的线程池，因此所有提交的任务是**顺序执行**。\n\n```java\nExecutorService executorService = Executors.newSingleThreadExecutor();\n```\n\n构造方法源码\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n\n这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。\n\n返回单线程的Executor，将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n\n------\n\n### newCachedThreadPool\n\n缓存型线程池，先查看池中有没有以前建立的线程，如果有，就重用，如果没有，就建一个新的线程加入池中。如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。\n\n```java\nExecutorService executorService = Executors.newCachedThreadPool();\n```\n\n构造方法源码\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0,//线程池维护线程的最少数量\n                Integer.MAX_VALUE,//线程池维护线程的最大数量\n                60L,//线程池维护线程所允许的空闲时间，60秒\n                TimeUnit.SECONDS,//线程池维护线程所允许的空闲时间的单位\n                new SynchronousQueue<Runnable>());\n}\n```\n\n实例\n\n```java\npublic static void main(String[] args){\n        ExecutorService exe= Executors.newCachedThreadPool();\n        for(int i=1;i<6;i++){\n            final int taskID=i;\n            exe.execute(new Runnable() {\n                public void run() {\n                    for(int j=1;j<4;j++){\n                        try {\n                            Thread.sleep(500);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(\"线程ID：\"+taskID+\",执行第 \"+j+\" 次\");\n                    }\n                }\n            });\n        }\n    }\n```\n\n执行结果\n\n```xml\n线程ID：3，执行第 1 次\n线程ID：4，执行第 1 次\n线程ID：2，执行第 1 次\n线程ID：5，执行第 1 次\n线程ID：1，执行第 1 次\n\n线程ID：2，执行第 2 次\n线程ID：3，执行第 2 次\n线程ID：4，执行第 2 次\n线程ID：1，执行第 2 次\n线程ID：5，执行第 2 次\n\n线程ID：2，执行第 3 次\n线程ID：3，执行第 3 次\n线程ID：4，执行第 3 次\n线程ID：5，执行第 3 次\n线程ID：1，执行第 3 次\n```\n\n可以看到执行结果是5个任务在交替进行的\n\nnewCachedThreadPool的总结：\n\n1. 重用：缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。\n2. 使用场景：缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。\n3. 超时：能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。\n4. 结束：注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。\n\n------\n\n### newFixedThreadPool\n\n定长线程池，可控制线程最大并发数。如果当前需要执行的任务超过池大小，那么多出的任务处于等待状态，直到有空闲下来的线程执行任务，如果当前需要执行的任务小于池大小，空闲的线程也不会去销毁。\n\n```java\nExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);\n```\n\n构造方法源码：有两个重载方法\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(\n                nThreads,//线程池维护线程的最少数量\n                nThreads,//线程池维护线程的最大数量\n                0L, //线程池维护线程所允许的空闲时间\n                TimeUnit.MILLISECONDS,//线程池维护线程所允许的空闲时间的单位\n                new LinkedBlockingQueue<Runnable>());\n}\npublic static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\n        return new ThreadPoolExecutor(nThreads, nThreads,\n                                      0L, TimeUnit.MILLISECONDS,\n                                      new LinkedBlockingQueue<Runnable>(),\n                                      threadFactory);\n }\n```\n\n实例\n\n```java\npublic static void main(String[] args) {\n        ExecutorService exe = Executors.newFixedThreadPool(3);\n        for (int i = 1; i < 6; i++) {\n            final int taskID = i;\n            exe.execute(new Runnable() {\n                public void run() {\n                    for (int j = 1; j < 4; j++) {\n                        try {\n                            Thread.sleep(500);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(\"线程ID：\" + taskID + \"，执行第 \" + j + \" 次\");\n                    }\n                }\n            });\n        }\n    }\n```\n\n执行结果\n\n```xml\n线程ID：2，执行第 1 次\n线程ID：1，执行第 1 次\n线程ID：3，执行第 1 次\n\n线程ID：2，执行第 2 次\n线程ID：3，执行第 2 次\n线程ID：1，执行第 2 次\n\n线程ID：2，执行第 3 次\n线程ID：3，执行第 3 次\n线程ID：1，执行第 3 次\n\n线程ID：4，执行第 1 次\n线程ID：5，执行第 1 次\n线程ID：4，执行第 2 次\n\n线程ID：5，执行第 2 次\n线程ID：4，执行第 3 次\n线程ID：5，执行第 3 次\n```\n\n创建了一个固定大小的线程池，容量为3，然后循环执行了5个任务。由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4,5个任务。\nnewFixedThreadPool的总结：\n\n1. 重用：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。\n2. 固定数目：其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。\n3. 超时：和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的）。\n4. 使用场景：所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。\n\n------\n\n### newScheduledThreadPool\n\n调度型线程池,支持定时及周期性任务执行，也是一个固定长度的线程池。\n\n```java\nScheduledExecutorService exe= Executors.newScheduledThreadPool(3);\n```\n\n构造方法源码\n\n```java\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n        super(corePoolSize, // 线程池维护线程的最少数量\n        Integer.MAX_VALUE, //线程池维护线程的最大数量\n        0, // 线程池维护线程所允许的空闲时间\n        NANOSECONDS,//线程池维护线程所允许的空闲时间的单位\n        new DelayedWorkQueue());\n    }\n```\n\n实例\n\n```java\npublic static void main(String[] args){\n        ScheduledExecutorService exe= Executors.newScheduledThreadPool(3);\n            for(int i=1;i<6;i++){\n                final int taskID=i;\n                exe.scheduleAtFixedRate(new Runnable() {\n                    public void run() {\n                        try {\n                            Thread.sleep(2000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(\"线程：\"+taskID+\",时间：\"+ LocalDateTime.now()+\" 执行一次\");\n                    }\n                }, 0, 2, TimeUnit.SECONDS);\n            }\n    }\n```\n\n代码scheduleAtFixedRate后面的参数 0 表示立即执行，2表示2秒执行一次调度。执行结果：\n\n```xml\n线程：1,时间：2016-12-11T13:09:18.544 执行一次\n线程：2,时间：2016-12-11T13:09:18.544 执行一次\n线程：3,时间：2016-12-11T13:09:18.544 执行一次\n\n线程：5,时间：2016-12-11T13:09:20.557 执行一次\n线程：1,时间：2016-12-11T13:09:20.557 执行一次\n线程：4,时间：2016-12-11T13:09:20.557 执行一次\n\n线程：4,时间：2016-12-11T13:09:22.572 执行一次\n线程：2,时间：2016-12-11T13:09:22.572 执行一次\n线程：3,时间：2016-12-11T13:09:22.572 执行一次\n\n线程：5,时间：2016-12-11T13:09:24.586 执行一次\n线程：1,时间：2016-12-11T13:09:24.586 执行一次\n线程：2,时间：2016-12-11T13:09:24.586 执行一次\n```\n\nnewScheduledThreadPool的线程池大小只设置了3，所以一次只能执行3个线程，然后可以看到每2秒执行一次任务调度。\n\n------\n\n### newSingleThreadScheduledPool\n\n单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。\n\n```java\nExecutorService exe= Executors.newSingleThreadExecutor();\n```\n\n构造方法源码\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n        return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                                    0L, TimeUnit.MILLISECONDS,\n                                    new LinkedBlockingQueue<Runnable>()));\n    }\n```\n\n实例\n\n```java\npublic static void main(String[] args){\n        ExecutorService exe= Executors.newSingleThreadExecutor();\n        for(int i=1;i<6;i++){\n            final int taskID=i;\n            exe.execute(new Runnable() {\n                public void run() {\n                    for(int j=1;j<4;j++){\n                        try {\n                            Thread.sleep(500);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                        System.out.println(\"线程ID：\"+taskID+\"，执行第 \"+j+\" 次\");\n                    }\n                }\n            });\n        }\n    }\n```\n\n执行结果\n\n```xml\n线程ID：1，执行第 1 次\n线程ID：1，执行第 2 次\n线程ID：1，执行第 3 次\n线程ID：2，执行第 1 次\n线程ID：2，执行第 2 次\n线程ID：2，执行第 3 次\n线程ID：3，执行第 1 次\n线程ID：3，执行第 2 次\n线程ID：3，执行第 3 次\n线程ID：4，执行第 1 次\n线程ID：4，执行第 2 次\n线程ID：4，执行第 3 次\n线程ID：5，执行第 1 次\n线程ID：5，执行第 2 次\n线程ID：5，执行第 3 次\n```\n\n每个结果都是相隔0.5秒打印出来的，顺序执行下去。\n\n\n\n- \n\n","slug":"Thread-Pool","published":1,"updated":"2020-01-21T12:07:31.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61cnn004oa6ybaoe058f8","content":"<h2 id=\"线程池原理\"><a href=\"#线程池原理\" class=\"headerlink\" title=\"线程池原理\"></a>线程池原理</h2><h3 id=\"使用线程池的好处\"><a href=\"#使用线程池的好处\" class=\"headerlink\" title=\"使用线程池的好处\"></a>使用线程池的好处</h3><ol>\n<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>\n</ol>\n<h3 id=\"线程池的实现原理\"><a href=\"#线程池的实现原理\" class=\"headerlink\" title=\"线程池的实现原理\"></a>线程池的实现原理</h3><ol>\n<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>\n<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>\n<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<a id=\"more\"></a></li>\n</ol>\n<p>对应到代码层面就是<code>ThreadPoolExecutor</code>执行<code>execute()</code>方法</p>\n<ol>\n<li>当<kbd>workerCount</kbd> &lt; <kbd>corePoolSize</kbd>，创建新线程执行任务。</li>\n<li>当<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且阻塞队列workQueue未满，把新的任务放入阻塞队列。</li>\n<li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且<kbd>workerCount</kbd> &lt; <kbd>maximumPoolSize</kbd>，创建新线程执行任务。</li>\n<li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>maximumPoolSize</kbd>，采取拒绝策略,根据不同的拒绝策略处理,默认拒绝策略是直接抛异常。</li>\n</ol>\n<p>由于创建新线程时（第1步、第3步）需要获取全局锁，所以ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。</p>\n<h3 id=\"线程池状态转换模型\"><a href=\"#线程池状态转换模型\" class=\"headerlink\" title=\"线程池状态转换模型\"></a>线程池状态转换模型</h3><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gb1qb2e8lbj31lo0jiu0x.jpg\" alt></p>\n<ul>\n<li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li>\n<li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li>\n<li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>\n<li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li>\n<li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li>\n</ul>\n<h2 id=\"线程池的使用\"><a href=\"#线程池的使用\" class=\"headerlink\" title=\"线程池的使用\"></a>线程池的使用</h2><h3 id=\"创建线程池\"><a href=\"#创建线程池\" class=\"headerlink\" title=\"创建线程池\"></a>创建线程池</h3><p>我们可以通过ThreadPoolExecutor的<strong>构造方法</strong>来创建线程池</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">int</span> maximumPoolSize,                              </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   RejectedExecutionHandler handler)</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面介绍一下代码中的参数：</p>\n<ol>\n<li><p>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，如果当前poolSize&lt;corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p>\n</li>\n<li><p>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p>\n</li>\n<li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p>\n</li>\n<li><p>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p>\n</li>\n<li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p>\n<ul>\n<li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</p>\n</li>\n<li><p>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</p>\n</li>\n<li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p>\n</li>\n<li><p>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p>\n</li>\n</ul>\n</li>\n<li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线<br>程设置有意义的名字，代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> ThreadFactoryBuilder().setNameFormat(<span class=\"string\">\"XX-task-%d\"</span>).build();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</p>\n<ul>\n<li>AbortPolicy：直接抛出异常。(默认)</li>\n<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>\n<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>\n<li>DiscardPolicy：不处理，丢弃掉。</li>\n</ul>\n</li>\n</ol>\n<p>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</p>\n<h3 id=\"向线程池提交任务\"><a href=\"#向线程池提交任务\" class=\"headerlink\" title=\"向线程池提交任务\"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p>\n<p>区别:</p>\n<ul>\n<li>execute()方法用于提交<strong>不需要返回值</strong>的任务;</li>\n<li>submit()方法用于提交<strong>需要返回值</strong>的任务。</li>\n</ul>\n<p>execute方法：</p>\n<p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadsPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>submit方法：</p>\n<p>线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方<br>法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future&lt;Object&gt; future = executor.submit(haveReturnValuetask);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\tObject s = future.get();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 处理中断异常</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 处理无法执行任务异常</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">\texecutor.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关闭线程池\"><a href=\"#关闭线程池\" class=\"headerlink\" title=\"关闭线程池\"></a>关闭线程池</h3><ul>\n<li>shutdown()</li>\n<li>shutdownNow()</li>\n</ul>\n<p>它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p>\n<p>区别：</p>\n<p>shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p>\n<p>总结：</p>\n<p>至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>\n<h3 id=\"线程池实例Demo\"><a href=\"#线程池实例Demo\" class=\"headerlink\" title=\"线程池实例Demo\"></a>线程池实例Demo</h3><ol>\n<li><p>首先构造一个线程池，用ArrayBlockingQueue作为其等待队列，队列初始化容量为1。该线程池核心容量为 10，最大容量为20，线程存活时间为1分钟。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> BlockingQueue blockingQueue=<span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">static</span> ThreadPoolExecutor threadPoolExecutor=<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">1</span>, TimeUnit.MINUTES, blockingQueue);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另外构造了一个实现Runable接口的类TaskBusyWithoutResult类，其模拟一个繁忙的任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskBusyWithoutResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskBusyWithoutResult</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"线程\"</span>+Thread.currentThread()+<span class=\"string\">\"开始运行\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">int</span> i=<span class=\"number\">10000</span>*<span class=\"number\">10000</span>;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(i&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           i--;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"线程\"</span>+Thread.currentThread()+<span class=\"string\">\"运行结束\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>向线程池提交20个任务，执行任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">        Runnable runnable = <span class=\"keyword\">new</span> TaskBusyWithoutResult();</span><br><span class=\"line\">        threadPoolExecutor.submit(runnable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"线程池源码分析\"><a href=\"#线程池源码分析\" class=\"headerlink\" title=\"线程池源码分析\"></a>线程池源码分析</h2><p><strong>基于JDK1.8</strong></p>\n<h3 id=\"ctl-变量\"><a href=\"#ctl-变量\" class=\"headerlink\" title=\"ctl 变量\"></a>ctl 变量</h3><p>后面execute方法会用到ctl，这个变量是为了把工作线程数量和线程池状态放在一个int型变量存储而设置的一个原子类型的变量。 在ctl中，低位的29位表示工作线程的数量，高位用来表示RUNNING、SHUTDOWN、STOP等状态。上面定义的三个方法只是为了计算得到线程池的状态和工作线程的数量，以及得到ctl。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Packing and unpacking ctl</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>     </span>&#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>  </span>&#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ctlOf</span><span class=\"params\">(<span class=\"keyword\">int</span> rs, <span class=\"keyword\">int</span> wc)</span> </span>&#123; <span class=\"keyword\">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"execute-方法\"><a href=\"#execute-方法\" class=\"headerlink\" title=\"execute()方法\"></a>execute()方法</h3><ul>\n<li>if (! isRunning(recheck) &amp;&amp; remove(command))这句。由于&amp;&amp;是短路与，意思就是前面如果非真，后面不会执行。所以如果线程池不是Running状态时，才把现成移出工作队列，再使用饱和策略。</li>\n<li>addWorker(command, false)：我们看到有addWorker(command, true)和addWorker(command, false)。true和false分别代表在检查工作线程数量的时候是应该与corePoolSize对比还是应该maximumPoolSize对比。只有第一个if时，也就是当前线程数小于corePoolSize时才用addWorker(command, true)。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//如果提交了空的任务 抛出异常</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">   <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\"> <span class=\"keyword\">int</span> c = ctl.get();<span class=\"comment\">//获取当前线程池的状态</span></span><br><span class=\"line\">   <span class=\"comment\">//检查当前工作线程数量是否小于核心线程数量</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">   <span class=\"comment\">//通过addWorker方法提交任务</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">     <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   c = ctl.get();<span class=\"comment\">//如果提交失败 需要二次检查状态</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//向工作线程提交任务 </span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 再次检查状态</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//扩容失败 则拒绝任务</span></span><br><span class=\"line\"> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">   reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"addWorker-方法\"><a href=\"#addWorker-方法\" class=\"headerlink\" title=\"addWorker()方法\"></a>addWorker()方法</h3><p>这个方法是任务提交的一个核心方法，在里面完成了状态检查、新建任务、执行任务等一系列动作，主要工作是在线程池中创建一个新的线程并执行。</p>\n<p>这个方法可以分为两个阶段来看，第一个阶段是判断是否有必要新增一个工作线程，如果有则利用CAS更新工作线程的数量；第二部分是将提交的任务封装成一个工作线程Worker然后加入到线程池的容器中，开始执行新提交的任务。这个Worker在执行完任务后，还会循环地获取工作队列里的任务来执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">       retry:</span><br><span class=\"line\">   <span class=\"comment\">//死循环更新状态</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">           <span class=\"keyword\">int</span> rs = runStateOf(c);<span class=\"comment\">//获取运行状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//检查线程池是否处于关闭状态</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">                  firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                  ! workQueue.isEmpty()))</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">           <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//获取当前工作线程数量</span></span><br><span class=\"line\">               <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">       <span class=\"comment\">//如果已经超过corePoolSize获取maximumPoolSize 返回false</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                   wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"comment\">//CAS增加一个工作线程</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">       <span class=\"comment\">//再次获取状态</span></span><br><span class=\"line\">               c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">       <span class=\"comment\">//如果状态更新失败 则循环更新</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                   <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">               <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           w = <span class=\"keyword\">new</span> Worker(firstTask);<span class=\"comment\">//初始化一个工作线程</span></span><br><span class=\"line\">           <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获得锁</span></span><br><span class=\"line\">               <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">               mainLock.lock();</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">// Recheck while holding lock.</span></span><br><span class=\"line\">                   <span class=\"comment\">// Back out on ThreadFactory failure or if</span></span><br><span class=\"line\">                   <span class=\"comment\">// shut down before lock acquired.</span></span><br><span class=\"line\">                   <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\"></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                       (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">           <span class=\"comment\">//添加工作这到hashset中保存</span></span><br><span class=\"line\">                       workers.add(w);</span><br><span class=\"line\">                       <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                           largestPoolSize = s;</span><br><span class=\"line\">                       workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                   mainLock.unlock();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">       <span class=\"comment\">//工作线程启动 执行第一个任务 就是新提交的任务</span></span><br><span class=\"line\">                   t.start();</span><br><span class=\"line\">                   workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">               addWorkerFailed(w);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Worker的构造方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates with given first task and thread from ThreadFactory.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> firstTask the first task (null if none)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">    setState(-<span class=\"number\">1</span>); <span class=\"comment\">// inhibit interrupts until runWorker</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"runWorker-方法\"><a href=\"#runWorker-方法\" class=\"headerlink\" title=\"runWorker()方法\"></a>runWorker()方法</h3><p>在addWorker方法快要结束的地方，调用了t.start()方法，我们知道它实际执行的就是Worker对象的run()方法，而worker的run()方法是这样定义的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Delegates main run loop to outer runWorker  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它实际上是将自己委托给线程池的runWorker方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">//不断地从blockingQueue获取任务</span></span><br><span class=\"line\">           <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               w.lock();</span><br><span class=\"line\">               <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class=\"line\">               <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></span><br><span class=\"line\">               <span class=\"comment\">// requires a recheck in second case to deal with</span></span><br><span class=\"line\">               <span class=\"comment\">// shutdownNow race while clearing interrupt</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                    (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                   !wt.isInterrupted())</span><br><span class=\"line\">                   wt.interrupt();</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//执行beforeExecute方法</span></span><br><span class=\"line\">                   beforeExecute(wt, task);</span><br><span class=\"line\">                   Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//调用Runable的run方法</span></span><br><span class=\"line\">                       task.run();</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                       thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                       thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                       thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 执行aferExecute方法</span></span><br><span class=\"line\">                       afterExecute(task, thrown);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                   task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                   w.completedTasks++;</span><br><span class=\"line\">                   w.unlock();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下runWorker方法的执行过程：</p>\n<ol>\n<li>while循环中，不断地通过getTask()方法从workerQueue中获取任务</li>\n<li>如果线程池正在停止，则中断线程。否则调用3.</li>\n<li>调用task.run()执行任务；</li>\n<li>如果task为null则跳出循环，执行processWorkerExit()方法，销毁线程workers.remove(w);</li>\n</ol>\n<p>它在不断执行我们提交的任务的run方法。而这个任务可能是我们新提交的，也有可能是从等待队列中获取的。这样就实现了线程池的完成逻辑。</p>\n<h2 id=\"ExecutorService\"><a href=\"#ExecutorService\" class=\"headerlink\" title=\"ExecutorService\"></a>ExecutorService</h2><p><strong>创建线程池的5个方法：</strong></p>\n<h3 id=\"newSingleThreadExecutor\"><a href=\"#newSingleThreadExecutor\" class=\"headerlink\" title=\"newSingleThreadExecutor\"></a>newSingleThreadExecutor</h3><p>只有一个线程的线程池，因此所有提交的任务是<strong>顺序执行</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n\n<p>构造方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</span><br><span class=\"line\">            (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。</p>\n<p>返回单线程的Executor，将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>\n<hr>\n<h3 id=\"newCachedThreadPool\"><a href=\"#newCachedThreadPool\" class=\"headerlink\" title=\"newCachedThreadPool\"></a>newCachedThreadPool</h3><p>缓存型线程池，先查看池中有没有以前建立的线程，如果有，就重用，如果没有，就建一个新的线程加入池中。如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n\n<p>构造方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>,<span class=\"comment\">//线程池维护线程的最少数量</span></span><br><span class=\"line\">                Integer.MAX_VALUE,<span class=\"comment\">//线程池维护线程的最大数量</span></span><br><span class=\"line\">                <span class=\"number\">60L</span>,<span class=\"comment\">//线程池维护线程所允许的空闲时间，60秒</span></span><br><span class=\"line\">                TimeUnit.SECONDS,<span class=\"comment\">//线程池维护线程所允许的空闲时间的单位</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ExecutorService exe= Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> taskID=i;</span><br><span class=\"line\">            exe.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;<span class=\"number\">4</span>;j++)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"线程ID：\"</span>+taskID+<span class=\"string\">\",执行第 \"</span>+j+<span class=\"string\">\" 次\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程ID：3，执行第 1 次</span><br><span class=\"line\">线程ID：4，执行第 1 次</span><br><span class=\"line\">线程ID：2，执行第 1 次</span><br><span class=\"line\">线程ID：5，执行第 1 次</span><br><span class=\"line\">线程ID：1，执行第 1 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：2，执行第 2 次</span><br><span class=\"line\">线程ID：3，执行第 2 次</span><br><span class=\"line\">线程ID：4，执行第 2 次</span><br><span class=\"line\">线程ID：1，执行第 2 次</span><br><span class=\"line\">线程ID：5，执行第 2 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：2，执行第 3 次</span><br><span class=\"line\">线程ID：3，执行第 3 次</span><br><span class=\"line\">线程ID：4，执行第 3 次</span><br><span class=\"line\">线程ID：5，执行第 3 次</span><br><span class=\"line\">线程ID：1，执行第 3 次</span><br></pre></td></tr></table></figure>\n\n<p>可以看到执行结果是5个任务在交替进行的</p>\n<p>newCachedThreadPool的总结：</p>\n<ol>\n<li>重用：缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。</li>\n<li>使用场景：缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。</li>\n<li>超时：能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。</li>\n<li>结束：注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。</li>\n</ol>\n<hr>\n<h3 id=\"newFixedThreadPool\"><a href=\"#newFixedThreadPool\" class=\"headerlink\" title=\"newFixedThreadPool\"></a>newFixedThreadPool</h3><p>定长线程池，可控制线程最大并发数。如果当前需要执行的任务超过池大小，那么多出的任务处于等待状态，直到有空闲下来的线程执行任务，如果当前需要执行的任务小于池大小，空闲的线程也不会去销毁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>构造方法源码：有两个重载方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(</span><br><span class=\"line\">                nThreads,<span class=\"comment\">//线程池维护线程的最少数量</span></span><br><span class=\"line\">                nThreads,<span class=\"comment\">//线程池维护线程的最大数量</span></span><br><span class=\"line\">                <span class=\"number\">0L</span>, <span class=\"comment\">//线程池维护线程所允许的空闲时间</span></span><br><span class=\"line\">                TimeUnit.MILLISECONDS,<span class=\"comment\">//线程池维护线程所允许的空闲时间的单位</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                      <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                      <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                      threadFactory);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService exe = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> taskID = i;</span><br><span class=\"line\">            exe.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; <span class=\"number\">4</span>; j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"线程ID：\"</span> + taskID + <span class=\"string\">\"，执行第 \"</span> + j + <span class=\"string\">\" 次\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程ID：2，执行第 1 次</span><br><span class=\"line\">线程ID：1，执行第 1 次</span><br><span class=\"line\">线程ID：3，执行第 1 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：2，执行第 2 次</span><br><span class=\"line\">线程ID：3，执行第 2 次</span><br><span class=\"line\">线程ID：1，执行第 2 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：2，执行第 3 次</span><br><span class=\"line\">线程ID：3，执行第 3 次</span><br><span class=\"line\">线程ID：1，执行第 3 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：4，执行第 1 次</span><br><span class=\"line\">线程ID：5，执行第 1 次</span><br><span class=\"line\">线程ID：4，执行第 2 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：5，执行第 2 次</span><br><span class=\"line\">线程ID：4，执行第 3 次</span><br><span class=\"line\">线程ID：5，执行第 3 次</span><br></pre></td></tr></table></figure>\n\n<p>创建了一个固定大小的线程池，容量为3，然后循环执行了5个任务。由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4,5个任务。<br>newFixedThreadPool的总结：</p>\n<ol>\n<li>重用：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。</li>\n<li>固定数目：其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。</li>\n<li>超时：和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的）。</li>\n<li>使用场景：所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。</li>\n</ol>\n<hr>\n<h3 id=\"newScheduledThreadPool\"><a href=\"#newScheduledThreadPool\" class=\"headerlink\" title=\"newScheduledThreadPool\"></a>newScheduledThreadPool</h3><p>调度型线程池,支持定时及周期性任务执行，也是一个固定长度的线程池。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ScheduledExecutorService exe= Executors.newScheduledThreadPool(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>构造方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduledThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(corePoolSize, <span class=\"comment\">// 线程池维护线程的最少数量</span></span><br><span class=\"line\">        Integer.MAX_VALUE, <span class=\"comment\">//线程池维护线程的最大数量</span></span><br><span class=\"line\">        <span class=\"number\">0</span>, <span class=\"comment\">// 线程池维护线程所允许的空闲时间</span></span><br><span class=\"line\">        NANOSECONDS,<span class=\"comment\">//线程池维护线程所允许的空闲时间的单位</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> DelayedWorkQueue());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ScheduledExecutorService exe= Executors.newScheduledThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> taskID=i;</span><br><span class=\"line\">                exe.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"线程：\"</span>+taskID+<span class=\"string\">\",时间：\"</span>+ LocalDateTime.now()+<span class=\"string\">\" 执行一次\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;, <span class=\"number\">0</span>, <span class=\"number\">2</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码scheduleAtFixedRate后面的参数 0 表示立即执行，2表示2秒执行一次调度。执行结果：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程：1,时间：2016-12-11T13:09:18.544 执行一次</span><br><span class=\"line\">线程：2,时间：2016-12-11T13:09:18.544 执行一次</span><br><span class=\"line\">线程：3,时间：2016-12-11T13:09:18.544 执行一次</span><br><span class=\"line\"></span><br><span class=\"line\">线程：5,时间：2016-12-11T13:09:20.557 执行一次</span><br><span class=\"line\">线程：1,时间：2016-12-11T13:09:20.557 执行一次</span><br><span class=\"line\">线程：4,时间：2016-12-11T13:09:20.557 执行一次</span><br><span class=\"line\"></span><br><span class=\"line\">线程：4,时间：2016-12-11T13:09:22.572 执行一次</span><br><span class=\"line\">线程：2,时间：2016-12-11T13:09:22.572 执行一次</span><br><span class=\"line\">线程：3,时间：2016-12-11T13:09:22.572 执行一次</span><br><span class=\"line\"></span><br><span class=\"line\">线程：5,时间：2016-12-11T13:09:24.586 执行一次</span><br><span class=\"line\">线程：1,时间：2016-12-11T13:09:24.586 执行一次</span><br><span class=\"line\">线程：2,时间：2016-12-11T13:09:24.586 执行一次</span><br></pre></td></tr></table></figure>\n\n<p>newScheduledThreadPool的线程池大小只设置了3，所以一次只能执行3个线程，然后可以看到每2秒执行一次任务调度。</p>\n<hr>\n<h3 id=\"newSingleThreadScheduledPool\"><a href=\"#newSingleThreadScheduledPool\" class=\"headerlink\" title=\"newSingleThreadScheduledPool\"></a>newSingleThreadScheduledPool</h3><p>单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exe= Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n\n<p>构造方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</span><br><span class=\"line\">            (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ExecutorService exe= Executors.newSingleThreadExecutor();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> taskID=i;</span><br><span class=\"line\">            exe.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;<span class=\"number\">4</span>;j++)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"线程ID：\"</span>+taskID+<span class=\"string\">\"，执行第 \"</span>+j+<span class=\"string\">\" 次\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程ID：1，执行第 1 次</span><br><span class=\"line\">线程ID：1，执行第 2 次</span><br><span class=\"line\">线程ID：1，执行第 3 次</span><br><span class=\"line\">线程ID：2，执行第 1 次</span><br><span class=\"line\">线程ID：2，执行第 2 次</span><br><span class=\"line\">线程ID：2，执行第 3 次</span><br><span class=\"line\">线程ID：3，执行第 1 次</span><br><span class=\"line\">线程ID：3，执行第 2 次</span><br><span class=\"line\">线程ID：3，执行第 3 次</span><br><span class=\"line\">线程ID：4，执行第 1 次</span><br><span class=\"line\">线程ID：4，执行第 2 次</span><br><span class=\"line\">线程ID：4，执行第 3 次</span><br><span class=\"line\">线程ID：5，执行第 1 次</span><br><span class=\"line\">线程ID：5，执行第 2 次</span><br><span class=\"line\">线程ID：5，执行第 3 次</span><br></pre></td></tr></table></figure>\n\n<p>每个结果都是相隔0.5秒打印出来的，顺序执行下去。</p>\n<ul>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"线程池原理\"><a href=\"#线程池原理\" class=\"headerlink\" title=\"线程池原理\"></a>线程池原理</h2><h3 id=\"使用线程池的好处\"><a href=\"#使用线程池的好处\" class=\"headerlink\" title=\"使用线程池的好处\"></a>使用线程池的好处</h3><ol>\n<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>\n<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>\n</ol>\n<h3 id=\"线程池的实现原理\"><a href=\"#线程池的实现原理\" class=\"headerlink\" title=\"线程池的实现原理\"></a>线程池的实现原理</h3><ol>\n<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>\n<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>\n<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。","more":"</li>\n</ol>\n<p>对应到代码层面就是<code>ThreadPoolExecutor</code>执行<code>execute()</code>方法</p>\n<ol>\n<li>当<kbd>workerCount</kbd> &lt; <kbd>corePoolSize</kbd>，创建新线程执行任务。</li>\n<li>当<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且阻塞队列workQueue未满，把新的任务放入阻塞队列。</li>\n<li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且<kbd>workerCount</kbd> &lt; <kbd>maximumPoolSize</kbd>，创建新线程执行任务。</li>\n<li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>maximumPoolSize</kbd>，采取拒绝策略,根据不同的拒绝策略处理,默认拒绝策略是直接抛异常。</li>\n</ol>\n<p>由于创建新线程时（第1步、第3步）需要获取全局锁，所以ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。</p>\n<h3 id=\"线程池状态转换模型\"><a href=\"#线程池状态转换模型\" class=\"headerlink\" title=\"线程池状态转换模型\"></a>线程池状态转换模型</h3><p><img src=\"https://tva1.sinaimg.cn/large/006tNbRwgy1gb1qb2e8lbj31lo0jiu0x.jpg\" alt></p>\n<ul>\n<li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li>\n<li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li>\n<li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>\n<li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li>\n<li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li>\n</ul>\n<h2 id=\"线程池的使用\"><a href=\"#线程池的使用\" class=\"headerlink\" title=\"线程池的使用\"></a>线程池的使用</h2><h3 id=\"创建线程池\"><a href=\"#创建线程池\" class=\"headerlink\" title=\"创建线程池\"></a>创建线程池</h3><p>我们可以通过ThreadPoolExecutor的<strong>构造方法</strong>来创建线程池</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   <span class=\"keyword\">int</span> maximumPoolSize,                              </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">      <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">   RejectedExecutionHandler handler)</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>下面介绍一下代码中的参数：</p>\n<ol>\n<li><p>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，如果当前poolSize&lt;corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p>\n</li>\n<li><p>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p>\n</li>\n<li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p>\n</li>\n<li><p>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p>\n</li>\n<li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p>\n<ul>\n<li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</p>\n</li>\n<li><p>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</p>\n</li>\n<li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p>\n</li>\n<li><p>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p>\n</li>\n</ul>\n</li>\n<li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线<br>程设置有意义的名字，代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> ThreadFactoryBuilder().setNameFormat(<span class=\"string\">\"XX-task-%d\"</span>).build();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</p>\n<ul>\n<li>AbortPolicy：直接抛出异常。(默认)</li>\n<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>\n<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>\n<li>DiscardPolicy：不处理，丢弃掉。</li>\n</ul>\n</li>\n</ol>\n<p>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</p>\n<h3 id=\"向线程池提交任务\"><a href=\"#向线程池提交任务\" class=\"headerlink\" title=\"向线程池提交任务\"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p>\n<p>区别:</p>\n<ul>\n<li>execute()方法用于提交<strong>不需要返回值</strong>的任务;</li>\n<li>submit()方法用于提交<strong>需要返回值</strong>的任务。</li>\n</ul>\n<p>execute方法：</p>\n<p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">threadsPool.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  \t<span class=\"comment\">// TODO Auto-generated method stub</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>submit方法：</p>\n<p>线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方<br>法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Future&lt;Object&gt; future = executor.submit(haveReturnValuetask);</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\tObject s = future.get();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 处理中断异常</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (ExecutionException e) &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 处理无法执行任务异常</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 关闭线程池</span></span><br><span class=\"line\">\texecutor.shutdown();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"关闭线程池\"><a href=\"#关闭线程池\" class=\"headerlink\" title=\"关闭线程池\"></a>关闭线程池</h3><ul>\n<li>shutdown()</li>\n<li>shutdownNow()</li>\n</ul>\n<p>它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p>\n<p>区别：</p>\n<p>shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p>\n<p>总结：</p>\n<p>至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p>\n<h3 id=\"线程池实例Demo\"><a href=\"#线程池实例Demo\" class=\"headerlink\" title=\"线程池实例Demo\"></a>线程池实例Demo</h3><ol>\n<li><p>首先构造一个线程池，用ArrayBlockingQueue作为其等待队列，队列初始化容量为1。该线程池核心容量为 10，最大容量为20，线程存活时间为1分钟。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> BlockingQueue blockingQueue=<span class=\"keyword\">new</span> ArrayBlockingQueue&lt;&gt;(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">static</span> ThreadPoolExecutor threadPoolExecutor=<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">1</span>, TimeUnit.MINUTES, blockingQueue);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>另外构造了一个实现Runable接口的类TaskBusyWithoutResult类，其模拟一个繁忙的任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskBusyWithoutResult</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TaskBusyWithoutResult</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\">   </span>&#123;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"线程\"</span>+Thread.currentThread()+<span class=\"string\">\"开始运行\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">int</span> i=<span class=\"number\">10000</span>*<span class=\"number\">10000</span>;</span><br><span class=\"line\">       <span class=\"keyword\">while</span>(i&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">       &#123;</span><br><span class=\"line\">           i--;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       System.out.println(<span class=\"string\">\"线程\"</span>+Thread.currentThread()+<span class=\"string\">\"运行结束\"</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>向线程池提交20个任务，执行任务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">20</span>; i++) &#123;</span><br><span class=\"line\">        Runnable runnable = <span class=\"keyword\">new</span> TaskBusyWithoutResult();</span><br><span class=\"line\">        threadPoolExecutor.submit(runnable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"线程池源码分析\"><a href=\"#线程池源码分析\" class=\"headerlink\" title=\"线程池源码分析\"></a>线程池源码分析</h2><p><strong>基于JDK1.8</strong></p>\n<h3 id=\"ctl-变量\"><a href=\"#ctl-变量\" class=\"headerlink\" title=\"ctl 变量\"></a>ctl 变量</h3><p>后面execute方法会用到ctl，这个变量是为了把工作线程数量和线程池状态放在一个int型变量存储而设置的一个原子类型的变量。 在ctl中，低位的29位表示工作线程的数量，高位用来表示RUNNING、SHUTDOWN、STOP等状态。上面定义的三个方法只是为了计算得到线程池的状态和工作线程的数量，以及得到ctl。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// Packing and unpacking ctl</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>     </span>&#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>  </span>&#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ctlOf</span><span class=\"params\">(<span class=\"keyword\">int</span> rs, <span class=\"keyword\">int</span> wc)</span> </span>&#123; <span class=\"keyword\">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"execute-方法\"><a href=\"#execute-方法\" class=\"headerlink\" title=\"execute()方法\"></a>execute()方法</h3><ul>\n<li>if (! isRunning(recheck) &amp;&amp; remove(command))这句。由于&amp;&amp;是短路与，意思就是前面如果非真，后面不会执行。所以如果线程池不是Running状态时，才把现成移出工作队列，再使用饱和策略。</li>\n<li>addWorker(command, false)：我们看到有addWorker(command, true)和addWorker(command, false)。true和false分别代表在检查工作线程数量的时候是应该与corePoolSize对比还是应该maximumPoolSize对比。只有第一个if时，也就是当前线程数小于corePoolSize时才用addWorker(command, true)。</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//如果提交了空的任务 抛出异常</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">   <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\"> <span class=\"keyword\">int</span> c = ctl.get();<span class=\"comment\">//获取当前线程池的状态</span></span><br><span class=\"line\">   <span class=\"comment\">//检查当前工作线程数量是否小于核心线程数量</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">   <span class=\"comment\">//通过addWorker方法提交任务</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">     <span class=\"keyword\">return</span>;</span><br><span class=\"line\">   c = ctl.get();<span class=\"comment\">//如果提交失败 需要二次检查状态</span></span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//向工作线程提交任务 </span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">   <span class=\"comment\">// 再次检查状态</span></span><br><span class=\"line\">      <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">      </span><br><span class=\"line\">      <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"comment\">//扩容失败 则拒绝任务</span></span><br><span class=\"line\"> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">   reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"addWorker-方法\"><a href=\"#addWorker-方法\" class=\"headerlink\" title=\"addWorker()方法\"></a>addWorker()方法</h3><p>这个方法是任务提交的一个核心方法，在里面完成了状态检查、新建任务、执行任务等一系列动作，主要工作是在线程池中创建一个新的线程并执行。</p>\n<p>这个方法可以分为两个阶段来看，第一个阶段是判断是否有必要新增一个工作线程，如果有则利用CAS更新工作线程的数量；第二部分是将提交的任务封装成一个工作线程Worker然后加入到线程池的容器中，开始执行新提交的任务。这个Worker在执行完任务后，还会循环地获取工作队列里的任务来执行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">       retry:</span><br><span class=\"line\">   <span class=\"comment\">//死循环更新状态</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">           <span class=\"keyword\">int</span> rs = runStateOf(c);<span class=\"comment\">//获取运行状态</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//检查线程池是否处于关闭状态</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">                  firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">                  ! workQueue.isEmpty()))</span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">   </span><br><span class=\"line\">           <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//获取当前工作线程数量</span></span><br><span class=\"line\">               <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">       <span class=\"comment\">//如果已经超过corePoolSize获取maximumPoolSize 返回false</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                   wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"comment\">//CAS增加一个工作线程</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">       <span class=\"comment\">//再次获取状态</span></span><br><span class=\"line\">               c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">       <span class=\"comment\">//如果状态更新失败 则循环更新</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                   <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">               <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           w = <span class=\"keyword\">new</span> Worker(firstTask);<span class=\"comment\">//初始化一个工作线程</span></span><br><span class=\"line\">           <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//获得锁</span></span><br><span class=\"line\">               <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">               mainLock.lock();</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                   <span class=\"comment\">// Recheck while holding lock.</span></span><br><span class=\"line\">                   <span class=\"comment\">// Back out on ThreadFactory failure or if</span></span><br><span class=\"line\">                   <span class=\"comment\">// shut down before lock acquired.</span></span><br><span class=\"line\">                   <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\"></span><br><span class=\"line\">                   <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                       (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                           <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">           <span class=\"comment\">//添加工作这到hashset中保存</span></span><br><span class=\"line\">                       workers.add(w);</span><br><span class=\"line\">                       <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                       <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                           largestPoolSize = s;</span><br><span class=\"line\">                       workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                   mainLock.unlock();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">       <span class=\"comment\">//工作线程启动 执行第一个任务 就是新提交的任务</span></span><br><span class=\"line\">                   t.start();</span><br><span class=\"line\">                   workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">               addWorkerFailed(w);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Worker的构造方法如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Creates with given first task and thread from ThreadFactory.</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> firstTask the first task (null if none)</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">    setState(-<span class=\"number\">1</span>); <span class=\"comment\">// inhibit interrupts until runWorker</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"runWorker-方法\"><a href=\"#runWorker-方法\" class=\"headerlink\" title=\"runWorker()方法\"></a>runWorker()方法</h3><p>在addWorker方法快要结束的地方，调用了t.start()方法，我们知道它实际执行的就是Worker对象的run()方法，而worker的run()方法是这样定义的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** Delegates main run loop to outer runWorker  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>它实际上是将自己委托给线程池的runWorker方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">       </span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">       <span class=\"comment\">//不断地从blockingQueue获取任务</span></span><br><span class=\"line\">           <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">               w.lock();</span><br><span class=\"line\">               <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class=\"line\">               <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></span><br><span class=\"line\">               <span class=\"comment\">// requires a recheck in second case to deal with</span></span><br><span class=\"line\">               <span class=\"comment\">// shutdownNow race while clearing interrupt</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                    (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                   !wt.isInterrupted())</span><br><span class=\"line\">                   wt.interrupt();</span><br><span class=\"line\">               <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//执行beforeExecute方法</span></span><br><span class=\"line\">                   beforeExecute(wt, task);</span><br><span class=\"line\">                   Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//调用Runable的run方法</span></span><br><span class=\"line\">                       task.run();</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                       thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                       thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                       thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                   &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">// 执行aferExecute方法</span></span><br><span class=\"line\">                       afterExecute(task, thrown);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                   task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                   w.completedTasks++;</span><br><span class=\"line\">                   w.unlock();</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">       &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">           processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>总结一下runWorker方法的执行过程：</p>\n<ol>\n<li>while循环中，不断地通过getTask()方法从workerQueue中获取任务</li>\n<li>如果线程池正在停止，则中断线程。否则调用3.</li>\n<li>调用task.run()执行任务；</li>\n<li>如果task为null则跳出循环，执行processWorkerExit()方法，销毁线程workers.remove(w);</li>\n</ol>\n<p>它在不断执行我们提交的任务的run方法。而这个任务可能是我们新提交的，也有可能是从等待队列中获取的。这样就实现了线程池的完成逻辑。</p>\n<h2 id=\"ExecutorService\"><a href=\"#ExecutorService\" class=\"headerlink\" title=\"ExecutorService\"></a>ExecutorService</h2><p><strong>创建线程池的5个方法：</strong></p>\n<h3 id=\"newSingleThreadExecutor\"><a href=\"#newSingleThreadExecutor\" class=\"headerlink\" title=\"newSingleThreadExecutor\"></a>newSingleThreadExecutor</h3><p>只有一个线程的线程池，因此所有提交的任务是<strong>顺序执行</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n\n<p>构造方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</span><br><span class=\"line\">            (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。</p>\n<p>返回单线程的Executor，将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>\n<hr>\n<h3 id=\"newCachedThreadPool\"><a href=\"#newCachedThreadPool\" class=\"headerlink\" title=\"newCachedThreadPool\"></a>newCachedThreadPool</h3><p>缓存型线程池，先查看池中有没有以前建立的线程，如果有，就重用，如果没有，就建一个新的线程加入池中。如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService executorService = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure>\n\n<p>构造方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>,<span class=\"comment\">//线程池维护线程的最少数量</span></span><br><span class=\"line\">                Integer.MAX_VALUE,<span class=\"comment\">//线程池维护线程的最大数量</span></span><br><span class=\"line\">                <span class=\"number\">60L</span>,<span class=\"comment\">//线程池维护线程所允许的空闲时间，60秒</span></span><br><span class=\"line\">                TimeUnit.SECONDS,<span class=\"comment\">//线程池维护线程所允许的空闲时间的单位</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ExecutorService exe= Executors.newCachedThreadPool();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> taskID=i;</span><br><span class=\"line\">            exe.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;<span class=\"number\">4</span>;j++)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"线程ID：\"</span>+taskID+<span class=\"string\">\",执行第 \"</span>+j+<span class=\"string\">\" 次\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程ID：3，执行第 1 次</span><br><span class=\"line\">线程ID：4，执行第 1 次</span><br><span class=\"line\">线程ID：2，执行第 1 次</span><br><span class=\"line\">线程ID：5，执行第 1 次</span><br><span class=\"line\">线程ID：1，执行第 1 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：2，执行第 2 次</span><br><span class=\"line\">线程ID：3，执行第 2 次</span><br><span class=\"line\">线程ID：4，执行第 2 次</span><br><span class=\"line\">线程ID：1，执行第 2 次</span><br><span class=\"line\">线程ID：5，执行第 2 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：2，执行第 3 次</span><br><span class=\"line\">线程ID：3，执行第 3 次</span><br><span class=\"line\">线程ID：4，执行第 3 次</span><br><span class=\"line\">线程ID：5，执行第 3 次</span><br><span class=\"line\">线程ID：1，执行第 3 次</span><br></pre></td></tr></table></figure>\n\n<p>可以看到执行结果是5个任务在交替进行的</p>\n<p>newCachedThreadPool的总结：</p>\n<ol>\n<li>重用：缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。</li>\n<li>使用场景：缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。</li>\n<li>超时：能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。</li>\n<li>结束：注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。</li>\n</ol>\n<hr>\n<h3 id=\"newFixedThreadPool\"><a href=\"#newFixedThreadPool\" class=\"headerlink\" title=\"newFixedThreadPool\"></a>newFixedThreadPool</h3><p>定长线程池，可控制线程最大并发数。如果当前需要执行的任务超过池大小，那么多出的任务处于等待状态，直到有空闲下来的线程执行任务，如果当前需要执行的任务小于池大小，空闲的线程也不会去销毁。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>构造方法源码：有两个重载方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(</span><br><span class=\"line\">                nThreads,<span class=\"comment\">//线程池维护线程的最少数量</span></span><br><span class=\"line\">                nThreads,<span class=\"comment\">//线程池维护线程的最大数量</span></span><br><span class=\"line\">                <span class=\"number\">0L</span>, <span class=\"comment\">//线程池维护线程所允许的空闲时间</span></span><br><span class=\"line\">                TimeUnit.MILLISECONDS,<span class=\"comment\">//线程池维护线程所允许的空闲时间的单位</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newFixedThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class=\"line\">                                      <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                      <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class=\"line\">                                      threadFactory);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        ExecutorService exe = Executors.newFixedThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"number\">6</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> taskID = i;</span><br><span class=\"line\">            exe.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; <span class=\"number\">4</span>; j++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"线程ID：\"</span> + taskID + <span class=\"string\">\"，执行第 \"</span> + j + <span class=\"string\">\" 次\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程ID：2，执行第 1 次</span><br><span class=\"line\">线程ID：1，执行第 1 次</span><br><span class=\"line\">线程ID：3，执行第 1 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：2，执行第 2 次</span><br><span class=\"line\">线程ID：3，执行第 2 次</span><br><span class=\"line\">线程ID：1，执行第 2 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：2，执行第 3 次</span><br><span class=\"line\">线程ID：3，执行第 3 次</span><br><span class=\"line\">线程ID：1，执行第 3 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：4，执行第 1 次</span><br><span class=\"line\">线程ID：5，执行第 1 次</span><br><span class=\"line\">线程ID：4，执行第 2 次</span><br><span class=\"line\"></span><br><span class=\"line\">线程ID：5，执行第 2 次</span><br><span class=\"line\">线程ID：4，执行第 3 次</span><br><span class=\"line\">线程ID：5，执行第 3 次</span><br></pre></td></tr></table></figure>\n\n<p>创建了一个固定大小的线程池，容量为3，然后循环执行了5个任务。由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4,5个任务。<br>newFixedThreadPool的总结：</p>\n<ol>\n<li>重用：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。</li>\n<li>固定数目：其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。</li>\n<li>超时：和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的）。</li>\n<li>使用场景：所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。</li>\n</ol>\n<hr>\n<h3 id=\"newScheduledThreadPool\"><a href=\"#newScheduledThreadPool\" class=\"headerlink\" title=\"newScheduledThreadPool\"></a>newScheduledThreadPool</h3><p>调度型线程池,支持定时及周期性任务执行，也是一个固定长度的线程池。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ScheduledExecutorService exe= Executors.newScheduledThreadPool(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<p>构造方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ScheduledThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(corePoolSize, <span class=\"comment\">// 线程池维护线程的最少数量</span></span><br><span class=\"line\">        Integer.MAX_VALUE, <span class=\"comment\">//线程池维护线程的最大数量</span></span><br><span class=\"line\">        <span class=\"number\">0</span>, <span class=\"comment\">// 线程池维护线程所允许的空闲时间</span></span><br><span class=\"line\">        NANOSECONDS,<span class=\"comment\">//线程池维护线程所允许的空闲时间的单位</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> DelayedWorkQueue());</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ScheduledExecutorService exe= Executors.newScheduledThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> taskID=i;</span><br><span class=\"line\">                exe.scheduleAtFixedRate(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            Thread.sleep(<span class=\"number\">2000</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"线程：\"</span>+taskID+<span class=\"string\">\",时间：\"</span>+ LocalDateTime.now()+<span class=\"string\">\" 执行一次\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;, <span class=\"number\">0</span>, <span class=\"number\">2</span>, TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码scheduleAtFixedRate后面的参数 0 表示立即执行，2表示2秒执行一次调度。执行结果：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程：1,时间：2016-12-11T13:09:18.544 执行一次</span><br><span class=\"line\">线程：2,时间：2016-12-11T13:09:18.544 执行一次</span><br><span class=\"line\">线程：3,时间：2016-12-11T13:09:18.544 执行一次</span><br><span class=\"line\"></span><br><span class=\"line\">线程：5,时间：2016-12-11T13:09:20.557 执行一次</span><br><span class=\"line\">线程：1,时间：2016-12-11T13:09:20.557 执行一次</span><br><span class=\"line\">线程：4,时间：2016-12-11T13:09:20.557 执行一次</span><br><span class=\"line\"></span><br><span class=\"line\">线程：4,时间：2016-12-11T13:09:22.572 执行一次</span><br><span class=\"line\">线程：2,时间：2016-12-11T13:09:22.572 执行一次</span><br><span class=\"line\">线程：3,时间：2016-12-11T13:09:22.572 执行一次</span><br><span class=\"line\"></span><br><span class=\"line\">线程：5,时间：2016-12-11T13:09:24.586 执行一次</span><br><span class=\"line\">线程：1,时间：2016-12-11T13:09:24.586 执行一次</span><br><span class=\"line\">线程：2,时间：2016-12-11T13:09:24.586 执行一次</span><br></pre></td></tr></table></figure>\n\n<p>newScheduledThreadPool的线程池大小只设置了3，所以一次只能执行3个线程，然后可以看到每2秒执行一次任务调度。</p>\n<hr>\n<h3 id=\"newSingleThreadScheduledPool\"><a href=\"#newSingleThreadScheduledPool\" class=\"headerlink\" title=\"newSingleThreadScheduledPool\"></a>newSingleThreadScheduledPool</h3><p>单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExecutorService exe= Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure>\n\n<p>构造方法源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newSingleThreadExecutor</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> FinalizableDelegatedExecutorService</span><br><span class=\"line\">            (<span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                    <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                    <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>实例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        ExecutorService exe= Executors.newSingleThreadExecutor();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;<span class=\"number\">6</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> taskID=i;</span><br><span class=\"line\">            exe.execute(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;<span class=\"number\">4</span>;j++)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                            Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                            e.printStackTrace();</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        System.out.println(<span class=\"string\">\"线程ID：\"</span>+taskID+<span class=\"string\">\"，执行第 \"</span>+j+<span class=\"string\">\" 次\"</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<p>执行结果</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程ID：1，执行第 1 次</span><br><span class=\"line\">线程ID：1，执行第 2 次</span><br><span class=\"line\">线程ID：1，执行第 3 次</span><br><span class=\"line\">线程ID：2，执行第 1 次</span><br><span class=\"line\">线程ID：2，执行第 2 次</span><br><span class=\"line\">线程ID：2，执行第 3 次</span><br><span class=\"line\">线程ID：3，执行第 1 次</span><br><span class=\"line\">线程ID：3，执行第 2 次</span><br><span class=\"line\">线程ID：3，执行第 3 次</span><br><span class=\"line\">线程ID：4，执行第 1 次</span><br><span class=\"line\">线程ID：4，执行第 2 次</span><br><span class=\"line\">线程ID：4，执行第 3 次</span><br><span class=\"line\">线程ID：5，执行第 1 次</span><br><span class=\"line\">线程ID：5，执行第 2 次</span><br><span class=\"line\">线程ID：5，执行第 3 次</span><br></pre></td></tr></table></figure>\n\n<p>每个结果都是相隔0.5秒打印出来的，顺序执行下去。</p>\n<ul>\n<li></li>\n</ul>"},{"title":"分布式缓存-Redis","date":"2019-03-12T15:46:44.000Z","top_img":"https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg","_content":"\n## redis单线程模型原理剖析？\n\nredis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。\n\n## redis为什么这么快？\n\n1. 纯内存操作。\n2. 核心是基于非阻塞的IO多路复用机制。\n3. 单线程——避免了多线程的频繁上下文切换问题。\n4. Resp协议。<!--more-->\n\n## 使用redis有什么缺点？\n\n- 缓存和数据库双写一致性问题\n- 缓存雪崩、缓存击穿\n- 缓存的并发竞争\n\n## redis支持的数据类型和使用场景\n\n1. string\n\n   最基本的类型，普通的set和get，做简单的key-value缓存。\n\n2. hash\n\n   类似map的一种结构，特别适合用存储对象，可以仅仅修改这个对象中的某个字段。\n\n3. list\n\n   有序列表，这个是可以玩出很多花样的：\n\n   比如可以基于redis的list实现简单的高性能分页，类似于微博的那种一直下拉。\n\n   还可以搞个简单的消息队列，从list头进去，从list尾巴取出来。\n\n4. set\n\n   无序集合，自动去重。\n\n   如果某个系统部署在多台机器上，可以基于redis实现全局的set去重。\n\n   还可以基于set玩交集，并集，差集的操作，比如利用交集，可以查看两个人的粉丝列表中的共同好友。\n\n5. sorted set\n\n   有序集合，自动去重。\n\n   这个也可以玩很多花样，写数据进去的时候给一个分数，自动根据分数排序，可以自定义排序规则。\n\n   比如想根据数据的时间排序，那么在写入数据的时候把时间作为分数，这样就会按时间排序了。\n\n   排行榜：将每个用户以及对应的分数写入进去，会自动排序，可以查看前几名的结果。\n\n   zadd board 85 jack\n\n   zadd board 72 tom\n\n   zadd board 96 jerry\n\n   zrevrange board 0 2：可以查看前三名的排序结果\n\n   zrank board tom：返回3，意思是tom排名第3\n\n------\n\n## redis的过期策略有哪些\n\n**定期删除+惰性删除**\n\n所谓**定期删除**，指的是redis默认每隔100ms就随机抽取一些过期时间的key，检测是否过期，如果过期就删除。注意：这里redis不是遍历所有过期的key（CPU负载太高），而是随机抽取。\n\n所谓**惰性删除**，指的是定期删除可能会导致很多过期的key到了时间也没被删除，所以在获取某个key的时候，redis会查一下这个key是否过期，如果过期了此时就会删除，不会返回结果。\n\n产生问题：如果定期删除漏掉了很多过期key没删，惰性删除是用到的时候才删，如果过期了并且一直没用到就会导致有大量的过期key堆积，这时候就需要走**内存淘汰机制**了。\n\n1. no-enviction（驱逐）：禁止驱逐数据，再写入会报错。**（默认，应该没人用）**\n2. allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。**（推荐使用）**\n3. allkeys-random：从数据集中任意选择数据淘汰。\n4. volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。\n5. volatile-ttl：从`已设置过期时间的`数据集中挑选`将要过期的`数据淘汰。\n6. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。\n\n------\n\n## 怎么保证redis的高并发&高可用？\n\nredis高并发：采用**主从架构**，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒上10万的QPS。如果redis高并发的同时还需要容纳大量的数据：几十G甚至几百G的数据，这样的话就需要采用redis集群了，还能提供每秒几十万的读写并发。\n\nredis高可用：如果做主从架构部署，其实加上**哨兵**就可以了，任何一个实例宕机，都会自动切换。\n\n### redis的主从复制\n\n主从架构 -> 读写分离 -> 水平扩容支撑10+的**读QPS**\n\n首先考虑读写分离，做成主从架构，一主多从，主负责写，并且将数据同步到其他slave节点，从节点负责读，所有的读请求都走从节点。好处是可以水平扩容，就是说如果QPS再增加，只需要继续增加slave就可以了。 \n\n#### 主从复制的核心原理\n\n当启动一个slave的时候，该节点会发送一个PSYNC命令给master，如果这是slave的重新连接，master仅仅会发送给slave部分缺少的数据进行**增量复制**，如果这是slave第一次连接master，会触发一次**全量复制**。\n\n官方解释：\n\n1. slave启动时，仅仅保存master的host和ip（redis.conf中配置的），此时复制流程还没开始。\n2. slave内部有个定时任务，每秒都会check是否有新的master要连接和复制，如果发现则建立网络连接。\n3. slave发送ping给master，如果master配置了requirepass，那么slave必须发送masterauth口令过去认证。\n4. master第一次执行全量复制，将所有数据发送给slave。\n5. master后续还会持续将写命令异步发送给slave。\n\n全量复制：开始full resynchronized的时候，master会启动一个后台线程，生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕以后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送给slave，slave来同步这些数据。\n\n增量复制：master根据slave发送的psync中的offset，在backlog中查找到部分丢失的数据，发送给slave。\n\n#### 主从复制的断点续传\n\n从redis2.8开始就支持主从复制的断点续传了。在主从复制过程中，如果网络连接断掉了，可以接着上次复制的地方继续复制，而不是重新开始复制。master会在内存中维护一个backlog，master和slave都会保存一个复制数据的replica offset和一个master run id，offset就是保存在backlog中的。如果master和slave网络中断了，slave会让master从上次的replica offset开始继续复制。但是如果没有找到对应的offset，那么就会执行一次resynchronized。\n\n官方解释：\n\n1. master和slave都会维护一个offset，slave每秒都会上报自己的offect给master，master记录在backlog中，这样才能知道双方数据是否一致。\n2. master还会维护一个backlog文件，默认是1M大小，给slave复制数据时也会记录在backlog中，主要是用来做全量复制中断后的增量复制的。\n3. master重启或者加载了之前的RDB数据是会变的，run id也会变，所以slave需要根据不同的run id区分，如果run id不同就需要做全量复制。\n4. 从节点使用psync从master进行复制，发送psync runid offset到master。master会根据自身的情况返回相应的信息，可能是FULLRESYNC runid offset触发全量复制，也可能是CONTINUE触发增量复制。\n\n#### 无磁盘化复制\n\n在redis的配置文件中开启无磁盘化复制以后，master会在内存中直接创建rdb文件然后发送给slave，不会保存在本地磁盘。这里不建议开启，开启也很简单，主要涉及到两个参数：repl-diskless-sync no 默认是no，改成yes就可以了，repl-diskless-sync-delay 5 默认是延迟5s在开始复制，因为需要等待更多的slave重新连接。\n\n#### 过期key处理\n\nslave不会过期key，只会等待master过期key。\n\n如果master过期了一个key，或者通过LRU淘汰了一个key，master会模拟一条del命令发送给slave。\n\n#### redis的心跳检测机制\n\n在命令传播阶段，slave每隔一秒向master发送一个心跳，主要用来检测双方的网络连接状态。\n\n#### redis的持久化\n\n如果采用了主从架构，建议必须开启master node的持久化。\n\n不建议用slave node作为master node的热备，因为那样的话如果关掉master的持久化（RDB和AOF都关闭）可能在master宕机重启的时候数据是空的，然后从节点一复制，slave node的数据也丢了。\n\n即使slave node可以自动接管master node，也可能哨兵还没有检测到master failure，master node就重启了，还是可能导致上面的所有slave node数据被清空的故障。\n\n**持久化方式RDB和AOF**\n\n- RDB持久化机制：通过快照的方式，对redis中的数据进行周期性的持久化。\n- AOF持久化机制：通过记录写命令，以append-only模式写入到日志文件中，redis重启时重新构建。\n\n如果同时开启了RDB和AOF两种持久化机制，在redis重启时会使用AOF来构建数据，因为AOF数据更加完整。\n\n如果我们想要redis仅仅作为纯内存的缓存来用，可以关掉RDB和AOF持久化机制。\n\n**RDB的优点**\n\n1. RDB会生成多个数据文件，非常适合做冷备，可以上传到云盘定期维护。\n2. RDB对redis的性能影响非常小，定期把数据写入到磁盘，使redis保持高性能。\n3. 通过RDB数据文件来做数据恢复更加快速，直接把文件加载到内存即可。\n\n**RDB的缺点**\n\n1. 最大的缺点就是可能造成部分数据丢失。由于RDB是定期备份，可能每隔5分钟甚至更久，如果redis突然宕机，可能会丢失部分数据，所以RDB不适合作为第一优先的恢复方案。\n2. RDB每次执行快照生成数据文件的时候，如果数据文件特别大，可能会导致redis对客户提供的服务暂停数秒，所以不要让RDB备份的间隔太长，否则每次生成的文件太大，影响redis本身的性能。\n\n**AOF的优点**\n\n1. AOF可以更好的保护数据不丢失，一般AOF会每隔一秒记录一次，所以最多丢失1秒的数据。\n2. AOF日志以append-only模式写入，没有磁盘寻址开销，写入性能高，且文件不易破损。\n3. AOF日志文件过大的时候，出现后台重写操作也不会影响reids客户端的读写效率。\n4. AOF特别合适误删除的紧急恢复，比如输入了flushall清空了数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall删除，然后再将AOF文件放回去，就可以自动恢复。\n\n**AOF的缺点**\n\n1. 最大的缺点就是做数据恢复的时候会比较慢，做冷备和定期备份不方便，需要手写复杂脚本。\n2. 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。\n3. AOF开启后，支持的QPS会比RDB低，因为每秒一次fsync，不过性能还是很高的。\n4. 如果想保证一条数据都不丢，也是可以的，设置成每写入一条数据就fsync一次，不过性能会大降。\n5. AOF相比于RDB更加脆弱一些，恢复数据后可能导致跟原来不一样，容易产生bug。\n\n**RDB和AOF到底如何选择**\n\n- 不要仅仅使用RDB，因为那样会导致丢失很多数据。\n- 也不要仅仅使用AOF，因为AOF不适合做冷备，恢复数据比较慢还容易产生bug。\n- 所以综合使用AOF和RDB两种持久化机制，用AOF保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或者损坏不可用的时候，还可以使用RDB快照来进行数据恢复。\n\n------\n\n### redis的哨兵机制\n\nsentinal，中文名是哨兵，是redis集群架构中非常重要的一个组件，主要功能如下：\n\n1. 集群监控：负责监控redis master和slave进程是否正常工作。\n2. 消息通知：如果某个redis实例有故障，哨兵负责发送消息给管理员报警。\n3. 故障转移：如果master挂掉了，会自动转移到slave上。\n4. 配置中心：如果故障转移发生了，把新的master地址通知到客户端。\n\n哨兵本身也是分布式的，作为一个哨兵集群在运行，互相协同工作。\n\n1. 故障转移时，判断一个master是否宕机，需要大部分的哨兵同意才行，涉及到分布式选举。\n2. 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，保证了系统的高可用性。\n\n#### 哨兵的核心知识\n\n1. 哨兵至少需要3个实例，来保证自己的健壮性。\n2. 哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用。\n3. 对于哨兵+redis主从的复杂架构，尽量在测试和生产环境都进行充足的测试和演练。\n\n**为什么redis哨兵集群少于3个节点无法正常工作**\n\n如果哨兵集群只有两个节点，两个哨兵的majority=2，其中master所在的机器宕机了，这时只剩下一个哨兵，哨兵切换故障需要满足大多数哨兵同意原则，此时没有majority来运行执行故障转移，所以两个哨兵节点不能工作。\n\n#### sdown和odown转换机制？\n\nmaster宕机有sdown和odown两种失败状态\n\n- sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，就是主观宕机。\n- odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，就是客观宕机。\n- sdown达成的条件很简单，如果一个哨兵ping一个master，超过了is-master-after-milliseconds指定的毫秒数之后，就主观认为master宕机了\n- sdown到odown的转换条件也很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，也就是客观认为master宕机。\n\n#### 哨兵和slave集群的自动发现机制\n\n哨兵互相之间的发现，是通过redis的pub/sub系统实现的，每个哨兵都会往\\_sentinel\\_:hello channel里发送一个消息，内容是自己的host、ip和runid，还有对这个master的监控配置。每个哨兵也会去监听自己监控的master+slave对应的\\_sentinel\\_:hello channel，然后去感到到同样在监听这个master+slave的其他哨兵的存在，每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。\n\n#### slave-master选举算法\n\n如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来准备升级为master。\n\n**从节点过滤**：判断跟master断开连接的时长\n\n如果一个slave跟master断开连接已经超过了（down-after-milliseconds的10倍+master宕机的时长），那么slave就被认为不适合选举为master。\n\n1. slave配置的优先级（slave-priority=100）\n2. 复制offset\n3. run id\n\n说明：\n\n1. 然后把剩下了的slave按照优先级进行排序，slave priority越低，优先级就越高。\n2. 如果slave priority相同，就看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。\n3. 如果上面两个条件都相同，那么选择一个run id比较小的那个slave。\n\n#### slave配置的自动纠正\n\n哨兵会自动纠正slave的配置信息。比如某台slave要成为潜在的master候选人，哨兵会确保slave在复制现有的master数据；如果slave连接到了一个错误的master上，比如故障转移后，哨兵会确保它们连接到正确的master上。\n\n#### quorum和majority\n\n每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还要得到majority哨兵的授权，才能正式执行切换。\n\n如果quorum < majority，比如5个哨兵，majority就是3，quorum设置为2，可以执行切换。\n\n如果quorum >= majority，比如5个哨兵，设置quorum是5，那么必须5个哨兵都授权才能切换。\n\n#### configuration epoch\n\n哨兵进行切换之前，执行切换的那个哨兵从要切换到新的master那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。如果第一次master切换失败了，那么其他哨兵会等待failover-timeout时间，然后继续执行切换，此时会重新获得一个新的configuration epoch，作为新的version号。\n\n#### configuration传播\n\n哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他哨兵，通过pub/sub消息机制。\n\n这里version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置。\n\n------\n\n## 异步复制和集群脑裂导致数据丢失\n\n场景一：异步复制导致的数据丢失\n\nclient往redis master写入数据，master还没来得及复制给slave，此时，master宕机了，哨兵检测到master宕机后，从slave中投票选举出新的master，但是没来得及复制的数据就丢失了。\n\n场景二：集群脑裂导致的数据丢失\n\nmaster出现了网络异常，与其他slave节点失去联系，但没有挂掉，其他slave节点上的哨兵机制重新选举了master，不过此时的client跟旧的master网络是好的，发送了数据到旧的master数据没有得到同步，此时检测到该master有问题，修好网络后作为slave挂在到新的master节点上，但是新的master没有同步网络异常时的数据导致丢失。\n\n**如何降低损失？**\n\n- min-slaves-to-write 1\n- min-slaves-max-lag 10\n\n配置说明：要求至少有一个slave，数据复制和同步的延迟不能超过10秒。也就是说一旦所有的slave数据的复制和同步都超过了10秒，这时master就不会再接收写请求了，可以把数据落差保持在可控范围内，减少数据损失。\n\n上述配置也适合脑裂，master发生脑裂以后，所有slave都不向旧的master发送数据，10秒之后旧master停止接收写请求，同样也可以减少脑裂带来的数据丢失。\n\n------\n\n## 分布式集群-redis cluster\n\n1. 自动将数据进行分片，每个master上放一部分数据。\n2. 提供内置的高可用支持，部分master不可用时，还是可以继续工作的。\n\nredis cluster可以突破单机redis在海量数据面前的瓶颈。\n\n**redis cluster VS replication+sentinal**\n\n如果数据量很少，只有几个G，主要是承载高并发性能的场景，那么单机足够了。采用主从架构，再搭建一个sentinal集群，保证高可用。如果你的数据量很大，建议使用redis cluster。\n\n### 分布式数据存储的核心算法\n\n#### 最老土的hash算法和弊端\n\n把请求的数据进行hash运算，对hash值取模（针对master数量）然后放入对应的master节点中，如果某台master宕机了，该节点中的缓存数据就会失效，更严重的是由于master数量少了，导致取模方式改变，新的请求通过取模运算后得不到有效缓存，会造成几乎100%的请求涌入数据库重新生成缓存，这里会涉及到**大量的缓存重建**，这是致命的。\n\n#### 一致性hash算法(自动缓存迁移)\n\n有请求过来以后，同样是把key进行hash运算，然后会把hash值对应在圆环的各个点上，key落在圆环上以后就会顺时针旋转去寻找距离自己最近的master节点，如果任何一个master节点宕机，只有在该master上的缓存会失效，比如有3台master节点，宕机一台，1/3的数据流量会瞬间涌入数据库，重新查询一次，在环上的master节点越多，宕机后失效的数据越少。这只是均匀分布的情况，如有区间存在缓存热点，还是会有弊端。\n\n#### 一致性hash算法+虚拟节点\n\n基于一致性hash算法，在各个master节点之间，再创建均匀分布的虚拟节点，在每个区间内，大量的数据都会均匀的分布到不同的节点，不会存在大量的缓存顺时针同时融入一个master内，实现了自动的**负载均衡**。\n\n#### hash slot算法\n\nredis cluster有固定的16384个哈希槽，对每个key计算CRC16的值，然后对16384取模，注意不是对机器取模，所以即使有任何一台机器宕机，其他master中的缓存是不受影响的，经过短暂的数据迁移后，会把宕机中的缓存数据均匀分布到其他的master中继续提供服务。而且master slot让node的增加和移除变得很简单，只需要针对机器的个数均匀分配16384个哈希槽就可以了。\n\n------\n\n### redis集群模式的工作原理\n\n#### 节点间的内部通信机制\n\n**基础通信原理**\n\nredis cluster节点间采用**gossip**协议进行通信。\n\n跟集中式不同，不是将元数据（节点信息、故障等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的。\n\n- 集中式：好处在于，元数据的更新和读取的时效性非常好，一旦有变更，其他节点立刻就能感知到。缺点是所有的元数据的更新全部集中在一个地方，可能导致元数据的存储压力。\n- gossip：好处在于，元数据的更新比较分散，更新请求会陆陆续续的打到所有节点上去更新，降低了压力。缺点是元数据的更新有一定的延迟，可能导致集群的一些操作滞后。\n\n10000端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口，每个节点每隔一段时间都会往另外几个节点发送ping信息，收到后返回pong。通过通信端口结合gossip协议相互交换信息，包括故障信息、节点的增加和删除、hash slot信息等等。\n\n**gossip协议**\n\ngossip协议包含多种消息，包括ping、pong、meet、fail等。\n\n- meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始和其他节点进行通信。\n- ping：每个节点都会频繁的给其他节点发送ping，其中包含自己的状态还有自己维护集群的元数据，互相通过ping进行元数据的交换和更新。\n- pong：返回ping和meet，包含自己的状态和其他信息，也可以用于广播和更新。\n- fail：某个节点判断另一个节点fail后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。\n\n**ping消息深入**\n\n每个节点每秒会执行10次ping，每次会选择5个最久没有通信的其他节点。如果发现某个节点通信延时达到了cluster_node_timeout，就会立即发送ping，避免数据交换延迟过长。所以cluster_node_timeout可以调节，如果调节比较大，就可以降低发送的频率。每次ping需要带上自己的节点信息，还有就是带上1/10的其他节点信息，发送出去，进行数据交换。至少包含3个其他节点的信息，最多包含（总节点-2）个其他节点信息。\n\n------\n\njedis的运行原理：重定向，计算hash slot，采用smart jedis，在本地维护了一个hash slot -> node的映射表缓存。\n\n#### 高性能与主备切换原理\n\nredis cluster的高可用原理，几乎和哨兵是一样的。\n\n1. 判断节点宕机\n\n   如果一个节点认为另外一个节点宕机了，就是pfail，主观宕机。如果多个节点都认为另外一个节点pfail了，那么就是客观宕机fail。节点之间把pfail放在gossip ping中进行通信，超过半数认为pfail就是fail。\n\n2. 从节点过滤\n\n   对于宕机的master，从其所有的从节点slave中选择一个切换成master，检查每个slave与宕机的master断开连接的时间，如果超过了（cluster-node-timeout * cluster-slave-validity-factor）将失去选举资格。\n\n3. master选举\n\n   每个从节点都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多），选举时间越靠前，优先进行选举。然后开始进行投票，具体过程和哨兵类似，选举通过成为新的master。\n\n综上所述：redis cluster功能强大，直接集成了replication和sentinal的功能。\n\n------\n\n## 缓存雪崩、缓存穿透、缓存击穿\n\n### 缓存雪崩\n\n定义：指在某一时间段，缓存集体失效。\n\n#### 造成缓存雪崩的原因\n\n1. 比如双11零点抢购，大量商品被集中放入到缓存，假设缓存时效为一小时，那么到了凌晨1点的时候缓存就集体失效了，大量的请求会打在数据库上，对数据库来说，就会产生周期性的压力波峰，可能造成缓存雪崩。\n2. 缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。\n\n#### 如何预防缓存雪崩？\n\n针对缓存集体失效：如果是电商项目，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。\n\n针对缓存服务器宕机：redis高可用（主从+哨兵 或者 redis cluster），避免全盘奔溃。\n\n#### 缓存雪崩了如何恢复？\n\n本地ehcache缓存+hystrix限流&降级，避免mysql被打死。事后通过redis持久化快速恢复缓存数据。\n\n------\n\n### 缓存穿透\n\n定义：是指查询一个数据库一定不存在的数据，请求穿过了缓存，直接打在了数据库。\n\n#### 造成缓存穿透的原因\n\n代码bug或者恶意攻击。\n\n#### 如何预防缓存穿透？\n\n如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。\n\n------\n\n### 缓存击穿\n\n定义：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。\n\n### 如何预防缓存击穿？\n\n这种情况遇到的比较少，真有这种爆款key，设置成永不过期就可以了。\n\n------\n\n## 如何保证缓存与数据库的双写一致性\n\n### 先删缓存，再更新数据库\n\n最经典的缓存+数据库读写的模式：暂存模式（cache aside pattern）\n\n1. 读的时候先读缓存，缓存没有的话就读数据库，然后把数据库的数据放到缓存，同时返回相应。\n2. 更新的时候，**先删除缓存，再更新数据库**，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，不会造成不一致，因为读的时候缓存中没有，还会把旧的数据库数据更新到缓存中。反过来，如果先更改数据库再删除缓存，如果缓存删除失败了，则会导致数据不一致。\n\n为什么是删除缓存，而不是更新缓存呢？\n\n原因很简单，很多时候复杂点的缓存场景，不单单是修改了一个值那么简单，而是需要结合多张表去计算才能得到缓存结果，就算真的是简单场景的缓存，也需要看看这个缓存是不是被频繁的使用到，否则只是增加麻烦而已。\n\n其实删除缓存就是一个lazy计算的思想，不需要每次都做复杂的运算，它被用到的时候再计算就好了。\n\n------\n\n### 高并发场景下的数据不一致\n\n#### 问题描述\n\n数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没有修改，一个请求过来，去读缓存，发现缓存空了，去查询数据库，把旧的数据放到了缓存中，然后数据库完成了修改，此时数据库和缓存的数据不一致了。\n\n#### 解决方案\n\n把数据库与缓存的更新读取操作进行异步串行化。\n\n- 更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个内存队列中。\n- 读取数据的时候，如果发现数据不在缓存中，那么将进行（重新读取+更新缓存）操作，也根据唯一标识路由并发送到同一个内存队列中。\n\n一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。\n\n这样的话，一个数据变更的操作，先删除缓存，然后去更新数据库，但是还没有完成更新；此时如果一个读请求过来，读到了空的缓存，可以先将缓存更新的请求发送到队列中积压，然后同步等待缓存更新完成。\n\n这里有一个优化点，一个队列中，多个读请求（更新缓存）串在一起是没有意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，就不用再放更新操作进入队列了，直接等待前面的缓存更新完成即可。如果请求还在等待范围内，不断轮询发现可以取到值了就返回，超过等待时长就返回数据库中的旧值。\n\n#### 解决方案需要注意的问题\n\n**读请求 长时间堵塞**\n\n由于读请求做了非常轻度的异步化，所以一定要注意读超时问题，每个读请求必须在超时时间范围内返回。\n\n该方案的最大风险在于可能数据更新很频繁，或者包含了对多个数据项的修改，导致队列中积压了大量的更新操作在里面，然后读请求发生了大量的超时，最后导致大量的读请求直接走数据库。一定要提前做好压力测试和真实数据模拟，不过一般来说数据的写频率是很低的，所以队列中积压的应该不会太多。如果真的导致积压过多的话，可以采取增加内存队列的方式来解决。\n\n**读请求 并发量过高**\n\n上述方案有可能突然大量的读请求在几十毫秒内hang在服务器上，看需要几台服务器才能扛得住，所以要计算好每个读请求不要hang太久。\n\n**多服务实例部署的请求路由**\n\n可能这个服务部署了多个实例，那么必须保证，执行数据更新操作以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务器实例上。\n\n**热点商品的路由问题**\n\n万一某个商品的读写请求特别高，全部打到相同的机器的相同队列里去了，可能造成某台机器的压力过大。\n\n因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题影响不是很大，不过的缺可能某些机器的负载高一些。\n\n------\n\n## 如何保证redis并发竞争的数据一致性\n\n客户端角度：为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。\n\n服务器角度：采用分布式锁，确保同一时刻只能有一个系统实例在操作某个key，获得分布式锁以后，每次要写之前，先判断当前这个value的时间戳是否比缓存中的时间戳更新，如果更新，可以写入；否则，就不能用旧数据覆盖新数据。","source":"_posts/redis.md","raw":"---\ntitle: 分布式缓存-Redis\ndate: 2019-03-12 23:46:44\ncategories: Java\ntags:\n  - 分布式\n  - redis\ntop_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg\n---\n\n## redis单线程模型原理剖析？\n\nredis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。\n\n## redis为什么这么快？\n\n1. 纯内存操作。\n2. 核心是基于非阻塞的IO多路复用机制。\n3. 单线程——避免了多线程的频繁上下文切换问题。\n4. Resp协议。<!--more-->\n\n## 使用redis有什么缺点？\n\n- 缓存和数据库双写一致性问题\n- 缓存雪崩、缓存击穿\n- 缓存的并发竞争\n\n## redis支持的数据类型和使用场景\n\n1. string\n\n   最基本的类型，普通的set和get，做简单的key-value缓存。\n\n2. hash\n\n   类似map的一种结构，特别适合用存储对象，可以仅仅修改这个对象中的某个字段。\n\n3. list\n\n   有序列表，这个是可以玩出很多花样的：\n\n   比如可以基于redis的list实现简单的高性能分页，类似于微博的那种一直下拉。\n\n   还可以搞个简单的消息队列，从list头进去，从list尾巴取出来。\n\n4. set\n\n   无序集合，自动去重。\n\n   如果某个系统部署在多台机器上，可以基于redis实现全局的set去重。\n\n   还可以基于set玩交集，并集，差集的操作，比如利用交集，可以查看两个人的粉丝列表中的共同好友。\n\n5. sorted set\n\n   有序集合，自动去重。\n\n   这个也可以玩很多花样，写数据进去的时候给一个分数，自动根据分数排序，可以自定义排序规则。\n\n   比如想根据数据的时间排序，那么在写入数据的时候把时间作为分数，这样就会按时间排序了。\n\n   排行榜：将每个用户以及对应的分数写入进去，会自动排序，可以查看前几名的结果。\n\n   zadd board 85 jack\n\n   zadd board 72 tom\n\n   zadd board 96 jerry\n\n   zrevrange board 0 2：可以查看前三名的排序结果\n\n   zrank board tom：返回3，意思是tom排名第3\n\n------\n\n## redis的过期策略有哪些\n\n**定期删除+惰性删除**\n\n所谓**定期删除**，指的是redis默认每隔100ms就随机抽取一些过期时间的key，检测是否过期，如果过期就删除。注意：这里redis不是遍历所有过期的key（CPU负载太高），而是随机抽取。\n\n所谓**惰性删除**，指的是定期删除可能会导致很多过期的key到了时间也没被删除，所以在获取某个key的时候，redis会查一下这个key是否过期，如果过期了此时就会删除，不会返回结果。\n\n产生问题：如果定期删除漏掉了很多过期key没删，惰性删除是用到的时候才删，如果过期了并且一直没用到就会导致有大量的过期key堆积，这时候就需要走**内存淘汰机制**了。\n\n1. no-enviction（驱逐）：禁止驱逐数据，再写入会报错。**（默认，应该没人用）**\n2. allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。**（推荐使用）**\n3. allkeys-random：从数据集中任意选择数据淘汰。\n4. volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。\n5. volatile-ttl：从`已设置过期时间的`数据集中挑选`将要过期的`数据淘汰。\n6. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。\n\n------\n\n## 怎么保证redis的高并发&高可用？\n\nredis高并发：采用**主从架构**，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒上10万的QPS。如果redis高并发的同时还需要容纳大量的数据：几十G甚至几百G的数据，这样的话就需要采用redis集群了，还能提供每秒几十万的读写并发。\n\nredis高可用：如果做主从架构部署，其实加上**哨兵**就可以了，任何一个实例宕机，都会自动切换。\n\n### redis的主从复制\n\n主从架构 -> 读写分离 -> 水平扩容支撑10+的**读QPS**\n\n首先考虑读写分离，做成主从架构，一主多从，主负责写，并且将数据同步到其他slave节点，从节点负责读，所有的读请求都走从节点。好处是可以水平扩容，就是说如果QPS再增加，只需要继续增加slave就可以了。 \n\n#### 主从复制的核心原理\n\n当启动一个slave的时候，该节点会发送一个PSYNC命令给master，如果这是slave的重新连接，master仅仅会发送给slave部分缺少的数据进行**增量复制**，如果这是slave第一次连接master，会触发一次**全量复制**。\n\n官方解释：\n\n1. slave启动时，仅仅保存master的host和ip（redis.conf中配置的），此时复制流程还没开始。\n2. slave内部有个定时任务，每秒都会check是否有新的master要连接和复制，如果发现则建立网络连接。\n3. slave发送ping给master，如果master配置了requirepass，那么slave必须发送masterauth口令过去认证。\n4. master第一次执行全量复制，将所有数据发送给slave。\n5. master后续还会持续将写命令异步发送给slave。\n\n全量复制：开始full resynchronized的时候，master会启动一个后台线程，生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕以后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送给slave，slave来同步这些数据。\n\n增量复制：master根据slave发送的psync中的offset，在backlog中查找到部分丢失的数据，发送给slave。\n\n#### 主从复制的断点续传\n\n从redis2.8开始就支持主从复制的断点续传了。在主从复制过程中，如果网络连接断掉了，可以接着上次复制的地方继续复制，而不是重新开始复制。master会在内存中维护一个backlog，master和slave都会保存一个复制数据的replica offset和一个master run id，offset就是保存在backlog中的。如果master和slave网络中断了，slave会让master从上次的replica offset开始继续复制。但是如果没有找到对应的offset，那么就会执行一次resynchronized。\n\n官方解释：\n\n1. master和slave都会维护一个offset，slave每秒都会上报自己的offect给master，master记录在backlog中，这样才能知道双方数据是否一致。\n2. master还会维护一个backlog文件，默认是1M大小，给slave复制数据时也会记录在backlog中，主要是用来做全量复制中断后的增量复制的。\n3. master重启或者加载了之前的RDB数据是会变的，run id也会变，所以slave需要根据不同的run id区分，如果run id不同就需要做全量复制。\n4. 从节点使用psync从master进行复制，发送psync runid offset到master。master会根据自身的情况返回相应的信息，可能是FULLRESYNC runid offset触发全量复制，也可能是CONTINUE触发增量复制。\n\n#### 无磁盘化复制\n\n在redis的配置文件中开启无磁盘化复制以后，master会在内存中直接创建rdb文件然后发送给slave，不会保存在本地磁盘。这里不建议开启，开启也很简单，主要涉及到两个参数：repl-diskless-sync no 默认是no，改成yes就可以了，repl-diskless-sync-delay 5 默认是延迟5s在开始复制，因为需要等待更多的slave重新连接。\n\n#### 过期key处理\n\nslave不会过期key，只会等待master过期key。\n\n如果master过期了一个key，或者通过LRU淘汰了一个key，master会模拟一条del命令发送给slave。\n\n#### redis的心跳检测机制\n\n在命令传播阶段，slave每隔一秒向master发送一个心跳，主要用来检测双方的网络连接状态。\n\n#### redis的持久化\n\n如果采用了主从架构，建议必须开启master node的持久化。\n\n不建议用slave node作为master node的热备，因为那样的话如果关掉master的持久化（RDB和AOF都关闭）可能在master宕机重启的时候数据是空的，然后从节点一复制，slave node的数据也丢了。\n\n即使slave node可以自动接管master node，也可能哨兵还没有检测到master failure，master node就重启了，还是可能导致上面的所有slave node数据被清空的故障。\n\n**持久化方式RDB和AOF**\n\n- RDB持久化机制：通过快照的方式，对redis中的数据进行周期性的持久化。\n- AOF持久化机制：通过记录写命令，以append-only模式写入到日志文件中，redis重启时重新构建。\n\n如果同时开启了RDB和AOF两种持久化机制，在redis重启时会使用AOF来构建数据，因为AOF数据更加完整。\n\n如果我们想要redis仅仅作为纯内存的缓存来用，可以关掉RDB和AOF持久化机制。\n\n**RDB的优点**\n\n1. RDB会生成多个数据文件，非常适合做冷备，可以上传到云盘定期维护。\n2. RDB对redis的性能影响非常小，定期把数据写入到磁盘，使redis保持高性能。\n3. 通过RDB数据文件来做数据恢复更加快速，直接把文件加载到内存即可。\n\n**RDB的缺点**\n\n1. 最大的缺点就是可能造成部分数据丢失。由于RDB是定期备份，可能每隔5分钟甚至更久，如果redis突然宕机，可能会丢失部分数据，所以RDB不适合作为第一优先的恢复方案。\n2. RDB每次执行快照生成数据文件的时候，如果数据文件特别大，可能会导致redis对客户提供的服务暂停数秒，所以不要让RDB备份的间隔太长，否则每次生成的文件太大，影响redis本身的性能。\n\n**AOF的优点**\n\n1. AOF可以更好的保护数据不丢失，一般AOF会每隔一秒记录一次，所以最多丢失1秒的数据。\n2. AOF日志以append-only模式写入，没有磁盘寻址开销，写入性能高，且文件不易破损。\n3. AOF日志文件过大的时候，出现后台重写操作也不会影响reids客户端的读写效率。\n4. AOF特别合适误删除的紧急恢复，比如输入了flushall清空了数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall删除，然后再将AOF文件放回去，就可以自动恢复。\n\n**AOF的缺点**\n\n1. 最大的缺点就是做数据恢复的时候会比较慢，做冷备和定期备份不方便，需要手写复杂脚本。\n2. 对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。\n3. AOF开启后，支持的QPS会比RDB低，因为每秒一次fsync，不过性能还是很高的。\n4. 如果想保证一条数据都不丢，也是可以的，设置成每写入一条数据就fsync一次，不过性能会大降。\n5. AOF相比于RDB更加脆弱一些，恢复数据后可能导致跟原来不一样，容易产生bug。\n\n**RDB和AOF到底如何选择**\n\n- 不要仅仅使用RDB，因为那样会导致丢失很多数据。\n- 也不要仅仅使用AOF，因为AOF不适合做冷备，恢复数据比较慢还容易产生bug。\n- 所以综合使用AOF和RDB两种持久化机制，用AOF保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或者损坏不可用的时候，还可以使用RDB快照来进行数据恢复。\n\n------\n\n### redis的哨兵机制\n\nsentinal，中文名是哨兵，是redis集群架构中非常重要的一个组件，主要功能如下：\n\n1. 集群监控：负责监控redis master和slave进程是否正常工作。\n2. 消息通知：如果某个redis实例有故障，哨兵负责发送消息给管理员报警。\n3. 故障转移：如果master挂掉了，会自动转移到slave上。\n4. 配置中心：如果故障转移发生了，把新的master地址通知到客户端。\n\n哨兵本身也是分布式的，作为一个哨兵集群在运行，互相协同工作。\n\n1. 故障转移时，判断一个master是否宕机，需要大部分的哨兵同意才行，涉及到分布式选举。\n2. 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，保证了系统的高可用性。\n\n#### 哨兵的核心知识\n\n1. 哨兵至少需要3个实例，来保证自己的健壮性。\n2. 哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用。\n3. 对于哨兵+redis主从的复杂架构，尽量在测试和生产环境都进行充足的测试和演练。\n\n**为什么redis哨兵集群少于3个节点无法正常工作**\n\n如果哨兵集群只有两个节点，两个哨兵的majority=2，其中master所在的机器宕机了，这时只剩下一个哨兵，哨兵切换故障需要满足大多数哨兵同意原则，此时没有majority来运行执行故障转移，所以两个哨兵节点不能工作。\n\n#### sdown和odown转换机制？\n\nmaster宕机有sdown和odown两种失败状态\n\n- sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，就是主观宕机。\n- odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，就是客观宕机。\n- sdown达成的条件很简单，如果一个哨兵ping一个master，超过了is-master-after-milliseconds指定的毫秒数之后，就主观认为master宕机了\n- sdown到odown的转换条件也很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，也就是客观认为master宕机。\n\n#### 哨兵和slave集群的自动发现机制\n\n哨兵互相之间的发现，是通过redis的pub/sub系统实现的，每个哨兵都会往\\_sentinel\\_:hello channel里发送一个消息，内容是自己的host、ip和runid，还有对这个master的监控配置。每个哨兵也会去监听自己监控的master+slave对应的\\_sentinel\\_:hello channel，然后去感到到同样在监听这个master+slave的其他哨兵的存在，每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。\n\n#### slave-master选举算法\n\n如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来准备升级为master。\n\n**从节点过滤**：判断跟master断开连接的时长\n\n如果一个slave跟master断开连接已经超过了（down-after-milliseconds的10倍+master宕机的时长），那么slave就被认为不适合选举为master。\n\n1. slave配置的优先级（slave-priority=100）\n2. 复制offset\n3. run id\n\n说明：\n\n1. 然后把剩下了的slave按照优先级进行排序，slave priority越低，优先级就越高。\n2. 如果slave priority相同，就看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。\n3. 如果上面两个条件都相同，那么选择一个run id比较小的那个slave。\n\n#### slave配置的自动纠正\n\n哨兵会自动纠正slave的配置信息。比如某台slave要成为潜在的master候选人，哨兵会确保slave在复制现有的master数据；如果slave连接到了一个错误的master上，比如故障转移后，哨兵会确保它们连接到正确的master上。\n\n#### quorum和majority\n\n每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还要得到majority哨兵的授权，才能正式执行切换。\n\n如果quorum < majority，比如5个哨兵，majority就是3，quorum设置为2，可以执行切换。\n\n如果quorum >= majority，比如5个哨兵，设置quorum是5，那么必须5个哨兵都授权才能切换。\n\n#### configuration epoch\n\n哨兵进行切换之前，执行切换的那个哨兵从要切换到新的master那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。如果第一次master切换失败了，那么其他哨兵会等待failover-timeout时间，然后继续执行切换，此时会重新获得一个新的configuration epoch，作为新的version号。\n\n#### configuration传播\n\n哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他哨兵，通过pub/sub消息机制。\n\n这里version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置。\n\n------\n\n## 异步复制和集群脑裂导致数据丢失\n\n场景一：异步复制导致的数据丢失\n\nclient往redis master写入数据，master还没来得及复制给slave，此时，master宕机了，哨兵检测到master宕机后，从slave中投票选举出新的master，但是没来得及复制的数据就丢失了。\n\n场景二：集群脑裂导致的数据丢失\n\nmaster出现了网络异常，与其他slave节点失去联系，但没有挂掉，其他slave节点上的哨兵机制重新选举了master，不过此时的client跟旧的master网络是好的，发送了数据到旧的master数据没有得到同步，此时检测到该master有问题，修好网络后作为slave挂在到新的master节点上，但是新的master没有同步网络异常时的数据导致丢失。\n\n**如何降低损失？**\n\n- min-slaves-to-write 1\n- min-slaves-max-lag 10\n\n配置说明：要求至少有一个slave，数据复制和同步的延迟不能超过10秒。也就是说一旦所有的slave数据的复制和同步都超过了10秒，这时master就不会再接收写请求了，可以把数据落差保持在可控范围内，减少数据损失。\n\n上述配置也适合脑裂，master发生脑裂以后，所有slave都不向旧的master发送数据，10秒之后旧master停止接收写请求，同样也可以减少脑裂带来的数据丢失。\n\n------\n\n## 分布式集群-redis cluster\n\n1. 自动将数据进行分片，每个master上放一部分数据。\n2. 提供内置的高可用支持，部分master不可用时，还是可以继续工作的。\n\nredis cluster可以突破单机redis在海量数据面前的瓶颈。\n\n**redis cluster VS replication+sentinal**\n\n如果数据量很少，只有几个G，主要是承载高并发性能的场景，那么单机足够了。采用主从架构，再搭建一个sentinal集群，保证高可用。如果你的数据量很大，建议使用redis cluster。\n\n### 分布式数据存储的核心算法\n\n#### 最老土的hash算法和弊端\n\n把请求的数据进行hash运算，对hash值取模（针对master数量）然后放入对应的master节点中，如果某台master宕机了，该节点中的缓存数据就会失效，更严重的是由于master数量少了，导致取模方式改变，新的请求通过取模运算后得不到有效缓存，会造成几乎100%的请求涌入数据库重新生成缓存，这里会涉及到**大量的缓存重建**，这是致命的。\n\n#### 一致性hash算法(自动缓存迁移)\n\n有请求过来以后，同样是把key进行hash运算，然后会把hash值对应在圆环的各个点上，key落在圆环上以后就会顺时针旋转去寻找距离自己最近的master节点，如果任何一个master节点宕机，只有在该master上的缓存会失效，比如有3台master节点，宕机一台，1/3的数据流量会瞬间涌入数据库，重新查询一次，在环上的master节点越多，宕机后失效的数据越少。这只是均匀分布的情况，如有区间存在缓存热点，还是会有弊端。\n\n#### 一致性hash算法+虚拟节点\n\n基于一致性hash算法，在各个master节点之间，再创建均匀分布的虚拟节点，在每个区间内，大量的数据都会均匀的分布到不同的节点，不会存在大量的缓存顺时针同时融入一个master内，实现了自动的**负载均衡**。\n\n#### hash slot算法\n\nredis cluster有固定的16384个哈希槽，对每个key计算CRC16的值，然后对16384取模，注意不是对机器取模，所以即使有任何一台机器宕机，其他master中的缓存是不受影响的，经过短暂的数据迁移后，会把宕机中的缓存数据均匀分布到其他的master中继续提供服务。而且master slot让node的增加和移除变得很简单，只需要针对机器的个数均匀分配16384个哈希槽就可以了。\n\n------\n\n### redis集群模式的工作原理\n\n#### 节点间的内部通信机制\n\n**基础通信原理**\n\nredis cluster节点间采用**gossip**协议进行通信。\n\n跟集中式不同，不是将元数据（节点信息、故障等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的。\n\n- 集中式：好处在于，元数据的更新和读取的时效性非常好，一旦有变更，其他节点立刻就能感知到。缺点是所有的元数据的更新全部集中在一个地方，可能导致元数据的存储压力。\n- gossip：好处在于，元数据的更新比较分散，更新请求会陆陆续续的打到所有节点上去更新，降低了压力。缺点是元数据的更新有一定的延迟，可能导致集群的一些操作滞后。\n\n10000端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口，每个节点每隔一段时间都会往另外几个节点发送ping信息，收到后返回pong。通过通信端口结合gossip协议相互交换信息，包括故障信息、节点的增加和删除、hash slot信息等等。\n\n**gossip协议**\n\ngossip协议包含多种消息，包括ping、pong、meet、fail等。\n\n- meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始和其他节点进行通信。\n- ping：每个节点都会频繁的给其他节点发送ping，其中包含自己的状态还有自己维护集群的元数据，互相通过ping进行元数据的交换和更新。\n- pong：返回ping和meet，包含自己的状态和其他信息，也可以用于广播和更新。\n- fail：某个节点判断另一个节点fail后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。\n\n**ping消息深入**\n\n每个节点每秒会执行10次ping，每次会选择5个最久没有通信的其他节点。如果发现某个节点通信延时达到了cluster_node_timeout，就会立即发送ping，避免数据交换延迟过长。所以cluster_node_timeout可以调节，如果调节比较大，就可以降低发送的频率。每次ping需要带上自己的节点信息，还有就是带上1/10的其他节点信息，发送出去，进行数据交换。至少包含3个其他节点的信息，最多包含（总节点-2）个其他节点信息。\n\n------\n\njedis的运行原理：重定向，计算hash slot，采用smart jedis，在本地维护了一个hash slot -> node的映射表缓存。\n\n#### 高性能与主备切换原理\n\nredis cluster的高可用原理，几乎和哨兵是一样的。\n\n1. 判断节点宕机\n\n   如果一个节点认为另外一个节点宕机了，就是pfail，主观宕机。如果多个节点都认为另外一个节点pfail了，那么就是客观宕机fail。节点之间把pfail放在gossip ping中进行通信，超过半数认为pfail就是fail。\n\n2. 从节点过滤\n\n   对于宕机的master，从其所有的从节点slave中选择一个切换成master，检查每个slave与宕机的master断开连接的时间，如果超过了（cluster-node-timeout * cluster-slave-validity-factor）将失去选举资格。\n\n3. master选举\n\n   每个从节点都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多），选举时间越靠前，优先进行选举。然后开始进行投票，具体过程和哨兵类似，选举通过成为新的master。\n\n综上所述：redis cluster功能强大，直接集成了replication和sentinal的功能。\n\n------\n\n## 缓存雪崩、缓存穿透、缓存击穿\n\n### 缓存雪崩\n\n定义：指在某一时间段，缓存集体失效。\n\n#### 造成缓存雪崩的原因\n\n1. 比如双11零点抢购，大量商品被集中放入到缓存，假设缓存时效为一小时，那么到了凌晨1点的时候缓存就集体失效了，大量的请求会打在数据库上，对数据库来说，就会产生周期性的压力波峰，可能造成缓存雪崩。\n2. 缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。\n\n#### 如何预防缓存雪崩？\n\n针对缓存集体失效：如果是电商项目，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。\n\n针对缓存服务器宕机：redis高可用（主从+哨兵 或者 redis cluster），避免全盘奔溃。\n\n#### 缓存雪崩了如何恢复？\n\n本地ehcache缓存+hystrix限流&降级，避免mysql被打死。事后通过redis持久化快速恢复缓存数据。\n\n------\n\n### 缓存穿透\n\n定义：是指查询一个数据库一定不存在的数据，请求穿过了缓存，直接打在了数据库。\n\n#### 造成缓存穿透的原因\n\n代码bug或者恶意攻击。\n\n#### 如何预防缓存穿透？\n\n如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。\n\n------\n\n### 缓存击穿\n\n定义：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。\n\n### 如何预防缓存击穿？\n\n这种情况遇到的比较少，真有这种爆款key，设置成永不过期就可以了。\n\n------\n\n## 如何保证缓存与数据库的双写一致性\n\n### 先删缓存，再更新数据库\n\n最经典的缓存+数据库读写的模式：暂存模式（cache aside pattern）\n\n1. 读的时候先读缓存，缓存没有的话就读数据库，然后把数据库的数据放到缓存，同时返回相应。\n2. 更新的时候，**先删除缓存，再更新数据库**，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，不会造成不一致，因为读的时候缓存中没有，还会把旧的数据库数据更新到缓存中。反过来，如果先更改数据库再删除缓存，如果缓存删除失败了，则会导致数据不一致。\n\n为什么是删除缓存，而不是更新缓存呢？\n\n原因很简单，很多时候复杂点的缓存场景，不单单是修改了一个值那么简单，而是需要结合多张表去计算才能得到缓存结果，就算真的是简单场景的缓存，也需要看看这个缓存是不是被频繁的使用到，否则只是增加麻烦而已。\n\n其实删除缓存就是一个lazy计算的思想，不需要每次都做复杂的运算，它被用到的时候再计算就好了。\n\n------\n\n### 高并发场景下的数据不一致\n\n#### 问题描述\n\n数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没有修改，一个请求过来，去读缓存，发现缓存空了，去查询数据库，把旧的数据放到了缓存中，然后数据库完成了修改，此时数据库和缓存的数据不一致了。\n\n#### 解决方案\n\n把数据库与缓存的更新读取操作进行异步串行化。\n\n- 更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个内存队列中。\n- 读取数据的时候，如果发现数据不在缓存中，那么将进行（重新读取+更新缓存）操作，也根据唯一标识路由并发送到同一个内存队列中。\n\n一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。\n\n这样的话，一个数据变更的操作，先删除缓存，然后去更新数据库，但是还没有完成更新；此时如果一个读请求过来，读到了空的缓存，可以先将缓存更新的请求发送到队列中积压，然后同步等待缓存更新完成。\n\n这里有一个优化点，一个队列中，多个读请求（更新缓存）串在一起是没有意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，就不用再放更新操作进入队列了，直接等待前面的缓存更新完成即可。如果请求还在等待范围内，不断轮询发现可以取到值了就返回，超过等待时长就返回数据库中的旧值。\n\n#### 解决方案需要注意的问题\n\n**读请求 长时间堵塞**\n\n由于读请求做了非常轻度的异步化，所以一定要注意读超时问题，每个读请求必须在超时时间范围内返回。\n\n该方案的最大风险在于可能数据更新很频繁，或者包含了对多个数据项的修改，导致队列中积压了大量的更新操作在里面，然后读请求发生了大量的超时，最后导致大量的读请求直接走数据库。一定要提前做好压力测试和真实数据模拟，不过一般来说数据的写频率是很低的，所以队列中积压的应该不会太多。如果真的导致积压过多的话，可以采取增加内存队列的方式来解决。\n\n**读请求 并发量过高**\n\n上述方案有可能突然大量的读请求在几十毫秒内hang在服务器上，看需要几台服务器才能扛得住，所以要计算好每个读请求不要hang太久。\n\n**多服务实例部署的请求路由**\n\n可能这个服务部署了多个实例，那么必须保证，执行数据更新操作以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务器实例上。\n\n**热点商品的路由问题**\n\n万一某个商品的读写请求特别高，全部打到相同的机器的相同队列里去了，可能造成某台机器的压力过大。\n\n因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题影响不是很大，不过的缺可能某些机器的负载高一些。\n\n------\n\n## 如何保证redis并发竞争的数据一致性\n\n客户端角度：为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。\n\n服务器角度：采用分布式锁，确保同一时刻只能有一个系统实例在操作某个key，获得分布式锁以后，每次要写之前，先判断当前这个value的时间戳是否比缓存中的时间戳更新，如果更新，可以写入；否则，就不能用旧数据覆盖新数据。","slug":"redis","published":1,"updated":"2020-02-14T16:18:37.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61cno004pa6ybrotjuccn","content":"<h2 id=\"redis单线程模型原理剖析？\"><a href=\"#redis单线程模型原理剖析？\" class=\"headerlink\" title=\"redis单线程模型原理剖析？\"></a>redis单线程模型原理剖析？</h2><p>redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。</p>\n<h2 id=\"redis为什么这么快？\"><a href=\"#redis为什么这么快？\" class=\"headerlink\" title=\"redis为什么这么快？\"></a>redis为什么这么快？</h2><ol>\n<li>纯内存操作。</li>\n<li>核心是基于非阻塞的IO多路复用机制。</li>\n<li>单线程——避免了多线程的频繁上下文切换问题。</li>\n<li>Resp协议。<a id=\"more\"></a></li>\n</ol>\n<h2 id=\"使用redis有什么缺点？\"><a href=\"#使用redis有什么缺点？\" class=\"headerlink\" title=\"使用redis有什么缺点？\"></a>使用redis有什么缺点？</h2><ul>\n<li>缓存和数据库双写一致性问题</li>\n<li>缓存雪崩、缓存击穿</li>\n<li>缓存的并发竞争</li>\n</ul>\n<h2 id=\"redis支持的数据类型和使用场景\"><a href=\"#redis支持的数据类型和使用场景\" class=\"headerlink\" title=\"redis支持的数据类型和使用场景\"></a>redis支持的数据类型和使用场景</h2><ol>\n<li><p>string</p>\n<p>最基本的类型，普通的set和get，做简单的key-value缓存。</p>\n</li>\n<li><p>hash</p>\n<p>类似map的一种结构，特别适合用存储对象，可以仅仅修改这个对象中的某个字段。</p>\n</li>\n<li><p>list</p>\n<p>有序列表，这个是可以玩出很多花样的：</p>\n<p>比如可以基于redis的list实现简单的高性能分页，类似于微博的那种一直下拉。</p>\n<p>还可以搞个简单的消息队列，从list头进去，从list尾巴取出来。</p>\n</li>\n<li><p>set</p>\n<p>无序集合，自动去重。</p>\n<p>如果某个系统部署在多台机器上，可以基于redis实现全局的set去重。</p>\n<p>还可以基于set玩交集，并集，差集的操作，比如利用交集，可以查看两个人的粉丝列表中的共同好友。</p>\n</li>\n<li><p>sorted set</p>\n<p>有序集合，自动去重。</p>\n<p>这个也可以玩很多花样，写数据进去的时候给一个分数，自动根据分数排序，可以自定义排序规则。</p>\n<p>比如想根据数据的时间排序，那么在写入数据的时候把时间作为分数，这样就会按时间排序了。</p>\n<p>排行榜：将每个用户以及对应的分数写入进去，会自动排序，可以查看前几名的结果。</p>\n<p>zadd board 85 jack</p>\n<p>zadd board 72 tom</p>\n<p>zadd board 96 jerry</p>\n<p>zrevrange board 0 2：可以查看前三名的排序结果</p>\n<p>zrank board tom：返回3，意思是tom排名第3</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"redis的过期策略有哪些\"><a href=\"#redis的过期策略有哪些\" class=\"headerlink\" title=\"redis的过期策略有哪些\"></a>redis的过期策略有哪些</h2><p><strong>定期删除+惰性删除</strong></p>\n<p>所谓<strong>定期删除</strong>，指的是redis默认每隔100ms就随机抽取一些过期时间的key，检测是否过期，如果过期就删除。注意：这里redis不是遍历所有过期的key（CPU负载太高），而是随机抽取。</p>\n<p>所谓<strong>惰性删除</strong>，指的是定期删除可能会导致很多过期的key到了时间也没被删除，所以在获取某个key的时候，redis会查一下这个key是否过期，如果过期了此时就会删除，不会返回结果。</p>\n<p>产生问题：如果定期删除漏掉了很多过期key没删，惰性删除是用到的时候才删，如果过期了并且一直没用到就会导致有大量的过期key堆积，这时候就需要走<strong>内存淘汰机制</strong>了。</p>\n<ol>\n<li>no-enviction（驱逐）：禁止驱逐数据，再写入会报错。<strong>（默认，应该没人用）</strong></li>\n<li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。<strong>（推荐使用）</strong></li>\n<li>allkeys-random：从数据集中任意选择数据淘汰。</li>\n<li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li>\n<li>volatile-ttl：从<code>已设置过期时间的</code>数据集中挑选<code>将要过期的</code>数据淘汰。</li>\n<li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li>\n</ol>\n<hr>\n<h2 id=\"怎么保证redis的高并发-amp-高可用？\"><a href=\"#怎么保证redis的高并发-amp-高可用？\" class=\"headerlink\" title=\"怎么保证redis的高并发&amp;高可用？\"></a>怎么保证redis的高并发&amp;高可用？</h2><p>redis高并发：采用<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒上10万的QPS。如果redis高并发的同时还需要容纳大量的数据：几十G甚至几百G的数据，这样的话就需要采用redis集群了，还能提供每秒几十万的读写并发。</p>\n<p>redis高可用：如果做主从架构部署，其实加上<strong>哨兵</strong>就可以了，任何一个实例宕机，都会自动切换。</p>\n<h3 id=\"redis的主从复制\"><a href=\"#redis的主从复制\" class=\"headerlink\" title=\"redis的主从复制\"></a>redis的主从复制</h3><p>主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑10+的<strong>读QPS</strong></p>\n<p>首先考虑读写分离，做成主从架构，一主多从，主负责写，并且将数据同步到其他slave节点，从节点负责读，所有的读请求都走从节点。好处是可以水平扩容，就是说如果QPS再增加，只需要继续增加slave就可以了。 </p>\n<h4 id=\"主从复制的核心原理\"><a href=\"#主从复制的核心原理\" class=\"headerlink\" title=\"主从复制的核心原理\"></a>主从复制的核心原理</h4><p>当启动一个slave的时候，该节点会发送一个PSYNC命令给master，如果这是slave的重新连接，master仅仅会发送给slave部分缺少的数据进行<strong>增量复制</strong>，如果这是slave第一次连接master，会触发一次<strong>全量复制</strong>。</p>\n<p>官方解释：</p>\n<ol>\n<li>slave启动时，仅仅保存master的host和ip（redis.conf中配置的），此时复制流程还没开始。</li>\n<li>slave内部有个定时任务，每秒都会check是否有新的master要连接和复制，如果发现则建立网络连接。</li>\n<li>slave发送ping给master，如果master配置了requirepass，那么slave必须发送masterauth口令过去认证。</li>\n<li>master第一次执行全量复制，将所有数据发送给slave。</li>\n<li>master后续还会持续将写命令异步发送给slave。</li>\n</ol>\n<p>全量复制：开始full resynchronized的时候，master会启动一个后台线程，生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕以后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送给slave，slave来同步这些数据。</p>\n<p>增量复制：master根据slave发送的psync中的offset，在backlog中查找到部分丢失的数据，发送给slave。</p>\n<h4 id=\"主从复制的断点续传\"><a href=\"#主从复制的断点续传\" class=\"headerlink\" title=\"主从复制的断点续传\"></a>主从复制的断点续传</h4><p>从redis2.8开始就支持主从复制的断点续传了。在主从复制过程中，如果网络连接断掉了，可以接着上次复制的地方继续复制，而不是重新开始复制。master会在内存中维护一个backlog，master和slave都会保存一个复制数据的replica offset和一个master run id，offset就是保存在backlog中的。如果master和slave网络中断了，slave会让master从上次的replica offset开始继续复制。但是如果没有找到对应的offset，那么就会执行一次resynchronized。</p>\n<p>官方解释：</p>\n<ol>\n<li>master和slave都会维护一个offset，slave每秒都会上报自己的offect给master，master记录在backlog中，这样才能知道双方数据是否一致。</li>\n<li>master还会维护一个backlog文件，默认是1M大小，给slave复制数据时也会记录在backlog中，主要是用来做全量复制中断后的增量复制的。</li>\n<li>master重启或者加载了之前的RDB数据是会变的，run id也会变，所以slave需要根据不同的run id区分，如果run id不同就需要做全量复制。</li>\n<li>从节点使用psync从master进行复制，发送psync runid offset到master。master会根据自身的情况返回相应的信息，可能是FULLRESYNC runid offset触发全量复制，也可能是CONTINUE触发增量复制。</li>\n</ol>\n<h4 id=\"无磁盘化复制\"><a href=\"#无磁盘化复制\" class=\"headerlink\" title=\"无磁盘化复制\"></a>无磁盘化复制</h4><p>在redis的配置文件中开启无磁盘化复制以后，master会在内存中直接创建rdb文件然后发送给slave，不会保存在本地磁盘。这里不建议开启，开启也很简单，主要涉及到两个参数：repl-diskless-sync no 默认是no，改成yes就可以了，repl-diskless-sync-delay 5 默认是延迟5s在开始复制，因为需要等待更多的slave重新连接。</p>\n<h4 id=\"过期key处理\"><a href=\"#过期key处理\" class=\"headerlink\" title=\"过期key处理\"></a>过期key处理</h4><p>slave不会过期key，只会等待master过期key。</p>\n<p>如果master过期了一个key，或者通过LRU淘汰了一个key，master会模拟一条del命令发送给slave。</p>\n<h4 id=\"redis的心跳检测机制\"><a href=\"#redis的心跳检测机制\" class=\"headerlink\" title=\"redis的心跳检测机制\"></a>redis的心跳检测机制</h4><p>在命令传播阶段，slave每隔一秒向master发送一个心跳，主要用来检测双方的网络连接状态。</p>\n<h4 id=\"redis的持久化\"><a href=\"#redis的持久化\" class=\"headerlink\" title=\"redis的持久化\"></a>redis的持久化</h4><p>如果采用了主从架构，建议必须开启master node的持久化。</p>\n<p>不建议用slave node作为master node的热备，因为那样的话如果关掉master的持久化（RDB和AOF都关闭）可能在master宕机重启的时候数据是空的，然后从节点一复制，slave node的数据也丢了。</p>\n<p>即使slave node可以自动接管master node，也可能哨兵还没有检测到master failure，master node就重启了，还是可能导致上面的所有slave node数据被清空的故障。</p>\n<p><strong>持久化方式RDB和AOF</strong></p>\n<ul>\n<li>RDB持久化机制：通过快照的方式，对redis中的数据进行周期性的持久化。</li>\n<li>AOF持久化机制：通过记录写命令，以append-only模式写入到日志文件中，redis重启时重新构建。</li>\n</ul>\n<p>如果同时开启了RDB和AOF两种持久化机制，在redis重启时会使用AOF来构建数据，因为AOF数据更加完整。</p>\n<p>如果我们想要redis仅仅作为纯内存的缓存来用，可以关掉RDB和AOF持久化机制。</p>\n<p><strong>RDB的优点</strong></p>\n<ol>\n<li>RDB会生成多个数据文件，非常适合做冷备，可以上传到云盘定期维护。</li>\n<li>RDB对redis的性能影响非常小，定期把数据写入到磁盘，使redis保持高性能。</li>\n<li>通过RDB数据文件来做数据恢复更加快速，直接把文件加载到内存即可。</li>\n</ol>\n<p><strong>RDB的缺点</strong></p>\n<ol>\n<li>最大的缺点就是可能造成部分数据丢失。由于RDB是定期备份，可能每隔5分钟甚至更久，如果redis突然宕机，可能会丢失部分数据，所以RDB不适合作为第一优先的恢复方案。</li>\n<li>RDB每次执行快照生成数据文件的时候，如果数据文件特别大，可能会导致redis对客户提供的服务暂停数秒，所以不要让RDB备份的间隔太长，否则每次生成的文件太大，影响redis本身的性能。</li>\n</ol>\n<p><strong>AOF的优点</strong></p>\n<ol>\n<li>AOF可以更好的保护数据不丢失，一般AOF会每隔一秒记录一次，所以最多丢失1秒的数据。</li>\n<li>AOF日志以append-only模式写入，没有磁盘寻址开销，写入性能高，且文件不易破损。</li>\n<li>AOF日志文件过大的时候，出现后台重写操作也不会影响reids客户端的读写效率。</li>\n<li>AOF特别合适误删除的紧急恢复，比如输入了flushall清空了数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall删除，然后再将AOF文件放回去，就可以自动恢复。</li>\n</ol>\n<p><strong>AOF的缺点</strong></p>\n<ol>\n<li>最大的缺点就是做数据恢复的时候会比较慢，做冷备和定期备份不方便，需要手写复杂脚本。</li>\n<li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。</li>\n<li>AOF开启后，支持的QPS会比RDB低，因为每秒一次fsync，不过性能还是很高的。</li>\n<li>如果想保证一条数据都不丢，也是可以的，设置成每写入一条数据就fsync一次，不过性能会大降。</li>\n<li>AOF相比于RDB更加脆弱一些，恢复数据后可能导致跟原来不一样，容易产生bug。</li>\n</ol>\n<p><strong>RDB和AOF到底如何选择</strong></p>\n<ul>\n<li>不要仅仅使用RDB，因为那样会导致丢失很多数据。</li>\n<li>也不要仅仅使用AOF，因为AOF不适合做冷备，恢复数据比较慢还容易产生bug。</li>\n<li>所以综合使用AOF和RDB两种持久化机制，用AOF保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或者损坏不可用的时候，还可以使用RDB快照来进行数据恢复。</li>\n</ul>\n<hr>\n<h3 id=\"redis的哨兵机制\"><a href=\"#redis的哨兵机制\" class=\"headerlink\" title=\"redis的哨兵机制\"></a>redis的哨兵机制</h3><p>sentinal，中文名是哨兵，是redis集群架构中非常重要的一个组件，主要功能如下：</p>\n<ol>\n<li>集群监控：负责监控redis master和slave进程是否正常工作。</li>\n<li>消息通知：如果某个redis实例有故障，哨兵负责发送消息给管理员报警。</li>\n<li>故障转移：如果master挂掉了，会自动转移到slave上。</li>\n<li>配置中心：如果故障转移发生了，把新的master地址通知到客户端。</li>\n</ol>\n<p>哨兵本身也是分布式的，作为一个哨兵集群在运行，互相协同工作。</p>\n<ol>\n<li>故障转移时，判断一个master是否宕机，需要大部分的哨兵同意才行，涉及到分布式选举。</li>\n<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，保证了系统的高可用性。</li>\n</ol>\n<h4 id=\"哨兵的核心知识\"><a href=\"#哨兵的核心知识\" class=\"headerlink\" title=\"哨兵的核心知识\"></a>哨兵的核心知识</h4><ol>\n<li>哨兵至少需要3个实例，来保证自己的健壮性。</li>\n<li>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用。</li>\n<li>对于哨兵+redis主从的复杂架构，尽量在测试和生产环境都进行充足的测试和演练。</li>\n</ol>\n<p><strong>为什么redis哨兵集群少于3个节点无法正常工作</strong></p>\n<p>如果哨兵集群只有两个节点，两个哨兵的majority=2，其中master所在的机器宕机了，这时只剩下一个哨兵，哨兵切换故障需要满足大多数哨兵同意原则，此时没有majority来运行执行故障转移，所以两个哨兵节点不能工作。</p>\n<h4 id=\"sdown和odown转换机制？\"><a href=\"#sdown和odown转换机制？\" class=\"headerlink\" title=\"sdown和odown转换机制？\"></a>sdown和odown转换机制？</h4><p>master宕机有sdown和odown两种失败状态</p>\n<ul>\n<li>sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，就是主观宕机。</li>\n<li>odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，就是客观宕机。</li>\n<li>sdown达成的条件很简单，如果一个哨兵ping一个master，超过了is-master-after-milliseconds指定的毫秒数之后，就主观认为master宕机了</li>\n<li>sdown到odown的转换条件也很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，也就是客观认为master宕机。</li>\n</ul>\n<h4 id=\"哨兵和slave集群的自动发现机制\"><a href=\"#哨兵和slave集群的自动发现机制\" class=\"headerlink\" title=\"哨兵和slave集群的自动发现机制\"></a>哨兵和slave集群的自动发现机制</h4><p>哨兵互相之间的发现，是通过redis的pub/sub系统实现的，每个哨兵都会往_sentinel_:hello channel里发送一个消息，内容是自己的host、ip和runid，还有对这个master的监控配置。每个哨兵也会去监听自己监控的master+slave对应的_sentinel_:hello channel，然后去感到到同样在监听这个master+slave的其他哨兵的存在，每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。</p>\n<h4 id=\"slave-master选举算法\"><a href=\"#slave-master选举算法\" class=\"headerlink\" title=\"slave-master选举算法\"></a>slave-master选举算法</h4><p>如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来准备升级为master。</p>\n<p><strong>从节点过滤</strong>：判断跟master断开连接的时长</p>\n<p>如果一个slave跟master断开连接已经超过了（down-after-milliseconds的10倍+master宕机的时长），那么slave就被认为不适合选举为master。</p>\n<ol>\n<li>slave配置的优先级（slave-priority=100）</li>\n<li>复制offset</li>\n<li>run id</li>\n</ol>\n<p>说明：</p>\n<ol>\n<li>然后把剩下了的slave按照优先级进行排序，slave priority越低，优先级就越高。</li>\n<li>如果slave priority相同，就看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。</li>\n<li>如果上面两个条件都相同，那么选择一个run id比较小的那个slave。</li>\n</ol>\n<h4 id=\"slave配置的自动纠正\"><a href=\"#slave配置的自动纠正\" class=\"headerlink\" title=\"slave配置的自动纠正\"></a>slave配置的自动纠正</h4><p>哨兵会自动纠正slave的配置信息。比如某台slave要成为潜在的master候选人，哨兵会确保slave在复制现有的master数据；如果slave连接到了一个错误的master上，比如故障转移后，哨兵会确保它们连接到正确的master上。</p>\n<h4 id=\"quorum和majority\"><a href=\"#quorum和majority\" class=\"headerlink\" title=\"quorum和majority\"></a>quorum和majority</h4><p>每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还要得到majority哨兵的授权，才能正式执行切换。</p>\n<p>如果quorum &lt; majority，比如5个哨兵，majority就是3，quorum设置为2，可以执行切换。</p>\n<p>如果quorum &gt;= majority，比如5个哨兵，设置quorum是5，那么必须5个哨兵都授权才能切换。</p>\n<h4 id=\"configuration-epoch\"><a href=\"#configuration-epoch\" class=\"headerlink\" title=\"configuration epoch\"></a>configuration epoch</h4><p>哨兵进行切换之前，执行切换的那个哨兵从要切换到新的master那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。如果第一次master切换失败了，那么其他哨兵会等待failover-timeout时间，然后继续执行切换，此时会重新获得一个新的configuration epoch，作为新的version号。</p>\n<h4 id=\"configuration传播\"><a href=\"#configuration传播\" class=\"headerlink\" title=\"configuration传播\"></a>configuration传播</h4><p>哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他哨兵，通过pub/sub消息机制。</p>\n<p>这里version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置。</p>\n<hr>\n<h2 id=\"异步复制和集群脑裂导致数据丢失\"><a href=\"#异步复制和集群脑裂导致数据丢失\" class=\"headerlink\" title=\"异步复制和集群脑裂导致数据丢失\"></a>异步复制和集群脑裂导致数据丢失</h2><p>场景一：异步复制导致的数据丢失</p>\n<p>client往redis master写入数据，master还没来得及复制给slave，此时，master宕机了，哨兵检测到master宕机后，从slave中投票选举出新的master，但是没来得及复制的数据就丢失了。</p>\n<p>场景二：集群脑裂导致的数据丢失</p>\n<p>master出现了网络异常，与其他slave节点失去联系，但没有挂掉，其他slave节点上的哨兵机制重新选举了master，不过此时的client跟旧的master网络是好的，发送了数据到旧的master数据没有得到同步，此时检测到该master有问题，修好网络后作为slave挂在到新的master节点上，但是新的master没有同步网络异常时的数据导致丢失。</p>\n<p><strong>如何降低损失？</strong></p>\n<ul>\n<li>min-slaves-to-write 1</li>\n<li>min-slaves-max-lag 10</li>\n</ul>\n<p>配置说明：要求至少有一个slave，数据复制和同步的延迟不能超过10秒。也就是说一旦所有的slave数据的复制和同步都超过了10秒，这时master就不会再接收写请求了，可以把数据落差保持在可控范围内，减少数据损失。</p>\n<p>上述配置也适合脑裂，master发生脑裂以后，所有slave都不向旧的master发送数据，10秒之后旧master停止接收写请求，同样也可以减少脑裂带来的数据丢失。</p>\n<hr>\n<h2 id=\"分布式集群-redis-cluster\"><a href=\"#分布式集群-redis-cluster\" class=\"headerlink\" title=\"分布式集群-redis cluster\"></a>分布式集群-redis cluster</h2><ol>\n<li>自动将数据进行分片，每个master上放一部分数据。</li>\n<li>提供内置的高可用支持，部分master不可用时，还是可以继续工作的。</li>\n</ol>\n<p>redis cluster可以突破单机redis在海量数据面前的瓶颈。</p>\n<p><strong>redis cluster VS replication+sentinal</strong></p>\n<p>如果数据量很少，只有几个G，主要是承载高并发性能的场景，那么单机足够了。采用主从架构，再搭建一个sentinal集群，保证高可用。如果你的数据量很大，建议使用redis cluster。</p>\n<h3 id=\"分布式数据存储的核心算法\"><a href=\"#分布式数据存储的核心算法\" class=\"headerlink\" title=\"分布式数据存储的核心算法\"></a>分布式数据存储的核心算法</h3><h4 id=\"最老土的hash算法和弊端\"><a href=\"#最老土的hash算法和弊端\" class=\"headerlink\" title=\"最老土的hash算法和弊端\"></a>最老土的hash算法和弊端</h4><p>把请求的数据进行hash运算，对hash值取模（针对master数量）然后放入对应的master节点中，如果某台master宕机了，该节点中的缓存数据就会失效，更严重的是由于master数量少了，导致取模方式改变，新的请求通过取模运算后得不到有效缓存，会造成几乎100%的请求涌入数据库重新生成缓存，这里会涉及到<strong>大量的缓存重建</strong>，这是致命的。</p>\n<h4 id=\"一致性hash算法-自动缓存迁移\"><a href=\"#一致性hash算法-自动缓存迁移\" class=\"headerlink\" title=\"一致性hash算法(自动缓存迁移)\"></a>一致性hash算法(自动缓存迁移)</h4><p>有请求过来以后，同样是把key进行hash运算，然后会把hash值对应在圆环的各个点上，key落在圆环上以后就会顺时针旋转去寻找距离自己最近的master节点，如果任何一个master节点宕机，只有在该master上的缓存会失效，比如有3台master节点，宕机一台，1/3的数据流量会瞬间涌入数据库，重新查询一次，在环上的master节点越多，宕机后失效的数据越少。这只是均匀分布的情况，如有区间存在缓存热点，还是会有弊端。</p>\n<h4 id=\"一致性hash算法-虚拟节点\"><a href=\"#一致性hash算法-虚拟节点\" class=\"headerlink\" title=\"一致性hash算法+虚拟节点\"></a>一致性hash算法+虚拟节点</h4><p>基于一致性hash算法，在各个master节点之间，再创建均匀分布的虚拟节点，在每个区间内，大量的数据都会均匀的分布到不同的节点，不会存在大量的缓存顺时针同时融入一个master内，实现了自动的<strong>负载均衡</strong>。</p>\n<h4 id=\"hash-slot算法\"><a href=\"#hash-slot算法\" class=\"headerlink\" title=\"hash slot算法\"></a>hash slot算法</h4><p>redis cluster有固定的16384个哈希槽，对每个key计算CRC16的值，然后对16384取模，注意不是对机器取模，所以即使有任何一台机器宕机，其他master中的缓存是不受影响的，经过短暂的数据迁移后，会把宕机中的缓存数据均匀分布到其他的master中继续提供服务。而且master slot让node的增加和移除变得很简单，只需要针对机器的个数均匀分配16384个哈希槽就可以了。</p>\n<hr>\n<h3 id=\"redis集群模式的工作原理\"><a href=\"#redis集群模式的工作原理\" class=\"headerlink\" title=\"redis集群模式的工作原理\"></a>redis集群模式的工作原理</h3><h4 id=\"节点间的内部通信机制\"><a href=\"#节点间的内部通信机制\" class=\"headerlink\" title=\"节点间的内部通信机制\"></a>节点间的内部通信机制</h4><p><strong>基础通信原理</strong></p>\n<p>redis cluster节点间采用<strong>gossip</strong>协议进行通信。</p>\n<p>跟集中式不同，不是将元数据（节点信息、故障等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的。</p>\n<ul>\n<li>集中式：好处在于，元数据的更新和读取的时效性非常好，一旦有变更，其他节点立刻就能感知到。缺点是所有的元数据的更新全部集中在一个地方，可能导致元数据的存储压力。</li>\n<li>gossip：好处在于，元数据的更新比较分散，更新请求会陆陆续续的打到所有节点上去更新，降低了压力。缺点是元数据的更新有一定的延迟，可能导致集群的一些操作滞后。</li>\n</ul>\n<p>10000端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口，每个节点每隔一段时间都会往另外几个节点发送ping信息，收到后返回pong。通过通信端口结合gossip协议相互交换信息，包括故障信息、节点的增加和删除、hash slot信息等等。</p>\n<p><strong>gossip协议</strong></p>\n<p>gossip协议包含多种消息，包括ping、pong、meet、fail等。</p>\n<ul>\n<li>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始和其他节点进行通信。</li>\n<li>ping：每个节点都会频繁的给其他节点发送ping，其中包含自己的状态还有自己维护集群的元数据，互相通过ping进行元数据的交换和更新。</li>\n<li>pong：返回ping和meet，包含自己的状态和其他信息，也可以用于广播和更新。</li>\n<li>fail：某个节点判断另一个节点fail后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</li>\n</ul>\n<p><strong>ping消息深入</strong></p>\n<p>每个节点每秒会执行10次ping，每次会选择5个最久没有通信的其他节点。如果发现某个节点通信延时达到了cluster_node_timeout，就会立即发送ping，避免数据交换延迟过长。所以cluster_node_timeout可以调节，如果调节比较大，就可以降低发送的频率。每次ping需要带上自己的节点信息，还有就是带上1/10的其他节点信息，发送出去，进行数据交换。至少包含3个其他节点的信息，最多包含（总节点-2）个其他节点信息。</p>\n<hr>\n<p>jedis的运行原理：重定向，计算hash slot，采用smart jedis，在本地维护了一个hash slot -&gt; node的映射表缓存。</p>\n<h4 id=\"高性能与主备切换原理\"><a href=\"#高性能与主备切换原理\" class=\"headerlink\" title=\"高性能与主备切换原理\"></a>高性能与主备切换原理</h4><p>redis cluster的高可用原理，几乎和哨兵是一样的。</p>\n<ol>\n<li><p>判断节点宕机</p>\n<p>如果一个节点认为另外一个节点宕机了，就是pfail，主观宕机。如果多个节点都认为另外一个节点pfail了，那么就是客观宕机fail。节点之间把pfail放在gossip ping中进行通信，超过半数认为pfail就是fail。</p>\n</li>\n<li><p>从节点过滤</p>\n<p>对于宕机的master，从其所有的从节点slave中选择一个切换成master，检查每个slave与宕机的master断开连接的时间，如果超过了（cluster-node-timeout * cluster-slave-validity-factor）将失去选举资格。</p>\n</li>\n<li><p>master选举</p>\n<p>每个从节点都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多），选举时间越靠前，优先进行选举。然后开始进行投票，具体过程和哨兵类似，选举通过成为新的master。</p>\n</li>\n</ol>\n<p>综上所述：redis cluster功能强大，直接集成了replication和sentinal的功能。</p>\n<hr>\n<h2 id=\"缓存雪崩、缓存穿透、缓存击穿\"><a href=\"#缓存雪崩、缓存穿透、缓存击穿\" class=\"headerlink\" title=\"缓存雪崩、缓存穿透、缓存击穿\"></a>缓存雪崩、缓存穿透、缓存击穿</h2><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>定义：指在某一时间段，缓存集体失效。</p>\n<h4 id=\"造成缓存雪崩的原因\"><a href=\"#造成缓存雪崩的原因\" class=\"headerlink\" title=\"造成缓存雪崩的原因\"></a>造成缓存雪崩的原因</h4><ol>\n<li>比如双11零点抢购，大量商品被集中放入到缓存，假设缓存时效为一小时，那么到了凌晨1点的时候缓存就集体失效了，大量的请求会打在数据库上，对数据库来说，就会产生周期性的压力波峰，可能造成缓存雪崩。</li>\n<li>缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</li>\n</ol>\n<h4 id=\"如何预防缓存雪崩？\"><a href=\"#如何预防缓存雪崩？\" class=\"headerlink\" title=\"如何预防缓存雪崩？\"></a>如何预防缓存雪崩？</h4><p>针对缓存集体失效：如果是电商项目，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。</p>\n<p>针对缓存服务器宕机：redis高可用（主从+哨兵 或者 redis cluster），避免全盘奔溃。</p>\n<h4 id=\"缓存雪崩了如何恢复？\"><a href=\"#缓存雪崩了如何恢复？\" class=\"headerlink\" title=\"缓存雪崩了如何恢复？\"></a>缓存雪崩了如何恢复？</h4><p>本地ehcache缓存+hystrix限流&amp;降级，避免mysql被打死。事后通过redis持久化快速恢复缓存数据。</p>\n<hr>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>定义：是指查询一个数据库一定不存在的数据，请求穿过了缓存，直接打在了数据库。</p>\n<h4 id=\"造成缓存穿透的原因\"><a href=\"#造成缓存穿透的原因\" class=\"headerlink\" title=\"造成缓存穿透的原因\"></a>造成缓存穿透的原因</h4><p>代码bug或者恶意攻击。</p>\n<h4 id=\"如何预防缓存穿透？\"><a href=\"#如何预防缓存穿透？\" class=\"headerlink\" title=\"如何预防缓存穿透？\"></a>如何预防缓存穿透？</h4><p>如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。</p>\n<hr>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>定义：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n<h3 id=\"如何预防缓存击穿？\"><a href=\"#如何预防缓存击穿？\" class=\"headerlink\" title=\"如何预防缓存击穿？\"></a>如何预防缓存击穿？</h3><p>这种情况遇到的比较少，真有这种爆款key，设置成永不过期就可以了。</p>\n<hr>\n<h2 id=\"如何保证缓存与数据库的双写一致性\"><a href=\"#如何保证缓存与数据库的双写一致性\" class=\"headerlink\" title=\"如何保证缓存与数据库的双写一致性\"></a>如何保证缓存与数据库的双写一致性</h2><h3 id=\"先删缓存，再更新数据库\"><a href=\"#先删缓存，再更新数据库\" class=\"headerlink\" title=\"先删缓存，再更新数据库\"></a>先删缓存，再更新数据库</h3><p>最经典的缓存+数据库读写的模式：暂存模式（cache aside pattern）</p>\n<ol>\n<li>读的时候先读缓存，缓存没有的话就读数据库，然后把数据库的数据放到缓存，同时返回相应。</li>\n<li>更新的时候，<strong>先删除缓存，再更新数据库</strong>，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，不会造成不一致，因为读的时候缓存中没有，还会把旧的数据库数据更新到缓存中。反过来，如果先更改数据库再删除缓存，如果缓存删除失败了，则会导致数据不一致。</li>\n</ol>\n<p>为什么是删除缓存，而不是更新缓存呢？</p>\n<p>原因很简单，很多时候复杂点的缓存场景，不单单是修改了一个值那么简单，而是需要结合多张表去计算才能得到缓存结果，就算真的是简单场景的缓存，也需要看看这个缓存是不是被频繁的使用到，否则只是增加麻烦而已。</p>\n<p>其实删除缓存就是一个lazy计算的思想，不需要每次都做复杂的运算，它被用到的时候再计算就好了。</p>\n<hr>\n<h3 id=\"高并发场景下的数据不一致\"><a href=\"#高并发场景下的数据不一致\" class=\"headerlink\" title=\"高并发场景下的数据不一致\"></a>高并发场景下的数据不一致</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没有修改，一个请求过来，去读缓存，发现缓存空了，去查询数据库，把旧的数据放到了缓存中，然后数据库完成了修改，此时数据库和缓存的数据不一致了。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>把数据库与缓存的更新读取操作进行异步串行化。</p>\n<ul>\n<li>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个内存队列中。</li>\n<li>读取数据的时候，如果发现数据不在缓存中，那么将进行（重新读取+更新缓存）操作，也根据唯一标识路由并发送到同一个内存队列中。</li>\n</ul>\n<p>一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。</p>\n<p>这样的话，一个数据变更的操作，先删除缓存，然后去更新数据库，但是还没有完成更新；此时如果一个读请求过来，读到了空的缓存，可以先将缓存更新的请求发送到队列中积压，然后同步等待缓存更新完成。</p>\n<p>这里有一个优化点，一个队列中，多个读请求（更新缓存）串在一起是没有意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，就不用再放更新操作进入队列了，直接等待前面的缓存更新完成即可。如果请求还在等待范围内，不断轮询发现可以取到值了就返回，超过等待时长就返回数据库中的旧值。</p>\n<h4 id=\"解决方案需要注意的问题\"><a href=\"#解决方案需要注意的问题\" class=\"headerlink\" title=\"解决方案需要注意的问题\"></a>解决方案需要注意的问题</h4><p><strong>读请求 长时间堵塞</strong></p>\n<p>由于读请求做了非常轻度的异步化，所以一定要注意读超时问题，每个读请求必须在超时时间范围内返回。</p>\n<p>该方案的最大风险在于可能数据更新很频繁，或者包含了对多个数据项的修改，导致队列中积压了大量的更新操作在里面，然后读请求发生了大量的超时，最后导致大量的读请求直接走数据库。一定要提前做好压力测试和真实数据模拟，不过一般来说数据的写频率是很低的，所以队列中积压的应该不会太多。如果真的导致积压过多的话，可以采取增加内存队列的方式来解决。</p>\n<p><strong>读请求 并发量过高</strong></p>\n<p>上述方案有可能突然大量的读请求在几十毫秒内hang在服务器上，看需要几台服务器才能扛得住，所以要计算好每个读请求不要hang太久。</p>\n<p><strong>多服务实例部署的请求路由</strong></p>\n<p>可能这个服务部署了多个实例，那么必须保证，执行数据更新操作以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务器实例上。</p>\n<p><strong>热点商品的路由问题</strong></p>\n<p>万一某个商品的读写请求特别高，全部打到相同的机器的相同队列里去了，可能造成某台机器的压力过大。</p>\n<p>因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题影响不是很大，不过的缺可能某些机器的负载高一些。</p>\n<hr>\n<h2 id=\"如何保证redis并发竞争的数据一致性\"><a href=\"#如何保证redis并发竞争的数据一致性\" class=\"headerlink\" title=\"如何保证redis并发竞争的数据一致性\"></a>如何保证redis并发竞争的数据一致性</h2><p>客户端角度：为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p>\n<p>服务器角度：采用分布式锁，确保同一时刻只能有一个系统实例在操作某个key，获得分布式锁以后，每次要写之前，先判断当前这个value的时间戳是否比缓存中的时间戳更新，如果更新，可以写入；否则，就不能用旧数据覆盖新数据。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"redis单线程模型原理剖析？\"><a href=\"#redis单线程模型原理剖析？\" class=\"headerlink\" title=\"redis单线程模型原理剖析？\"></a>redis单线程模型原理剖析？</h2><p>redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。</p>\n<h2 id=\"redis为什么这么快？\"><a href=\"#redis为什么这么快？\" class=\"headerlink\" title=\"redis为什么这么快？\"></a>redis为什么这么快？</h2><ol>\n<li>纯内存操作。</li>\n<li>核心是基于非阻塞的IO多路复用机制。</li>\n<li>单线程——避免了多线程的频繁上下文切换问题。</li>\n<li>Resp协议。","more":"</li>\n</ol>\n<h2 id=\"使用redis有什么缺点？\"><a href=\"#使用redis有什么缺点？\" class=\"headerlink\" title=\"使用redis有什么缺点？\"></a>使用redis有什么缺点？</h2><ul>\n<li>缓存和数据库双写一致性问题</li>\n<li>缓存雪崩、缓存击穿</li>\n<li>缓存的并发竞争</li>\n</ul>\n<h2 id=\"redis支持的数据类型和使用场景\"><a href=\"#redis支持的数据类型和使用场景\" class=\"headerlink\" title=\"redis支持的数据类型和使用场景\"></a>redis支持的数据类型和使用场景</h2><ol>\n<li><p>string</p>\n<p>最基本的类型，普通的set和get，做简单的key-value缓存。</p>\n</li>\n<li><p>hash</p>\n<p>类似map的一种结构，特别适合用存储对象，可以仅仅修改这个对象中的某个字段。</p>\n</li>\n<li><p>list</p>\n<p>有序列表，这个是可以玩出很多花样的：</p>\n<p>比如可以基于redis的list实现简单的高性能分页，类似于微博的那种一直下拉。</p>\n<p>还可以搞个简单的消息队列，从list头进去，从list尾巴取出来。</p>\n</li>\n<li><p>set</p>\n<p>无序集合，自动去重。</p>\n<p>如果某个系统部署在多台机器上，可以基于redis实现全局的set去重。</p>\n<p>还可以基于set玩交集，并集，差集的操作，比如利用交集，可以查看两个人的粉丝列表中的共同好友。</p>\n</li>\n<li><p>sorted set</p>\n<p>有序集合，自动去重。</p>\n<p>这个也可以玩很多花样，写数据进去的时候给一个分数，自动根据分数排序，可以自定义排序规则。</p>\n<p>比如想根据数据的时间排序，那么在写入数据的时候把时间作为分数，这样就会按时间排序了。</p>\n<p>排行榜：将每个用户以及对应的分数写入进去，会自动排序，可以查看前几名的结果。</p>\n<p>zadd board 85 jack</p>\n<p>zadd board 72 tom</p>\n<p>zadd board 96 jerry</p>\n<p>zrevrange board 0 2：可以查看前三名的排序结果</p>\n<p>zrank board tom：返回3，意思是tom排名第3</p>\n</li>\n</ol>\n<hr>\n<h2 id=\"redis的过期策略有哪些\"><a href=\"#redis的过期策略有哪些\" class=\"headerlink\" title=\"redis的过期策略有哪些\"></a>redis的过期策略有哪些</h2><p><strong>定期删除+惰性删除</strong></p>\n<p>所谓<strong>定期删除</strong>，指的是redis默认每隔100ms就随机抽取一些过期时间的key，检测是否过期，如果过期就删除。注意：这里redis不是遍历所有过期的key（CPU负载太高），而是随机抽取。</p>\n<p>所谓<strong>惰性删除</strong>，指的是定期删除可能会导致很多过期的key到了时间也没被删除，所以在获取某个key的时候，redis会查一下这个key是否过期，如果过期了此时就会删除，不会返回结果。</p>\n<p>产生问题：如果定期删除漏掉了很多过期key没删，惰性删除是用到的时候才删，如果过期了并且一直没用到就会导致有大量的过期key堆积，这时候就需要走<strong>内存淘汰机制</strong>了。</p>\n<ol>\n<li>no-enviction（驱逐）：禁止驱逐数据，再写入会报错。<strong>（默认，应该没人用）</strong></li>\n<li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。<strong>（推荐使用）</strong></li>\n<li>allkeys-random：从数据集中任意选择数据淘汰。</li>\n<li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li>\n<li>volatile-ttl：从<code>已设置过期时间的</code>数据集中挑选<code>将要过期的</code>数据淘汰。</li>\n<li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li>\n</ol>\n<hr>\n<h2 id=\"怎么保证redis的高并发-amp-高可用？\"><a href=\"#怎么保证redis的高并发-amp-高可用？\" class=\"headerlink\" title=\"怎么保证redis的高并发&amp;高可用？\"></a>怎么保证redis的高并发&amp;高可用？</h2><p>redis高并发：采用<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒上10万的QPS。如果redis高并发的同时还需要容纳大量的数据：几十G甚至几百G的数据，这样的话就需要采用redis集群了，还能提供每秒几十万的读写并发。</p>\n<p>redis高可用：如果做主从架构部署，其实加上<strong>哨兵</strong>就可以了，任何一个实例宕机，都会自动切换。</p>\n<h3 id=\"redis的主从复制\"><a href=\"#redis的主从复制\" class=\"headerlink\" title=\"redis的主从复制\"></a>redis的主从复制</h3><p>主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑10+的<strong>读QPS</strong></p>\n<p>首先考虑读写分离，做成主从架构，一主多从，主负责写，并且将数据同步到其他slave节点，从节点负责读，所有的读请求都走从节点。好处是可以水平扩容，就是说如果QPS再增加，只需要继续增加slave就可以了。 </p>\n<h4 id=\"主从复制的核心原理\"><a href=\"#主从复制的核心原理\" class=\"headerlink\" title=\"主从复制的核心原理\"></a>主从复制的核心原理</h4><p>当启动一个slave的时候，该节点会发送一个PSYNC命令给master，如果这是slave的重新连接，master仅仅会发送给slave部分缺少的数据进行<strong>增量复制</strong>，如果这是slave第一次连接master，会触发一次<strong>全量复制</strong>。</p>\n<p>官方解释：</p>\n<ol>\n<li>slave启动时，仅仅保存master的host和ip（redis.conf中配置的），此时复制流程还没开始。</li>\n<li>slave内部有个定时任务，每秒都会check是否有新的master要连接和复制，如果发现则建立网络连接。</li>\n<li>slave发送ping给master，如果master配置了requirepass，那么slave必须发送masterauth口令过去认证。</li>\n<li>master第一次执行全量复制，将所有数据发送给slave。</li>\n<li>master后续还会持续将写命令异步发送给slave。</li>\n</ol>\n<p>全量复制：开始full resynchronized的时候，master会启动一个后台线程，生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕以后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送给slave，slave来同步这些数据。</p>\n<p>增量复制：master根据slave发送的psync中的offset，在backlog中查找到部分丢失的数据，发送给slave。</p>\n<h4 id=\"主从复制的断点续传\"><a href=\"#主从复制的断点续传\" class=\"headerlink\" title=\"主从复制的断点续传\"></a>主从复制的断点续传</h4><p>从redis2.8开始就支持主从复制的断点续传了。在主从复制过程中，如果网络连接断掉了，可以接着上次复制的地方继续复制，而不是重新开始复制。master会在内存中维护一个backlog，master和slave都会保存一个复制数据的replica offset和一个master run id，offset就是保存在backlog中的。如果master和slave网络中断了，slave会让master从上次的replica offset开始继续复制。但是如果没有找到对应的offset，那么就会执行一次resynchronized。</p>\n<p>官方解释：</p>\n<ol>\n<li>master和slave都会维护一个offset，slave每秒都会上报自己的offect给master，master记录在backlog中，这样才能知道双方数据是否一致。</li>\n<li>master还会维护一个backlog文件，默认是1M大小，给slave复制数据时也会记录在backlog中，主要是用来做全量复制中断后的增量复制的。</li>\n<li>master重启或者加载了之前的RDB数据是会变的，run id也会变，所以slave需要根据不同的run id区分，如果run id不同就需要做全量复制。</li>\n<li>从节点使用psync从master进行复制，发送psync runid offset到master。master会根据自身的情况返回相应的信息，可能是FULLRESYNC runid offset触发全量复制，也可能是CONTINUE触发增量复制。</li>\n</ol>\n<h4 id=\"无磁盘化复制\"><a href=\"#无磁盘化复制\" class=\"headerlink\" title=\"无磁盘化复制\"></a>无磁盘化复制</h4><p>在redis的配置文件中开启无磁盘化复制以后，master会在内存中直接创建rdb文件然后发送给slave，不会保存在本地磁盘。这里不建议开启，开启也很简单，主要涉及到两个参数：repl-diskless-sync no 默认是no，改成yes就可以了，repl-diskless-sync-delay 5 默认是延迟5s在开始复制，因为需要等待更多的slave重新连接。</p>\n<h4 id=\"过期key处理\"><a href=\"#过期key处理\" class=\"headerlink\" title=\"过期key处理\"></a>过期key处理</h4><p>slave不会过期key，只会等待master过期key。</p>\n<p>如果master过期了一个key，或者通过LRU淘汰了一个key，master会模拟一条del命令发送给slave。</p>\n<h4 id=\"redis的心跳检测机制\"><a href=\"#redis的心跳检测机制\" class=\"headerlink\" title=\"redis的心跳检测机制\"></a>redis的心跳检测机制</h4><p>在命令传播阶段，slave每隔一秒向master发送一个心跳，主要用来检测双方的网络连接状态。</p>\n<h4 id=\"redis的持久化\"><a href=\"#redis的持久化\" class=\"headerlink\" title=\"redis的持久化\"></a>redis的持久化</h4><p>如果采用了主从架构，建议必须开启master node的持久化。</p>\n<p>不建议用slave node作为master node的热备，因为那样的话如果关掉master的持久化（RDB和AOF都关闭）可能在master宕机重启的时候数据是空的，然后从节点一复制，slave node的数据也丢了。</p>\n<p>即使slave node可以自动接管master node，也可能哨兵还没有检测到master failure，master node就重启了，还是可能导致上面的所有slave node数据被清空的故障。</p>\n<p><strong>持久化方式RDB和AOF</strong></p>\n<ul>\n<li>RDB持久化机制：通过快照的方式，对redis中的数据进行周期性的持久化。</li>\n<li>AOF持久化机制：通过记录写命令，以append-only模式写入到日志文件中，redis重启时重新构建。</li>\n</ul>\n<p>如果同时开启了RDB和AOF两种持久化机制，在redis重启时会使用AOF来构建数据，因为AOF数据更加完整。</p>\n<p>如果我们想要redis仅仅作为纯内存的缓存来用，可以关掉RDB和AOF持久化机制。</p>\n<p><strong>RDB的优点</strong></p>\n<ol>\n<li>RDB会生成多个数据文件，非常适合做冷备，可以上传到云盘定期维护。</li>\n<li>RDB对redis的性能影响非常小，定期把数据写入到磁盘，使redis保持高性能。</li>\n<li>通过RDB数据文件来做数据恢复更加快速，直接把文件加载到内存即可。</li>\n</ol>\n<p><strong>RDB的缺点</strong></p>\n<ol>\n<li>最大的缺点就是可能造成部分数据丢失。由于RDB是定期备份，可能每隔5分钟甚至更久，如果redis突然宕机，可能会丢失部分数据，所以RDB不适合作为第一优先的恢复方案。</li>\n<li>RDB每次执行快照生成数据文件的时候，如果数据文件特别大，可能会导致redis对客户提供的服务暂停数秒，所以不要让RDB备份的间隔太长，否则每次生成的文件太大，影响redis本身的性能。</li>\n</ol>\n<p><strong>AOF的优点</strong></p>\n<ol>\n<li>AOF可以更好的保护数据不丢失，一般AOF会每隔一秒记录一次，所以最多丢失1秒的数据。</li>\n<li>AOF日志以append-only模式写入，没有磁盘寻址开销，写入性能高，且文件不易破损。</li>\n<li>AOF日志文件过大的时候，出现后台重写操作也不会影响reids客户端的读写效率。</li>\n<li>AOF特别合适误删除的紧急恢复，比如输入了flushall清空了数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall删除，然后再将AOF文件放回去，就可以自动恢复。</li>\n</ol>\n<p><strong>AOF的缺点</strong></p>\n<ol>\n<li>最大的缺点就是做数据恢复的时候会比较慢，做冷备和定期备份不方便，需要手写复杂脚本。</li>\n<li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。</li>\n<li>AOF开启后，支持的QPS会比RDB低，因为每秒一次fsync，不过性能还是很高的。</li>\n<li>如果想保证一条数据都不丢，也是可以的，设置成每写入一条数据就fsync一次，不过性能会大降。</li>\n<li>AOF相比于RDB更加脆弱一些，恢复数据后可能导致跟原来不一样，容易产生bug。</li>\n</ol>\n<p><strong>RDB和AOF到底如何选择</strong></p>\n<ul>\n<li>不要仅仅使用RDB，因为那样会导致丢失很多数据。</li>\n<li>也不要仅仅使用AOF，因为AOF不适合做冷备，恢复数据比较慢还容易产生bug。</li>\n<li>所以综合使用AOF和RDB两种持久化机制，用AOF保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或者损坏不可用的时候，还可以使用RDB快照来进行数据恢复。</li>\n</ul>\n<hr>\n<h3 id=\"redis的哨兵机制\"><a href=\"#redis的哨兵机制\" class=\"headerlink\" title=\"redis的哨兵机制\"></a>redis的哨兵机制</h3><p>sentinal，中文名是哨兵，是redis集群架构中非常重要的一个组件，主要功能如下：</p>\n<ol>\n<li>集群监控：负责监控redis master和slave进程是否正常工作。</li>\n<li>消息通知：如果某个redis实例有故障，哨兵负责发送消息给管理员报警。</li>\n<li>故障转移：如果master挂掉了，会自动转移到slave上。</li>\n<li>配置中心：如果故障转移发生了，把新的master地址通知到客户端。</li>\n</ol>\n<p>哨兵本身也是分布式的，作为一个哨兵集群在运行，互相协同工作。</p>\n<ol>\n<li>故障转移时，判断一个master是否宕机，需要大部分的哨兵同意才行，涉及到分布式选举。</li>\n<li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，保证了系统的高可用性。</li>\n</ol>\n<h4 id=\"哨兵的核心知识\"><a href=\"#哨兵的核心知识\" class=\"headerlink\" title=\"哨兵的核心知识\"></a>哨兵的核心知识</h4><ol>\n<li>哨兵至少需要3个实例，来保证自己的健壮性。</li>\n<li>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用。</li>\n<li>对于哨兵+redis主从的复杂架构，尽量在测试和生产环境都进行充足的测试和演练。</li>\n</ol>\n<p><strong>为什么redis哨兵集群少于3个节点无法正常工作</strong></p>\n<p>如果哨兵集群只有两个节点，两个哨兵的majority=2，其中master所在的机器宕机了，这时只剩下一个哨兵，哨兵切换故障需要满足大多数哨兵同意原则，此时没有majority来运行执行故障转移，所以两个哨兵节点不能工作。</p>\n<h4 id=\"sdown和odown转换机制？\"><a href=\"#sdown和odown转换机制？\" class=\"headerlink\" title=\"sdown和odown转换机制？\"></a>sdown和odown转换机制？</h4><p>master宕机有sdown和odown两种失败状态</p>\n<ul>\n<li>sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，就是主观宕机。</li>\n<li>odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，就是客观宕机。</li>\n<li>sdown达成的条件很简单，如果一个哨兵ping一个master，超过了is-master-after-milliseconds指定的毫秒数之后，就主观认为master宕机了</li>\n<li>sdown到odown的转换条件也很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，也就是客观认为master宕机。</li>\n</ul>\n<h4 id=\"哨兵和slave集群的自动发现机制\"><a href=\"#哨兵和slave集群的自动发现机制\" class=\"headerlink\" title=\"哨兵和slave集群的自动发现机制\"></a>哨兵和slave集群的自动发现机制</h4><p>哨兵互相之间的发现，是通过redis的pub/sub系统实现的，每个哨兵都会往_sentinel_:hello channel里发送一个消息，内容是自己的host、ip和runid，还有对这个master的监控配置。每个哨兵也会去监听自己监控的master+slave对应的_sentinel_:hello channel，然后去感到到同样在监听这个master+slave的其他哨兵的存在，每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。</p>\n<h4 id=\"slave-master选举算法\"><a href=\"#slave-master选举算法\" class=\"headerlink\" title=\"slave-master选举算法\"></a>slave-master选举算法</h4><p>如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来准备升级为master。</p>\n<p><strong>从节点过滤</strong>：判断跟master断开连接的时长</p>\n<p>如果一个slave跟master断开连接已经超过了（down-after-milliseconds的10倍+master宕机的时长），那么slave就被认为不适合选举为master。</p>\n<ol>\n<li>slave配置的优先级（slave-priority=100）</li>\n<li>复制offset</li>\n<li>run id</li>\n</ol>\n<p>说明：</p>\n<ol>\n<li>然后把剩下了的slave按照优先级进行排序，slave priority越低，优先级就越高。</li>\n<li>如果slave priority相同，就看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。</li>\n<li>如果上面两个条件都相同，那么选择一个run id比较小的那个slave。</li>\n</ol>\n<h4 id=\"slave配置的自动纠正\"><a href=\"#slave配置的自动纠正\" class=\"headerlink\" title=\"slave配置的自动纠正\"></a>slave配置的自动纠正</h4><p>哨兵会自动纠正slave的配置信息。比如某台slave要成为潜在的master候选人，哨兵会确保slave在复制现有的master数据；如果slave连接到了一个错误的master上，比如故障转移后，哨兵会确保它们连接到正确的master上。</p>\n<h4 id=\"quorum和majority\"><a href=\"#quorum和majority\" class=\"headerlink\" title=\"quorum和majority\"></a>quorum和majority</h4><p>每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还要得到majority哨兵的授权，才能正式执行切换。</p>\n<p>如果quorum &lt; majority，比如5个哨兵，majority就是3，quorum设置为2，可以执行切换。</p>\n<p>如果quorum &gt;= majority，比如5个哨兵，设置quorum是5，那么必须5个哨兵都授权才能切换。</p>\n<h4 id=\"configuration-epoch\"><a href=\"#configuration-epoch\" class=\"headerlink\" title=\"configuration epoch\"></a>configuration epoch</h4><p>哨兵进行切换之前，执行切换的那个哨兵从要切换到新的master那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。如果第一次master切换失败了，那么其他哨兵会等待failover-timeout时间，然后继续执行切换，此时会重新获得一个新的configuration epoch，作为新的version号。</p>\n<h4 id=\"configuration传播\"><a href=\"#configuration传播\" class=\"headerlink\" title=\"configuration传播\"></a>configuration传播</h4><p>哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他哨兵，通过pub/sub消息机制。</p>\n<p>这里version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置。</p>\n<hr>\n<h2 id=\"异步复制和集群脑裂导致数据丢失\"><a href=\"#异步复制和集群脑裂导致数据丢失\" class=\"headerlink\" title=\"异步复制和集群脑裂导致数据丢失\"></a>异步复制和集群脑裂导致数据丢失</h2><p>场景一：异步复制导致的数据丢失</p>\n<p>client往redis master写入数据，master还没来得及复制给slave，此时，master宕机了，哨兵检测到master宕机后，从slave中投票选举出新的master，但是没来得及复制的数据就丢失了。</p>\n<p>场景二：集群脑裂导致的数据丢失</p>\n<p>master出现了网络异常，与其他slave节点失去联系，但没有挂掉，其他slave节点上的哨兵机制重新选举了master，不过此时的client跟旧的master网络是好的，发送了数据到旧的master数据没有得到同步，此时检测到该master有问题，修好网络后作为slave挂在到新的master节点上，但是新的master没有同步网络异常时的数据导致丢失。</p>\n<p><strong>如何降低损失？</strong></p>\n<ul>\n<li>min-slaves-to-write 1</li>\n<li>min-slaves-max-lag 10</li>\n</ul>\n<p>配置说明：要求至少有一个slave，数据复制和同步的延迟不能超过10秒。也就是说一旦所有的slave数据的复制和同步都超过了10秒，这时master就不会再接收写请求了，可以把数据落差保持在可控范围内，减少数据损失。</p>\n<p>上述配置也适合脑裂，master发生脑裂以后，所有slave都不向旧的master发送数据，10秒之后旧master停止接收写请求，同样也可以减少脑裂带来的数据丢失。</p>\n<hr>\n<h2 id=\"分布式集群-redis-cluster\"><a href=\"#分布式集群-redis-cluster\" class=\"headerlink\" title=\"分布式集群-redis cluster\"></a>分布式集群-redis cluster</h2><ol>\n<li>自动将数据进行分片，每个master上放一部分数据。</li>\n<li>提供内置的高可用支持，部分master不可用时，还是可以继续工作的。</li>\n</ol>\n<p>redis cluster可以突破单机redis在海量数据面前的瓶颈。</p>\n<p><strong>redis cluster VS replication+sentinal</strong></p>\n<p>如果数据量很少，只有几个G，主要是承载高并发性能的场景，那么单机足够了。采用主从架构，再搭建一个sentinal集群，保证高可用。如果你的数据量很大，建议使用redis cluster。</p>\n<h3 id=\"分布式数据存储的核心算法\"><a href=\"#分布式数据存储的核心算法\" class=\"headerlink\" title=\"分布式数据存储的核心算法\"></a>分布式数据存储的核心算法</h3><h4 id=\"最老土的hash算法和弊端\"><a href=\"#最老土的hash算法和弊端\" class=\"headerlink\" title=\"最老土的hash算法和弊端\"></a>最老土的hash算法和弊端</h4><p>把请求的数据进行hash运算，对hash值取模（针对master数量）然后放入对应的master节点中，如果某台master宕机了，该节点中的缓存数据就会失效，更严重的是由于master数量少了，导致取模方式改变，新的请求通过取模运算后得不到有效缓存，会造成几乎100%的请求涌入数据库重新生成缓存，这里会涉及到<strong>大量的缓存重建</strong>，这是致命的。</p>\n<h4 id=\"一致性hash算法-自动缓存迁移\"><a href=\"#一致性hash算法-自动缓存迁移\" class=\"headerlink\" title=\"一致性hash算法(自动缓存迁移)\"></a>一致性hash算法(自动缓存迁移)</h4><p>有请求过来以后，同样是把key进行hash运算，然后会把hash值对应在圆环的各个点上，key落在圆环上以后就会顺时针旋转去寻找距离自己最近的master节点，如果任何一个master节点宕机，只有在该master上的缓存会失效，比如有3台master节点，宕机一台，1/3的数据流量会瞬间涌入数据库，重新查询一次，在环上的master节点越多，宕机后失效的数据越少。这只是均匀分布的情况，如有区间存在缓存热点，还是会有弊端。</p>\n<h4 id=\"一致性hash算法-虚拟节点\"><a href=\"#一致性hash算法-虚拟节点\" class=\"headerlink\" title=\"一致性hash算法+虚拟节点\"></a>一致性hash算法+虚拟节点</h4><p>基于一致性hash算法，在各个master节点之间，再创建均匀分布的虚拟节点，在每个区间内，大量的数据都会均匀的分布到不同的节点，不会存在大量的缓存顺时针同时融入一个master内，实现了自动的<strong>负载均衡</strong>。</p>\n<h4 id=\"hash-slot算法\"><a href=\"#hash-slot算法\" class=\"headerlink\" title=\"hash slot算法\"></a>hash slot算法</h4><p>redis cluster有固定的16384个哈希槽，对每个key计算CRC16的值，然后对16384取模，注意不是对机器取模，所以即使有任何一台机器宕机，其他master中的缓存是不受影响的，经过短暂的数据迁移后，会把宕机中的缓存数据均匀分布到其他的master中继续提供服务。而且master slot让node的增加和移除变得很简单，只需要针对机器的个数均匀分配16384个哈希槽就可以了。</p>\n<hr>\n<h3 id=\"redis集群模式的工作原理\"><a href=\"#redis集群模式的工作原理\" class=\"headerlink\" title=\"redis集群模式的工作原理\"></a>redis集群模式的工作原理</h3><h4 id=\"节点间的内部通信机制\"><a href=\"#节点间的内部通信机制\" class=\"headerlink\" title=\"节点间的内部通信机制\"></a>节点间的内部通信机制</h4><p><strong>基础通信原理</strong></p>\n<p>redis cluster节点间采用<strong>gossip</strong>协议进行通信。</p>\n<p>跟集中式不同，不是将元数据（节点信息、故障等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的。</p>\n<ul>\n<li>集中式：好处在于，元数据的更新和读取的时效性非常好，一旦有变更，其他节点立刻就能感知到。缺点是所有的元数据的更新全部集中在一个地方，可能导致元数据的存储压力。</li>\n<li>gossip：好处在于，元数据的更新比较分散，更新请求会陆陆续续的打到所有节点上去更新，降低了压力。缺点是元数据的更新有一定的延迟，可能导致集群的一些操作滞后。</li>\n</ul>\n<p>10000端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口，每个节点每隔一段时间都会往另外几个节点发送ping信息，收到后返回pong。通过通信端口结合gossip协议相互交换信息，包括故障信息、节点的增加和删除、hash slot信息等等。</p>\n<p><strong>gossip协议</strong></p>\n<p>gossip协议包含多种消息，包括ping、pong、meet、fail等。</p>\n<ul>\n<li>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始和其他节点进行通信。</li>\n<li>ping：每个节点都会频繁的给其他节点发送ping，其中包含自己的状态还有自己维护集群的元数据，互相通过ping进行元数据的交换和更新。</li>\n<li>pong：返回ping和meet，包含自己的状态和其他信息，也可以用于广播和更新。</li>\n<li>fail：某个节点判断另一个节点fail后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</li>\n</ul>\n<p><strong>ping消息深入</strong></p>\n<p>每个节点每秒会执行10次ping，每次会选择5个最久没有通信的其他节点。如果发现某个节点通信延时达到了cluster_node_timeout，就会立即发送ping，避免数据交换延迟过长。所以cluster_node_timeout可以调节，如果调节比较大，就可以降低发送的频率。每次ping需要带上自己的节点信息，还有就是带上1/10的其他节点信息，发送出去，进行数据交换。至少包含3个其他节点的信息，最多包含（总节点-2）个其他节点信息。</p>\n<hr>\n<p>jedis的运行原理：重定向，计算hash slot，采用smart jedis，在本地维护了一个hash slot -&gt; node的映射表缓存。</p>\n<h4 id=\"高性能与主备切换原理\"><a href=\"#高性能与主备切换原理\" class=\"headerlink\" title=\"高性能与主备切换原理\"></a>高性能与主备切换原理</h4><p>redis cluster的高可用原理，几乎和哨兵是一样的。</p>\n<ol>\n<li><p>判断节点宕机</p>\n<p>如果一个节点认为另外一个节点宕机了，就是pfail，主观宕机。如果多个节点都认为另外一个节点pfail了，那么就是客观宕机fail。节点之间把pfail放在gossip ping中进行通信，超过半数认为pfail就是fail。</p>\n</li>\n<li><p>从节点过滤</p>\n<p>对于宕机的master，从其所有的从节点slave中选择一个切换成master，检查每个slave与宕机的master断开连接的时间，如果超过了（cluster-node-timeout * cluster-slave-validity-factor）将失去选举资格。</p>\n</li>\n<li><p>master选举</p>\n<p>每个从节点都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多），选举时间越靠前，优先进行选举。然后开始进行投票，具体过程和哨兵类似，选举通过成为新的master。</p>\n</li>\n</ol>\n<p>综上所述：redis cluster功能强大，直接集成了replication和sentinal的功能。</p>\n<hr>\n<h2 id=\"缓存雪崩、缓存穿透、缓存击穿\"><a href=\"#缓存雪崩、缓存穿透、缓存击穿\" class=\"headerlink\" title=\"缓存雪崩、缓存穿透、缓存击穿\"></a>缓存雪崩、缓存穿透、缓存击穿</h2><h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>定义：指在某一时间段，缓存集体失效。</p>\n<h4 id=\"造成缓存雪崩的原因\"><a href=\"#造成缓存雪崩的原因\" class=\"headerlink\" title=\"造成缓存雪崩的原因\"></a>造成缓存雪崩的原因</h4><ol>\n<li>比如双11零点抢购，大量商品被集中放入到缓存，假设缓存时效为一小时，那么到了凌晨1点的时候缓存就集体失效了，大量的请求会打在数据库上，对数据库来说，就会产生周期性的压力波峰，可能造成缓存雪崩。</li>\n<li>缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</li>\n</ol>\n<h4 id=\"如何预防缓存雪崩？\"><a href=\"#如何预防缓存雪崩？\" class=\"headerlink\" title=\"如何预防缓存雪崩？\"></a>如何预防缓存雪崩？</h4><p>针对缓存集体失效：如果是电商项目，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。</p>\n<p>针对缓存服务器宕机：redis高可用（主从+哨兵 或者 redis cluster），避免全盘奔溃。</p>\n<h4 id=\"缓存雪崩了如何恢复？\"><a href=\"#缓存雪崩了如何恢复？\" class=\"headerlink\" title=\"缓存雪崩了如何恢复？\"></a>缓存雪崩了如何恢复？</h4><p>本地ehcache缓存+hystrix限流&amp;降级，避免mysql被打死。事后通过redis持久化快速恢复缓存数据。</p>\n<hr>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>定义：是指查询一个数据库一定不存在的数据，请求穿过了缓存，直接打在了数据库。</p>\n<h4 id=\"造成缓存穿透的原因\"><a href=\"#造成缓存穿透的原因\" class=\"headerlink\" title=\"造成缓存穿透的原因\"></a>造成缓存穿透的原因</h4><p>代码bug或者恶意攻击。</p>\n<h4 id=\"如何预防缓存穿透？\"><a href=\"#如何预防缓存穿透？\" class=\"headerlink\" title=\"如何预防缓存穿透？\"></a>如何预防缓存穿透？</h4><p>如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。</p>\n<hr>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>定义：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>\n<h3 id=\"如何预防缓存击穿？\"><a href=\"#如何预防缓存击穿？\" class=\"headerlink\" title=\"如何预防缓存击穿？\"></a>如何预防缓存击穿？</h3><p>这种情况遇到的比较少，真有这种爆款key，设置成永不过期就可以了。</p>\n<hr>\n<h2 id=\"如何保证缓存与数据库的双写一致性\"><a href=\"#如何保证缓存与数据库的双写一致性\" class=\"headerlink\" title=\"如何保证缓存与数据库的双写一致性\"></a>如何保证缓存与数据库的双写一致性</h2><h3 id=\"先删缓存，再更新数据库\"><a href=\"#先删缓存，再更新数据库\" class=\"headerlink\" title=\"先删缓存，再更新数据库\"></a>先删缓存，再更新数据库</h3><p>最经典的缓存+数据库读写的模式：暂存模式（cache aside pattern）</p>\n<ol>\n<li>读的时候先读缓存，缓存没有的话就读数据库，然后把数据库的数据放到缓存，同时返回相应。</li>\n<li>更新的时候，<strong>先删除缓存，再更新数据库</strong>，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，不会造成不一致，因为读的时候缓存中没有，还会把旧的数据库数据更新到缓存中。反过来，如果先更改数据库再删除缓存，如果缓存删除失败了，则会导致数据不一致。</li>\n</ol>\n<p>为什么是删除缓存，而不是更新缓存呢？</p>\n<p>原因很简单，很多时候复杂点的缓存场景，不单单是修改了一个值那么简单，而是需要结合多张表去计算才能得到缓存结果，就算真的是简单场景的缓存，也需要看看这个缓存是不是被频繁的使用到，否则只是增加麻烦而已。</p>\n<p>其实删除缓存就是一个lazy计算的思想，不需要每次都做复杂的运算，它被用到的时候再计算就好了。</p>\n<hr>\n<h3 id=\"高并发场景下的数据不一致\"><a href=\"#高并发场景下的数据不一致\" class=\"headerlink\" title=\"高并发场景下的数据不一致\"></a>高并发场景下的数据不一致</h3><h4 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h4><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没有修改，一个请求过来，去读缓存，发现缓存空了，去查询数据库，把旧的数据放到了缓存中，然后数据库完成了修改，此时数据库和缓存的数据不一致了。</p>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><p>把数据库与缓存的更新读取操作进行异步串行化。</p>\n<ul>\n<li>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个内存队列中。</li>\n<li>读取数据的时候，如果发现数据不在缓存中，那么将进行（重新读取+更新缓存）操作，也根据唯一标识路由并发送到同一个内存队列中。</li>\n</ul>\n<p>一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。</p>\n<p>这样的话，一个数据变更的操作，先删除缓存，然后去更新数据库，但是还没有完成更新；此时如果一个读请求过来，读到了空的缓存，可以先将缓存更新的请求发送到队列中积压，然后同步等待缓存更新完成。</p>\n<p>这里有一个优化点，一个队列中，多个读请求（更新缓存）串在一起是没有意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，就不用再放更新操作进入队列了，直接等待前面的缓存更新完成即可。如果请求还在等待范围内，不断轮询发现可以取到值了就返回，超过等待时长就返回数据库中的旧值。</p>\n<h4 id=\"解决方案需要注意的问题\"><a href=\"#解决方案需要注意的问题\" class=\"headerlink\" title=\"解决方案需要注意的问题\"></a>解决方案需要注意的问题</h4><p><strong>读请求 长时间堵塞</strong></p>\n<p>由于读请求做了非常轻度的异步化，所以一定要注意读超时问题，每个读请求必须在超时时间范围内返回。</p>\n<p>该方案的最大风险在于可能数据更新很频繁，或者包含了对多个数据项的修改，导致队列中积压了大量的更新操作在里面，然后读请求发生了大量的超时，最后导致大量的读请求直接走数据库。一定要提前做好压力测试和真实数据模拟，不过一般来说数据的写频率是很低的，所以队列中积压的应该不会太多。如果真的导致积压过多的话，可以采取增加内存队列的方式来解决。</p>\n<p><strong>读请求 并发量过高</strong></p>\n<p>上述方案有可能突然大量的读请求在几十毫秒内hang在服务器上，看需要几台服务器才能扛得住，所以要计算好每个读请求不要hang太久。</p>\n<p><strong>多服务实例部署的请求路由</strong></p>\n<p>可能这个服务部署了多个实例，那么必须保证，执行数据更新操作以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务器实例上。</p>\n<p><strong>热点商品的路由问题</strong></p>\n<p>万一某个商品的读写请求特别高，全部打到相同的机器的相同队列里去了，可能造成某台机器的压力过大。</p>\n<p>因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题影响不是很大，不过的缺可能某些机器的负载高一些。</p>\n<hr>\n<h2 id=\"如何保证redis并发竞争的数据一致性\"><a href=\"#如何保证redis并发竞争的数据一致性\" class=\"headerlink\" title=\"如何保证redis并发竞争的数据一致性\"></a>如何保证redis并发竞争的数据一致性</h2><p>客户端角度：为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p>\n<p>服务器角度：采用分布式锁，确保同一时刻只能有一个系统实例在操作某个key，获得分布式锁以后，每次要写之前，先判断当前这个value的时间戳是否比缓存中的时间戳更新，如果更新，可以写入；否则，就不能用旧数据覆盖新数据。</p>"},{"title":"Java开发框架以及高频知识点汇总","date":"2017-09-08T14:54:57.000Z","top_img":"https://i.loli.net/2020/01/07/9z6Pqybp8O1AEMU.jpg","_content":"\n## Java 基础\n\n#### JDK 和 JRE 有什么区别？\n\nJDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。\n\nJRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。\n\n具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。\n\n<!-- more -->\n\n#### == 和 equals 的区别是什么？\n\n== 解读\n\n对于基本类型和引用类型 == 的作用效果是不同的，如下所示：\n\n基本类型：比较的是值是否相同；\n\n引用类型：比较的是引用是否相同；\n\n代码示例：\n\n```java\nString x = \"string\";\nString y = \"string\";\nString z = new String(\"string\");\nSystem.out.println(x==y); // true\nSystem.out.println(x==z); // false\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x.equals(z)); // true\n```\n\n代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。\n\nequals 解读\n\nequals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。\n\n首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：\n\n```java\nclass Cat {\n    public Cat(String name) {\n        this.name = name;\n    }\n  \tprivate String name;\n \n\t\tpublic String getName() {\n    \t\treturn name;\n\t\t}\n \n\t\tpublic void setName(String name) {\n    \t\tthis.name = name;\n\t\t}\n}\n\nCat c1 = new Cat(\"xx\");\nCat c2 = new Cat(\"xx\");\nSystem.out.println(c1.equals(c2)); // false\n\n```\n\n输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n原来 equals 本质上就是 ==。\n\n那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：\n\n```java\nString s1 = new String(\"老王\");\nString s2 = new String(\"老王\");\nSystem.out.println(s1.equals(s2)); // true\n```\n\n同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下:\n\n```java\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。\n\n总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。\n\n\n\n#### 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？\n\n不对，两个对象的 hashCode()相同，equals()不一定 true。\n\n代码示例：\n\n```java\nString str1 = \"通话\";\nString str2 = \"重地\";\nSystem.out.println(String.format(\"str1：%d | str2：%d\",  str1.hashCode(),str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n```\n\n执行的结果：\n\nstr1：1179395 | str2：1179395\n\nfalse\n\n代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。\n\n\n\n#### final 在 java 中有什么作用？\n\nfinal 修饰的类不能被继承。\n\nfinal 修饰的方法不能被重写。\n\nfinal 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n\n\n\n#### java 中的 Math.round(-1.5) 等于多少？\n\n等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃\n\n\n\n#### String 属于基础的数据类型吗？\n\nString 不属于基础类型，属于对象，也就是引用类型。\n\n基础类型有 8 种：byte、boolean、char、short、int、float、long、double。\n\n\n\n#### java 中操作字符串都有哪些类？它们之间有什么区别？\n\n操作字符串的类有：String、StringBuffer、StringBuilder。\n\nString 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\n\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n\n\n\n#### String str=\"i\"与 String str=new String(\"i\")一样吗？\n\n不一样，因为内存的分配方式不一样。String str=\"i\"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(\"i\") 则会被分到堆内存中。\n\n\n\n#### 如何将字符串反转？\n\n使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n\n示例代码：\n\n```java\n// StringBuffer reverse\nStringBuffer stringBuffer = new StringBuffer();\nstringBuffer.append(\"abcdefg\");\nSystem.out.println(stringBuffer.reverse()); // gfedcba\n// StringBuilder reverse\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"abcdefg\");\nSystem.out.println(stringBuilder.reverse()); // gfedcba\n```\n\n\n\n#### String 类的常用方法都有那些？\n\nindexOf()：返回指定字符的索引。\ncharAt()：返回指定索引处的字符。\nreplace()：字符串替换。\ntrim()：去除字符串两端空白。\nsplit()：分割字符串，返回一个分割后的字符串数组。\ngetBytes()：返回字符串的 byte 类型数组。\nlength()：返回字符串长度。\ntoLowerCase()：将字符串转成小写字母。\ntoUpperCase()：将字符串转成大写字符。\nsubstring()：截取字符串。\nequals()：字符串比较。\n\n\n\n#### 抽象类必须要有抽象方法吗？\n\n不需要，抽象类不一定非要有抽象方法。\n\n示例代码：\n\n```java\nabstract class Cat {\n    public static void sayHi() {\n        System.out.println(\"hi~\");\n    }\n}\n```\n\n上面代码，抽象类并没有抽象方法但完全可以正常运行。\n\n\n\n#### 普通类和抽象类有哪些区别？\n\n普通类不能包含抽象方法，抽象类可以包含抽象方法。\n抽象类不能直接实例化，普通类可以直接实例化。\n\n\n\n#### 抽象类能使用 final 修饰吗？\n\n不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，编辑器会提示错误信息。\n\n\n\n#### 接口和抽象类有什么区别？\n\n实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n构造函数：抽象类可以有构造函数；接口不能有。\nmain 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。\n实现数量：类可以实现很多个接口；但是只能继承一个抽象类。\n访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n\n\n#### java 中 IO 流分为几种？\n\n按功能来分：输入流（input）、输出流（output）。\n\n按类型来分：字节流和字符流。\n\n字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。\n\n \n\n#### BIO、NIO、AIO 有什么区别？\n\nBIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\n\nNIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\n\nAIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n\n\n#### Files的常用方法都有哪些？\n\nFiles.exists()：检测文件路径是否存在。\nFiles.createFile()：创建文件。\nFiles.createDirectory()：创建文件夹。\nFiles.delete()：删除一个文件或目录。\nFiles.copy()：复制文件。\nFiles.move()：移动文件。\nFiles.size()：查看文件个数。\nFiles.read()：读取文件。\nFiles.write()：写入文件。\n\n\n\n## java集合/容器\n\n#### java 容器都有哪些？\n\n\n\n#### Collection 和 Collections 有什么区别？\n\njava.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。\n\nCollections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。\n\n\n\n#### List、Set、Map 之间的区别是什么？\n\n\n\n#### HashMap 和 Hashtable 有什么区别？\n\nhashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。\nhashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。\nhashMap允许空键值，而hashTable不允许。\n\n\n\n#### 如何决定使用 HashMap 还是 TreeMap？\n\n对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。\n\n\n\n#### 说一下 HashMap 的实现原理？\n\nHashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 \n\n HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。\n\n当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。\n\n 需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)\n\n\n\n#### 说一下 HashSet 的实现原理？\n\nHashSet底层由HashMap实现\nHashSet的值存放于HashMap的key上\nHashMap的value统一为PRESENT\n\n\n\n#### ArrayList 和 LinkedList 的区别是什么？\n\n最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。\n\n\n\n#### 如何实现数组和 List 之间的转换？\n\nList转换成为数组：调用ArrayList的toArray方法。\n数组转换成为List：调用Arrays的asList方法。\n\n\n\n#### ArrayList 和 Vector 的区别是什么？\n\nVector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 \n\nArrayList比Vector快，它因为有同步，不会过载。 \n\nArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。\n\n\n\n#### Array 和 ArrayList 有何区别？\n\nArray可以容纳基本类型和对象，而ArrayList只能容纳对象。 \nArray是指定大小的，而ArrayList大小是固定的。 \nArray没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。\n\n\n\n#### 在 Queue 中 poll()和 remove()有什么区别？\n\npoll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。\n\n\n\n#### 哪些集合类是线程安全的？\n\nvector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。\nstatck：堆栈类，先进后出。\nhashtable：就比hashmap多了个线程安全。\nenumeration：枚举，相当于迭代器。\n\n\n\n#### 迭代器 Iterator 是什么？\n\n迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。\n\n\n\n#### Iterator 怎么使用？有什么特点？\n\nJava中的Iterator功能比较简单，并且只能单向移动：\n\n　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。\n\n　　(2) 使用next()获得序列中的下一个元素。\n\n　　(3) 使用hasNext()检查序列中是否还有元素。\n\n　　(4) 使用remove()将迭代器新返回的元素删除。\n\n　　Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。\n\n\n\n#### Iterator 和 ListIterator 有什么区别？\n\nIterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 \nIterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 \nListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。\n\n## 多线程\n\n#### 并行和并发有什么区别？\n\n并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。\n并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。\n在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。\n所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。\n\n\n\n#### 线程和进程的区别？\n\n简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。\n\n\n\n#### 守护线程是什么？\n\n守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程\n\n\n\n#### 创建线程有哪几种方式？\n\n①. 继承Thread类创建线程类\n\n定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。\n创建Thread子类的实例，即创建了线程对象。\n调用线程对象的start()方法来启动该线程。\n②. 通过Runnable接口创建线程类\n\n定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。\n创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。\n调用线程对象的start()方法来启动该线程。\n③. 通过Callable和Future创建线程\n\n创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。\n创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。\n使用FutureTask对象作为Thread对象的target创建并启动新线程。\n调用FutureTask对象的get()方法来获得子线程执行结束后的返回值\n\n\n\n#### 说一下 runnable 和 callable 有什么区别？\n\n有点深的问题了，也看出一个Java程序员学习知识的广度。\n\nRunnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；\nCallable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。\n\n\n\n#### 线程有哪些状态？\n\n线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。\n\n创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。\n就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。\n运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。\n阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。\n死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 。\n\n\n\n#### sleep() 和 wait() 有什么区别？\n\nsleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。\n\nwait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。\n\n\n\n#### notify()和 notifyAll()有什么区别？\n\n如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。\n当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。\n优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。\n\n\n\n#### 线程的 run()和 start()有什么区别？\n\n每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。\n\n start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。\n\n run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法\n\n\n\n#### 创建线程池有哪几种方式？\n\n①. newFixedThreadPool(int nThreads)\n\n创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。\n\n②. newCachedThreadPool()\n\n创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。\n\n③. newSingleThreadExecutor()\n\n这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行\n\n④. newScheduledThreadPool(int corePoolSize)\n\n创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。\n\n\n\n#### 线程池都有哪些状态？\n\n线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。\n\n线程池各个状态切换框架图：\n\n\n\n#### 线程池中 submit()和 execute()方法有什么区别？\n\n接收的参数不一样\nsubmit有返回值，而execute没有\nsubmit方便Exception处理\n\n\n\n#### 在 java 程序中怎么保证多线程的运行安全？\n\n线程安全在三个方面体现：\n\n原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；\n可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；\n有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。\n\n\n\n#### 多线程锁的升级原理是什么？\n\n在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。\n\n锁升级的图示过程： \n\n\n\n#### 什么是死锁？\n\n死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。\n\n\n\n#### 怎么防止死锁？\n\n死锁的四个必要条件：\n\n互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源\n请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放\n不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放\n环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系\n这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。\n\n理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。\n\n所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。\n\n此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。\n\n\n\n#### ThreadLocal 是什么？有哪些使用场景？\n\n线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。\n\n\n\n#### 说一下 synchronized 底层实现原理？\n\nsynchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。\n\nJava中每一个对象都可以作为锁，这是synchronized实现同步的基础：\n\n普通同步方法，锁是当前实例对象\n静态同步方法，锁是当前类的class对象\n同步方法块，锁是括号里面的对象\n\n\n\n#### 说一下volatile底层实现原理\n\n#### synchronized 和 volatile 的区别是什么？\n\nvolatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\nvolatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。\nvolatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。\nvolatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。\nvolatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。\n\n\n\n#### synchronized 和 Lock 有什么区别？\n\n首先synchronized是java内置关键字，在jvm层面，Lock是个java类；\nsynchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\nsynchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\nsynchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；\nLock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n\n\n\n#### synchronized 和 ReentrantLock 区别是什么？\n\nsynchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：\n\nReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 \nReentrantLock可以获取各种锁的信息\nReentrantLock可以灵活地实现多路通知 \n另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word\n\n \n\n#### 说一下 atomic 的原理？\n\nAtomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。\n\nAtomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。\n\n\n\n## 反射\n\n#### 什么是反射？\n\n反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。\n\nJava反射：在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法。\n\nJava反射机制主要提供了以下功能：\n\n在运行时判断任意一个对象所属的类。\n在运行时构造任意一个类的对象。\n在运行时判断任意一个类所具有的成员变量和方法。\n在运行时调用任意一个对象的方法。 \n得到类的字节码文件相同，这三种方式。\n1.Class cls1=类名.class 相对简单，还是需要明确类名\n2.cls1.getclass();必须要明确具体的类，并创建对象\n3.class.forName(\"完整的类名（带包名）\");\n\n\n\n#### 什么是 java 序列化？什么情况下需要序列化？\n\n简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。\n\n什么情况下需要序列化：\n\na）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；\nb）当你想用套接字在网络上传送对象的时候；\nc）当你想通过RMI传输对象的时候；\n\n\n\n#### 动态代理是什么？有哪些应用？\n\n动态代理：\n\n当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。\n\n动态代理的应用：\n\nSpring的AOP\n加事务\n加权限\n加日志\n\n\n\n#### 怎么实现动态代理？\n\n首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。\n\n\n\n## 对象拷贝\n\n#### 为什么要使用克隆？\n\n想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。\n\n\n\n#### 如何实现对象克隆？\n\n有两种方式：\n\n1). 实现Cloneable接口并重写Object类中的clone()方法；\n\n2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。\n注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时\n\n\n\n#### 深拷贝和浅拷贝区别是什么？\n\n浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）\n深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）\n\n\n\n## Java Web\n\n#### jsp 和 servlet 有什么区别？\n\njsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）\njsp更擅长表现于页面显示，servlet更擅长于逻辑控制。\nServlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。\nJsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应\n\n\n\n#### jsp 有哪些内置对象？作用分别是什么？\n\nJSP有9个内置对象：\n\nrequest：封装客户端的请求，其中包含来自GET或POST请求的参数；\nresponse：封装服务器对客户端的响应；\npageContext：通过该对象可以获取其他对象；\nsession：封装用户会话的对象；\napplication：封装服务器运行环境的对象；\nout：输出服务器响应的输出流对象；\nconfig：Web应用的配置对象；\npage：JSP页面本身（相当于Java程序中的this）；\nexception：封装页面抛出异常的对象。\n\n\n\n#### 说一下 jsp 的 4 种作用域？\n\nJSP中的四种作用域包括page、request、session和application，具体来说：\n\npage代表与一个页面相关的对象和属性。\nrequest代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。\nsession代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。\napplication代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。\n\n\n\n#### session 和 cookie 有什么区别？\n\n\n\n#### 说一下 session 的工作原理？\n\n其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了\n\n\n\n#### 如何避免SQL注入\n\n1. PreparedStatement（简单又有效的方法）\n2. 使用正则表达式过滤传入的参数\n3. 字符串过滤\n4. JSP中调用该函数检查是否包函非法字符\n5. JSP页面判断代码\n\n\n\n#### 什么是 XSS 攻击，如何避免？\n\nXSS攻击又称CSS,全称Cross Site Script  （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。\n\n\n\n## 异常\n\n#### throw 和 throws 的区别？\n\nthrows是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型\n\n\n\n#### final、finally、finalize 有什么区别？\n\nfinal可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。\nfinally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。\nfinalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 \n\n\n\n#### try-catch-finally 中哪个部分可以省略？\n\n答：catch 可以省略\n\n原因：\n\n```\n   更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。\n   理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。\n  至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。\n\n```\n\n\n\n#### try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\n\n答：会执行，在 return 前执行。\n\n\n\n#### 常见的异常类有哪些？\n\nNullPointerException：当应用程序试图访问空对象时，则抛出该异常。\nSQLException：提供关于数据库访问错误或其他错误信息的异常。\nIndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 \nNumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\nFileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。\nIOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。\nClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。\nArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。\nIllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。\nArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 \nNegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。\nNoSuchMethodException：无法找到某一特定方法时，抛出该异常。\nSecurityException：由安全管理器抛出的异常，指示存在安全侵犯。\nUnsupportedOperationException：当不支持请求的操作时，抛出该异常。\nRuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。\n\n\n\n## 网络\n\n#### http 响应码 301 和 302 代表的是什么？有什么区别？\n\n301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。\n\n区别： \n\n301 redirect: 301 代表永久性转移(Permanently Moved)。\n302 redirect: 302 代表暂时性转移(Temporarily Moved )。\n\n\n\n#### forward 和 redirect 的区别？\n\nForward和Redirect代表了两种请求转发方式：直接转发和间接转发。\n\n直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。\n\n间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。\n\n举个通俗的例子：\n\n　　直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；\n\n　　间接转发就相当于：\"A找B借钱，B说没有，让A去找C借\"\n\n\n\n#### 简述 tcp 和 udp的区别？\n\nTCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。\nTCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。\nTcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。\nUDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。\n每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。\nTCP对系统资源要求较多，UDP对系统资源要求较少。\n\n\n\n#### tcp 为什么要三次握手，两次不行吗？为什么？\n\n为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。\n\n如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。\n\n\n\n#### 说一下 tcp 粘包是怎么产生的？\n\n①. 发送方产生粘包\n\n采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。\n\n②. 接收方产生粘包\n\n接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度） \n\n\n\n#### OSI 的七层模型都有哪些？\n\n应用层：网络服务与最终用户的一个接口。\n表示层：数据的表示、安全、压缩。\n会话层：建立、管理、终止会话。\n传输层：定义传输数据的协议端口号，以及流控和差错校验。\n网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。\n数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。\n物理层：建立、维护、断开物理连接。\n\n\n\n#### get 和 post 请求有哪些区别？\n\nGET在浏览器回退时是无害的，而POST会再次提交请求。\nGET产生的URL地址可以被Bookmark，而POST不可以。\nGET请求会被浏览器主动cache，而POST不会，除非手动设置。\nGET请求只能进行url编码，而POST支持多种编码方式。\nGET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\nGET请求在URL中传送的参数是有长度限制的，而POST么有。\n对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\nGET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\nGET参数通过URL传递，POST放在Request body中\n\n#### 说一下 JSONP 实现原理？\n\njsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返货json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。\n\n\n\n## 设计模式\n\n#### 单例模式\n\n定义：有且仅有一个实例\n\n用途：\n\n双重检查、静态内部类、枚举（推荐使用）\n\n```java\n//双重检查写法\npublic class Singleton {\n    private static volatile Singleton singleton;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n\n```\n\n这两种写法的优点：线程安全；延迟加载；效率较高。\n\n```java\n//静态内部类写法\npublic class Singleton {\n    private Singleton() {}\n    private static class SingletonInstance {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    public static Singleton getInstance() {\n        return SingletonInstance.INSTANCE;\n    }\n}\n\n```\n\n注意：内存浪费、线程安全、使用效率\n\n#### 原型模式\n\n定义：从原型实例复制克隆出新实例，而绝不是从类去实例化\n\n用途：\n\n写法：原型类要实现Cloneable接口\n\n\n\n## Spring / Spring MVC\n\n90. 为什么要使用 spring？\n\n1.简介\n\n目的：解决企业应用开发的复杂性\n功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能\n范围：任何Java应用\n简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。\n\n2.轻量　　\n\n从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。\n\n3.控制反转　　\n\nSpring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它\n\n4.面向切面　　\n\nSpring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。\n\n5.容器\n\nSpring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。\n\n6.框架\n\nSpring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。\n\n所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。\n\n#### 解释一下什么是 aop？\n\nAOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。\n\n 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。\n\n使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”\n\n#### 解释一下什么是 ioc？\n\nIOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。\n\n　1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。\n\n　IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：\n\n\n\n大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。\n\n　　我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统\n\n\n\n```\n我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！\n\n我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：\n\n软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。\n\n软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。\n\n通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。\n\n```\n\n\n\n#### spring 有哪些主要模块？\n\nSpring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。\n\n\n\n#### spring 常用的注入方式有哪些？\n\nSpring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：\n\n构造方法注入\nsetter注入\n基于注解的注入\n\n\n\n#### spring 中的 bean 是线程安全的吗？\n\nSpring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。\n\n\n\n#### spring 支持几种 bean 的作用域？\n\n当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：\n\nsingleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例\nprototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例\nrequest：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效\nsession：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效\nglobalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效\n    其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。\n\n如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。\n\n\n\n#### spring 自动装配 bean 有哪些方式？\n\nSpring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。\n\nspring中bean装配有两种方式：\n\n隐式的bean发现机制和自动装配\n在java代码或者XML中进行显示配置\n当然这些方式也可以配合使用。\n\n\n\n#### spring 事务实现方式有哪些？\n\n编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。\n基于 TransactionProxyFactoryBean 的声明式事务管理\n基于 @Transactional 的声明式事务管理\n基于 Aspectj AOP 配置事务\n\n\n\n#### 说一下 spring 的事务隔离？\n\n事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：\n\n脏读：一个事务读到另一个事务未提交的更新数据。\n\n幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。\n\n不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。\n\n\n\n#### 说一下 spring mvc 运行流程？\n\nSpring MVC运行流程图：\n\n\n\nSpring MVC运行描述：\n\n1. 用户发送请求至前端控制器DispatcherServlet\n\n2. DispatcherServlet收到请求调用HandlerMapping处理器映射器。\n\n3. 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。\n\n4. DispatcherServlet通过HandlerAdapter处理器适配器调用处理器\n\n5. HandlerAdapter执行处理器(handler，也叫后端控制器)。\n\n6. Controller执行完成返回ModelAndView\n\n7. HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet\n\n8. DispatcherServlet将ModelAndView传给ViewReslover视图解析器\n\n9. ViewReslover解析后返回具体View对象\n\n10. DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。\n\n11. DispatcherServlet响应用户\n\n  ​    \n\n#### spring mvc 有哪些组件？\n\nSpring MVC的核心组件：\n\nDispatcherServlet：中央控制器，把请求给转发到具体的控制类\nController：具体处理请求的控制器\nHandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略\nModelAndView：服务层返回的数据和视图层的封装类\nViewResolver：视图解析器，解析具体的视图\nInterceptors ：拦截器，负责拦截我们定义的请求然后做处理工作\n\n\n\n#### @RequestMapping 的作用是什么？\n\nRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明。\n\nvalue， method：\n\nvalue：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；\nmethod：指定请求的method类型， GET、POST、PUT、DELETE等；\nconsumes，produces\nconsumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；\nproduces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\nparams，headers\n\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\nheaders：指定request中必须包含某些指定的header值，才能让该方法处理请求。\n\n\n\n#### @Autowired 的作用是什么？\n\n《@Autowired用法详解》：blog.csdn.net/u013257679/article/details/52295106\n\n\n\n## Spring Boot / Spring Cloud\n\n\n\n## Mybatis\n\n#### mybatis 中 #{}和 ${}的区别是什么？\n\n${}是字符串替换；#{}是预编译处理。\n\nMybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；\nMybatis在处理${}时，就是把${}替换成变量的值；\n使用#{}可以有效的防止SQL注入，提高系统安全性。\n\n\n\n#### mybatis 有几种分页方式？\n\n数组分页\nsql分页\n拦截器分页\nRowBounds分页\n\n\n\n#### mybatis 逻辑分页和物理分页的区别是什么？\n\n物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。\n物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。\n\n\n\n#### mybatis 是否支持延迟加载？延迟加载的原理是什么？\n\nMybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。\n\n它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。\n\n当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。\n\n\n\n#### 说一下 mybatis 的一级缓存和二级缓存？\n\n一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。 \n\n二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ； \n\n对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。\n\n\n\n#### mybatis 和 hibernate 的区别有哪些？\n\n（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。\n\n（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 \n\n（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。 \n\n\n\n#### mybatis 有哪些执行器（Executor）？\n\nMybatis有三种基本的执行器（Executor）：\n\nSimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。\nReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。\nBatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。\n\n\n\n#### mybatis 分页插件的实现原理是什么？\n\n分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。\n\n\n\n#### mybatis 如何编写一个自定义插件？\n\n转自：blog.csdn.net/qq_30051265/article/details/80266434\n\n  Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：\n\nExecutor：拦截执行器的方法(log记录) \nStatementHandler ：拦截Sql语法构建的处理 \nParameterHandler ：拦截参数的处理 \nResultSetHandler ：拦截结果集的处理 \nMybatis自定义插件必须实现Interceptor接口：\n\npublic interface Interceptor {\n    Object intercept(Invocation invocation) throws Throwable;\n    Object plugin(Object target);\n    void setProperties(Properties properties);\n}\nintercept方法：拦截器具体处理逻辑方法 \n\nplugin方法：根据签名signatureMap生成动态代理对象 \n\nsetProperties方法：设置Properties属性 \n\n自定义插件demo：\n\n// ExamplePlugin.java\n@Intercepts({@Signature(\n  type= Executor.class,\n  method = \"update\",\n  args = {MappedStatement.class,Object.class})})\npublic class ExamplePlugin implements Interceptor {\n  public Object intercept(Invocation invocation) throws Throwable {\n  Object target = invocation.getTarget(); //被代理对象\n  Method method = invocation.getMethod(); //代理方法\n  Object[] args = invocation.getArgs(); //方法参数\n  // do something ...... 方法拦截前执行代码块\n  Object result = invocation.proceed();\n  // do something .......方法拦截后执行代码块\n  return result;\n  }\n  public Object plugin(Object target) {\n    return Plugin.wrap(target, this);\n  }\n  public void setProperties(Properties properties) {\n  }\n}\n\n一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下： \n\ntype：表示拦截的类，这里是Executor的实现类；\nmethod：表示拦截的方法，这里是拦截Executor的update方法；\nargs：表示方法参数。\n\n\n\n## MySql\n\n#### 数据库的三范式是什么？\n\n第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。\n第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。\n第三范式：任何非主属性不依赖于其它非主属性。\n\n\n\n#### 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了1条数据，此时 id 是几？\n\n表类型如果是 MyISAM ，那 id 就是 8。\n表类型如果是 InnoDB，那 id 就是 8。并没有变化\n\n\n\n#### 如何获取当前数据库版本？\n\n使用 select version() 获取当前 MySQL 数据库版本。\n\n\n\n#### 说一下 ACID 是什么？\n\nAtomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。\nConsistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。\nIsolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\nDurability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n\n\n#### char 和 varchar 的区别是什么？\n\nchar(n) ：固定长度类型，比如订阅 char(10)，当你输入\"abc\"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。\n\nchat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。\n\nvarchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。\n\n所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。\n\n\n\n#### float 和 double 的区别是什么？\n\nfloat 最多可以存储 8 位的十进制数，并在内存中占 4 字节。\ndouble 最可可以存储 16 位的十进制数，并在内存中占 8 字节。\n\n\n\n#### mysql 的内连接、左连接、右连接有什么区别？\n\n内连接关键字：inner join；左连接：left join；右连接：right join。\n\n内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。\n\n\n\n#### mysql 索引是怎么实现的？\n\n索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。\n\n具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。\n\n\n\n#### 怎么验证 mysql 的索引是否满足需求？\n\n使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。\n\nexplain 语法：explain select * from table where type=1。\n\n\n\n#### 说一下数据库的事务隔离？\n\nMySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ\n\n可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。\n\nREAD-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。\nREAD-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。\nREPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。\nSERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。\n\n不可重复读 ：是指在一个事务内，多次读同一数据。\n\n幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。\n\n\n\n#### 说一下 mysql 常用的引擎？\n\nInnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。\n\nMyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。\n\n\n\n#### 说一下 mysql 的行锁和表锁？\n\nMyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。\n\n表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。\n行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。\n\n\n\n#### 说一下乐观锁和悲观锁？\n\n乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。\n悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。\n\n数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。\n\n\n\n#### mysql 问题排查都有哪些手段？\n\n使用 show processlist 命令查看当前所有连接信息。\n使用 explain 命令查询 SQL 语句执行计划。\n开启慢查询日志，查看慢查询的 SQL。\n\n\n\n#### 如何做 mysql 的性能优化？\n\n为搜索字段创建索引。\n避免使用 select *，列出需要查询的字段。\n垂直分割分表。\n选择正确的存储引擎。\n\n\n\n## Redis\n\n#### redis 是什么？\n\nRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n\n#### redis 有哪些使用场景\n\n数据高并发的读写\n海量数据的读写\n对扩展性要求高的数据\n\n\n\n#### redis 有哪些功能？\n\n数据缓存功能\n分布式锁的功能\n支持数据持久化\n支持事务\n支持消息队列\n\n\n\n#### redis 和 memecache 的区别？\n\nmemcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型\nredis的速度比memcached快很多\nredis可以持久化其数据\n\n\n\n#### redis 为什么是单线程的？\n\n因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。\n\n关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。\n\n而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。\n\n\n\n#### 什么是缓存穿透？怎么解决？\n\n缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。\n\n解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n\n\n\n#### redis 支持的数据类型有哪些？\n\nstring、list、hash、set、zset。\n\n\n\n#### redis 支持哪些 java 客户端？\n\nRedisson、Jedis、lettuce等等，官方推荐使用Redisson。\n\n\n\n#### jedis 和 redisson 有哪些区别？\n\nJedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。\n\nRedisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。\n\n\n\n#### redis缓存和数据库数据的一致性？\n\n合理设置缓存的过期时间。\n新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。\n\n\n\n#### redis 持久化有几种方式？\n\nRedis 的持久化有两种方式，或者说有两种策略：\n\nRDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。\n\nAOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。\n\n\n\n#### redis 怎么实现分布式锁？\n\nRedis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。\n\n占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。\n\n\n\n#### redis 分布式锁有什么缺陷？\n\nRedis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。\n\n\n\n#### redis 如何做内存优化？\n\n尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。 \n\n比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。\n\n\n\n#### redis 淘汰策略有哪些？\n\nvolatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。\n\nvolatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。\n\nvolatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。\n\nallkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。\n\nallkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。\nno-enviction（驱逐）：禁止驱逐数据。\n\n\n\n#### redis 常见的性能问题有哪些？\n\n主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。\nRedis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。\n\n\n\n## Zookeeper\n\n#### zookeeper 是什么？\n\nzookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。\n\n\n\n#### zookeeper 都有哪些功能？\n\n集群管理：监控节点存活状态、运行请求等。\n主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。\n分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。\n命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。\n\n\n\n#### 说一下 zookeeper 的通知机制？\n\n客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。\n\n\n\n#### zookeeper 有几种部署模式？\n\nzookeeper 有三种部署模式：\n\n单机部署：一台集群上运行；\n集群部署：多台集群运行；\n伪集群部署：一台集群启动多个 zookeeper 实例运行。\n\n\n\n#### zookeeper 怎么保证主从节点的状态同步？\n\nzookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。\n\n\n\n#### 集群中为什么要有主节点？\n\n在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。\n\n\n\n#### 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？\n\n可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。\n\n## JVM\n\n#### jvm的主要组成部分和作用？\n\n类加载器（ClassLoader）\n运行时数据区（Runtime Data Area）\n执行引擎（Execution Engine）\n本地库接口（Native Interface）\n\n组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。\n\n\n\n#### jvm 运行时数据区？\n\n程序计数器\n虚拟机栈\n本地方法栈\n堆\n方法区\n\n有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。\n\n\n\n#### 堆栈的区别？\n\n栈内存存储的是局部变量而堆内存存储的是实体；\n\n栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；\n\n栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。\n\n\n\n#### 队列和栈是什么？有什么区别？\n\n队列和栈都是被用来预存储数据的。\n队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。\n栈和队列很相似，但它运行对元素进行后进先出进行检索。\n\n\n\n#### 什么是双亲委派模型？\n\n在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。\n\n类加载器分类：\n\n启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；\n其他类加载器：\n扩展类加载器（Extension ClassLoader）：负责加载<java_home style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;\">\\lib\\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</java_home>\n应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。\n\n双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。\n\n#### 说一下类加载的执行过程？\n\n类加载分为以下 5 个步骤：\n\n加载：根据查找路径找到相应的 class 文件然后导入；\n检查：检查加载的 class 文件的正确性；\n准备：给类中的静态变量分配内存空间；\n解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；\n初始化：对静态变量和静态代码块执行初始化工作。\n\n\n\n#### 怎么判断对象是否可以被回收？\n\n一般有两种方法来判断：\n\n引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；\n可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。\n\n\n\n#### java 中都有哪些引用类型？\n\n强引用\n软引用\n弱引用\n虚引用（幽灵引用/幻影引用）\n\n\n\n#### 说一下 jvm 有哪些垃圾回收算法？\n\n标记-清除算法\n标记-整理算法\n复制算法\n分代算法\n\n\n\n#### 说一下 jvm 有哪些垃圾回收器？\n\nSerial：最早的单线程串行垃圾回收器。\nSerial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。\nParNew：是 Serial 的多线程版本。\nParallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。\nParallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。\nCMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。\nG1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。\n\n\n\n#### 详细介绍一下 CMS 垃圾回收器？\n\nCMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。\n\nCMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。\n\n\n\n#### 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？\n\n新生代回收器：Serial、ParNew、Parallel Scavenge\n老年代回收器：Serial Old、Parallel Old、CMS\n整堆回收器：G1\n\n新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。\n\n\n\n#### 简述分代垃圾回收器怎么工作的？\n\n分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。\n\n 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：\n\n 把 Eden + From Survivor 存活的对象放入 To Survivor 区；\n清空 Eden 和 From Survivor 分区；\nFrom Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。\n每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。\n\n老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。\n\n\n\n#### 说一下 jvm 调优的工具？\n\nJDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。\n\njconsole：用于对 JVM 中的内存、线程和类等进行监控；\njvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。\n\n\n\n#### 常用的 jvm 调优的参数都有哪些？\n\n-Xms2g：初始化推大小为 2g；\n-Xmx2g：堆最大内存为 2g；\n-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；\n-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；\n–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；\n-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；\n-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；\n-XX:+PrintGC：开启打印 gc 信息；\n-XX:+PrintGCDetails：打印 gc 详细信息。\n\n## 程序优化\n\n#### 慎用异常\n\ntry-catch不要放在循环中，尽量把try-catsh放到循环体外来提升性能。\n\n```java\npublic void test() {        \n    int a = 0;        \n        try {            \n            for (int i = 0; i < 1000000; i++) {\n                a = a + 1;\n                System.out.println(i);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n#### 使用局部环境\n\n局部变量的访问速度高于类的成员变量。\n\n```java\n//  private static int a = 0;\n    public static void main(String[] args) {        \n       int a = 0;        \n       long start = System.currentTimeMillis();        \n       for (int i = 0; i < 1000000; i++) {\n            a = a + 1;\n            System.out.println(i);\n        }\n        System.out.println(System.currentTimeMillis() - start);\n    }\n```\n\n#### 位运算代替乘除法\n\nHashMap的源码中使用了位运算，a*=2和a/=2，用位运算可以写为a<<=1，a>>=1\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```","source":"_posts/article.md","raw":"---\ntitle: Java开发框架以及高频知识点汇总\ndate: 2017-09-08 22:54:57\ncategories: Java\ntags: develop frame summary\ntop_img: https://i.loli.net/2020/01/07/9z6Pqybp8O1AEMU.jpg\n---\n\n## Java 基础\n\n#### JDK 和 JRE 有什么区别？\n\nJDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。\n\nJRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。\n\n具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。\n\n<!-- more -->\n\n#### == 和 equals 的区别是什么？\n\n== 解读\n\n对于基本类型和引用类型 == 的作用效果是不同的，如下所示：\n\n基本类型：比较的是值是否相同；\n\n引用类型：比较的是引用是否相同；\n\n代码示例：\n\n```java\nString x = \"string\";\nString y = \"string\";\nString z = new String(\"string\");\nSystem.out.println(x==y); // true\nSystem.out.println(x==z); // false\nSystem.out.println(x.equals(y)); // true\nSystem.out.println(x.equals(z)); // true\n```\n\n代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。\n\nequals 解读\n\nequals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。\n\n首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：\n\n```java\nclass Cat {\n    public Cat(String name) {\n        this.name = name;\n    }\n  \tprivate String name;\n \n\t\tpublic String getName() {\n    \t\treturn name;\n\t\t}\n \n\t\tpublic void setName(String name) {\n    \t\tthis.name = name;\n\t\t}\n}\n\nCat c1 = new Cat(\"xx\");\nCat c2 = new Cat(\"xx\");\nSystem.out.println(c1.equals(c2)); // false\n\n```\n\n输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n原来 equals 本质上就是 ==。\n\n那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：\n\n```java\nString s1 = new String(\"老王\");\nString s2 = new String(\"老王\");\nSystem.out.println(s1.equals(s2)); // true\n```\n\n同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下:\n\n```java\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。\n\n总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。\n\n\n\n#### 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？\n\n不对，两个对象的 hashCode()相同，equals()不一定 true。\n\n代码示例：\n\n```java\nString str1 = \"通话\";\nString str2 = \"重地\";\nSystem.out.println(String.format(\"str1：%d | str2：%d\",  str1.hashCode(),str2.hashCode()));\nSystem.out.println(str1.equals(str2));\n```\n\n执行的结果：\n\nstr1：1179395 | str2：1179395\n\nfalse\n\n代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。\n\n\n\n#### final 在 java 中有什么作用？\n\nfinal 修饰的类不能被继承。\n\nfinal 修饰的方法不能被重写。\n\nfinal 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。\n\n\n\n#### java 中的 Math.round(-1.5) 等于多少？\n\n等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃\n\n\n\n#### String 属于基础的数据类型吗？\n\nString 不属于基础类型，属于对象，也就是引用类型。\n\n基础类型有 8 种：byte、boolean、char、short、int、float、long、double。\n\n\n\n#### java 中操作字符串都有哪些类？它们之间有什么区别？\n\n操作字符串的类有：String、StringBuffer、StringBuilder。\n\nString 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。\n\nStringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。\n\n\n\n#### String str=\"i\"与 String str=new String(\"i\")一样吗？\n\n不一样，因为内存的分配方式不一样。String str=\"i\"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(\"i\") 则会被分到堆内存中。\n\n\n\n#### 如何将字符串反转？\n\n使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。\n\n示例代码：\n\n```java\n// StringBuffer reverse\nStringBuffer stringBuffer = new StringBuffer();\nstringBuffer.append(\"abcdefg\");\nSystem.out.println(stringBuffer.reverse()); // gfedcba\n// StringBuilder reverse\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"abcdefg\");\nSystem.out.println(stringBuilder.reverse()); // gfedcba\n```\n\n\n\n#### String 类的常用方法都有那些？\n\nindexOf()：返回指定字符的索引。\ncharAt()：返回指定索引处的字符。\nreplace()：字符串替换。\ntrim()：去除字符串两端空白。\nsplit()：分割字符串，返回一个分割后的字符串数组。\ngetBytes()：返回字符串的 byte 类型数组。\nlength()：返回字符串长度。\ntoLowerCase()：将字符串转成小写字母。\ntoUpperCase()：将字符串转成大写字符。\nsubstring()：截取字符串。\nequals()：字符串比较。\n\n\n\n#### 抽象类必须要有抽象方法吗？\n\n不需要，抽象类不一定非要有抽象方法。\n\n示例代码：\n\n```java\nabstract class Cat {\n    public static void sayHi() {\n        System.out.println(\"hi~\");\n    }\n}\n```\n\n上面代码，抽象类并没有抽象方法但完全可以正常运行。\n\n\n\n#### 普通类和抽象类有哪些区别？\n\n普通类不能包含抽象方法，抽象类可以包含抽象方法。\n抽象类不能直接实例化，普通类可以直接实例化。\n\n\n\n#### 抽象类能使用 final 修饰吗？\n\n不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，编辑器会提示错误信息。\n\n\n\n#### 接口和抽象类有什么区别？\n\n实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。\n构造函数：抽象类可以有构造函数；接口不能有。\nmain 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。\n实现数量：类可以实现很多个接口；但是只能继承一个抽象类。\n访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。\n\n\n\n#### java 中 IO 流分为几种？\n\n按功能来分：输入流（input）、输出流（output）。\n\n按类型来分：字节流和字符流。\n\n字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。\n\n \n\n#### BIO、NIO、AIO 有什么区别？\n\nBIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。\n\nNIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\n\nAIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n\n\n#### Files的常用方法都有哪些？\n\nFiles.exists()：检测文件路径是否存在。\nFiles.createFile()：创建文件。\nFiles.createDirectory()：创建文件夹。\nFiles.delete()：删除一个文件或目录。\nFiles.copy()：复制文件。\nFiles.move()：移动文件。\nFiles.size()：查看文件个数。\nFiles.read()：读取文件。\nFiles.write()：写入文件。\n\n\n\n## java集合/容器\n\n#### java 容器都有哪些？\n\n\n\n#### Collection 和 Collections 有什么区别？\n\njava.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。\n\nCollections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。\n\n\n\n#### List、Set、Map 之间的区别是什么？\n\n\n\n#### HashMap 和 Hashtable 有什么区别？\n\nhashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。\nhashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。\nhashMap允许空键值，而hashTable不允许。\n\n\n\n#### 如何决定使用 HashMap 还是 TreeMap？\n\n对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。\n\n\n\n#### 说一下 HashMap 的实现原理？\n\nHashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 \n\n HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。\n\n当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。\n\n 需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)\n\n\n\n#### 说一下 HashSet 的实现原理？\n\nHashSet底层由HashMap实现\nHashSet的值存放于HashMap的key上\nHashMap的value统一为PRESENT\n\n\n\n#### ArrayList 和 LinkedList 的区别是什么？\n\n最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。\n\n\n\n#### 如何实现数组和 List 之间的转换？\n\nList转换成为数组：调用ArrayList的toArray方法。\n数组转换成为List：调用Arrays的asList方法。\n\n\n\n#### ArrayList 和 Vector 的区别是什么？\n\nVector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 \n\nArrayList比Vector快，它因为有同步，不会过载。 \n\nArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。\n\n\n\n#### Array 和 ArrayList 有何区别？\n\nArray可以容纳基本类型和对象，而ArrayList只能容纳对象。 \nArray是指定大小的，而ArrayList大小是固定的。 \nArray没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。\n\n\n\n#### 在 Queue 中 poll()和 remove()有什么区别？\n\npoll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。\n\n\n\n#### 哪些集合类是线程安全的？\n\nvector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。\nstatck：堆栈类，先进后出。\nhashtable：就比hashmap多了个线程安全。\nenumeration：枚举，相当于迭代器。\n\n\n\n#### 迭代器 Iterator 是什么？\n\n迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。\n\n\n\n#### Iterator 怎么使用？有什么特点？\n\nJava中的Iterator功能比较简单，并且只能单向移动：\n\n　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。\n\n　　(2) 使用next()获得序列中的下一个元素。\n\n　　(3) 使用hasNext()检查序列中是否还有元素。\n\n　　(4) 使用remove()将迭代器新返回的元素删除。\n\n　　Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。\n\n\n\n#### Iterator 和 ListIterator 有什么区别？\n\nIterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 \nIterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 \nListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。\n\n## 多线程\n\n#### 并行和并发有什么区别？\n\n并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。\n并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。\n在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。\n所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。\n\n\n\n#### 线程和进程的区别？\n\n简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。\n\n\n\n#### 守护线程是什么？\n\n守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程\n\n\n\n#### 创建线程有哪几种方式？\n\n①. 继承Thread类创建线程类\n\n定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。\n创建Thread子类的实例，即创建了线程对象。\n调用线程对象的start()方法来启动该线程。\n②. 通过Runnable接口创建线程类\n\n定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。\n创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。\n调用线程对象的start()方法来启动该线程。\n③. 通过Callable和Future创建线程\n\n创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。\n创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。\n使用FutureTask对象作为Thread对象的target创建并启动新线程。\n调用FutureTask对象的get()方法来获得子线程执行结束后的返回值\n\n\n\n#### 说一下 runnable 和 callable 有什么区别？\n\n有点深的问题了，也看出一个Java程序员学习知识的广度。\n\nRunnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；\nCallable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。\n\n\n\n#### 线程有哪些状态？\n\n线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。\n\n创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。\n就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。\n运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。\n阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。\n死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 。\n\n\n\n#### sleep() 和 wait() 有什么区别？\n\nsleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。\n\nwait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。\n\n\n\n#### notify()和 notifyAll()有什么区别？\n\n如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。\n当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。\n优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。\n\n\n\n#### 线程的 run()和 start()有什么区别？\n\n每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。\n\n start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。\n\n run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法\n\n\n\n#### 创建线程池有哪几种方式？\n\n①. newFixedThreadPool(int nThreads)\n\n创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。\n\n②. newCachedThreadPool()\n\n创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。\n\n③. newSingleThreadExecutor()\n\n这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行\n\n④. newScheduledThreadPool(int corePoolSize)\n\n创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。\n\n\n\n#### 线程池都有哪些状态？\n\n线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。\n\n线程池各个状态切换框架图：\n\n\n\n#### 线程池中 submit()和 execute()方法有什么区别？\n\n接收的参数不一样\nsubmit有返回值，而execute没有\nsubmit方便Exception处理\n\n\n\n#### 在 java 程序中怎么保证多线程的运行安全？\n\n线程安全在三个方面体现：\n\n原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；\n可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；\n有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。\n\n\n\n#### 多线程锁的升级原理是什么？\n\n在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。\n\n锁升级的图示过程： \n\n\n\n#### 什么是死锁？\n\n死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。\n\n\n\n#### 怎么防止死锁？\n\n死锁的四个必要条件：\n\n互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源\n请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放\n不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放\n环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系\n这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。\n\n理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。\n\n所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。\n\n此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。\n\n\n\n#### ThreadLocal 是什么？有哪些使用场景？\n\n线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。\n\n\n\n#### 说一下 synchronized 底层实现原理？\n\nsynchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。\n\nJava中每一个对象都可以作为锁，这是synchronized实现同步的基础：\n\n普通同步方法，锁是当前实例对象\n静态同步方法，锁是当前类的class对象\n同步方法块，锁是括号里面的对象\n\n\n\n#### 说一下volatile底层实现原理\n\n#### synchronized 和 volatile 的区别是什么？\n\nvolatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。\nvolatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。\nvolatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。\nvolatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。\nvolatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。\n\n\n\n#### synchronized 和 Lock 有什么区别？\n\n首先synchronized是java内置关键字，在jvm层面，Lock是个java类；\nsynchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；\nsynchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；\n用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；\nsynchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；\nLock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。\n\n\n\n#### synchronized 和 ReentrantLock 区别是什么？\n\nsynchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：\n\nReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 \nReentrantLock可以获取各种锁的信息\nReentrantLock可以灵活地实现多路通知 \n另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word\n\n \n\n#### 说一下 atomic 的原理？\n\nAtomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。\n\nAtomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。\n\n\n\n## 反射\n\n#### 什么是反射？\n\n反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。\n\nJava反射：在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法。\n\nJava反射机制主要提供了以下功能：\n\n在运行时判断任意一个对象所属的类。\n在运行时构造任意一个类的对象。\n在运行时判断任意一个类所具有的成员变量和方法。\n在运行时调用任意一个对象的方法。 \n得到类的字节码文件相同，这三种方式。\n1.Class cls1=类名.class 相对简单，还是需要明确类名\n2.cls1.getclass();必须要明确具体的类，并创建对象\n3.class.forName(\"完整的类名（带包名）\");\n\n\n\n#### 什么是 java 序列化？什么情况下需要序列化？\n\n简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。\n\n什么情况下需要序列化：\n\na）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；\nb）当你想用套接字在网络上传送对象的时候；\nc）当你想通过RMI传输对象的时候；\n\n\n\n#### 动态代理是什么？有哪些应用？\n\n动态代理：\n\n当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。\n\n动态代理的应用：\n\nSpring的AOP\n加事务\n加权限\n加日志\n\n\n\n#### 怎么实现动态代理？\n\n首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。\n\n\n\n## 对象拷贝\n\n#### 为什么要使用克隆？\n\n想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。\n\n\n\n#### 如何实现对象克隆？\n\n有两种方式：\n\n1). 实现Cloneable接口并重写Object类中的clone()方法；\n\n2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。\n注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时\n\n\n\n#### 深拷贝和浅拷贝区别是什么？\n\n浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）\n深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）\n\n\n\n## Java Web\n\n#### jsp 和 servlet 有什么区别？\n\njsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）\njsp更擅长表现于页面显示，servlet更擅长于逻辑控制。\nServlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。\nJsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应\n\n\n\n#### jsp 有哪些内置对象？作用分别是什么？\n\nJSP有9个内置对象：\n\nrequest：封装客户端的请求，其中包含来自GET或POST请求的参数；\nresponse：封装服务器对客户端的响应；\npageContext：通过该对象可以获取其他对象；\nsession：封装用户会话的对象；\napplication：封装服务器运行环境的对象；\nout：输出服务器响应的输出流对象；\nconfig：Web应用的配置对象；\npage：JSP页面本身（相当于Java程序中的this）；\nexception：封装页面抛出异常的对象。\n\n\n\n#### 说一下 jsp 的 4 种作用域？\n\nJSP中的四种作用域包括page、request、session和application，具体来说：\n\npage代表与一个页面相关的对象和属性。\nrequest代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。\nsession代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。\napplication代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。\n\n\n\n#### session 和 cookie 有什么区别？\n\n\n\n#### 说一下 session 的工作原理？\n\n其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了\n\n\n\n#### 如何避免SQL注入\n\n1. PreparedStatement（简单又有效的方法）\n2. 使用正则表达式过滤传入的参数\n3. 字符串过滤\n4. JSP中调用该函数检查是否包函非法字符\n5. JSP页面判断代码\n\n\n\n#### 什么是 XSS 攻击，如何避免？\n\nXSS攻击又称CSS,全称Cross Site Script  （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。\n\n\n\n## 异常\n\n#### throw 和 throws 的区别？\n\nthrows是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型\n\n\n\n#### final、finally、finalize 有什么区别？\n\nfinal可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。\nfinally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。\nfinalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 \n\n\n\n#### try-catch-finally 中哪个部分可以省略？\n\n答：catch 可以省略\n\n原因：\n\n```\n   更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。\n   理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。\n  至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。\n\n```\n\n\n\n#### try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\n\n答：会执行，在 return 前执行。\n\n\n\n#### 常见的异常类有哪些？\n\nNullPointerException：当应用程序试图访问空对象时，则抛出该异常。\nSQLException：提供关于数据库访问错误或其他错误信息的异常。\nIndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 \nNumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。\nFileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。\nIOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。\nClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。\nArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。\nIllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。\nArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 \nNegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。\nNoSuchMethodException：无法找到某一特定方法时，抛出该异常。\nSecurityException：由安全管理器抛出的异常，指示存在安全侵犯。\nUnsupportedOperationException：当不支持请求的操作时，抛出该异常。\nRuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。\n\n\n\n## 网络\n\n#### http 响应码 301 和 302 代表的是什么？有什么区别？\n\n301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。\n\n区别： \n\n301 redirect: 301 代表永久性转移(Permanently Moved)。\n302 redirect: 302 代表暂时性转移(Temporarily Moved )。\n\n\n\n#### forward 和 redirect 的区别？\n\nForward和Redirect代表了两种请求转发方式：直接转发和间接转发。\n\n直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。\n\n间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。\n\n举个通俗的例子：\n\n　　直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；\n\n　　间接转发就相当于：\"A找B借钱，B说没有，让A去找C借\"\n\n\n\n#### 简述 tcp 和 udp的区别？\n\nTCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。\nTCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。\nTcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。\nUDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。\n每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。\nTCP对系统资源要求较多，UDP对系统资源要求较少。\n\n\n\n#### tcp 为什么要三次握手，两次不行吗？为什么？\n\n为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。\n\n如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。\n\n\n\n#### 说一下 tcp 粘包是怎么产生的？\n\n①. 发送方产生粘包\n\n采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。\n\n②. 接收方产生粘包\n\n接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 > 应用层拿数据速度） \n\n\n\n#### OSI 的七层模型都有哪些？\n\n应用层：网络服务与最终用户的一个接口。\n表示层：数据的表示、安全、压缩。\n会话层：建立、管理、终止会话。\n传输层：定义传输数据的协议端口号，以及流控和差错校验。\n网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。\n数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。\n物理层：建立、维护、断开物理连接。\n\n\n\n#### get 和 post 请求有哪些区别？\n\nGET在浏览器回退时是无害的，而POST会再次提交请求。\nGET产生的URL地址可以被Bookmark，而POST不可以。\nGET请求会被浏览器主动cache，而POST不会，除非手动设置。\nGET请求只能进行url编码，而POST支持多种编码方式。\nGET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。\nGET请求在URL中传送的参数是有长度限制的，而POST么有。\n对参数的数据类型，GET只接受ASCII字符，而POST没有限制。\nGET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。\nGET参数通过URL传递，POST放在Request body中\n\n#### 说一下 JSONP 实现原理？\n\njsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返货json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。\n\n\n\n## 设计模式\n\n#### 单例模式\n\n定义：有且仅有一个实例\n\n用途：\n\n双重检查、静态内部类、枚举（推荐使用）\n\n```java\n//双重检查写法\npublic class Singleton {\n    private static volatile Singleton singleton;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (singleton == null) {\n            synchronized (Singleton.class) {\n                if (singleton == null) {\n                    singleton = new Singleton();\n                }\n            }\n        }\n        return singleton;\n    }\n}\n\n```\n\n这两种写法的优点：线程安全；延迟加载；效率较高。\n\n```java\n//静态内部类写法\npublic class Singleton {\n    private Singleton() {}\n    private static class SingletonInstance {\n        private static final Singleton INSTANCE = new Singleton();\n    }\n    public static Singleton getInstance() {\n        return SingletonInstance.INSTANCE;\n    }\n}\n\n```\n\n注意：内存浪费、线程安全、使用效率\n\n#### 原型模式\n\n定义：从原型实例复制克隆出新实例，而绝不是从类去实例化\n\n用途：\n\n写法：原型类要实现Cloneable接口\n\n\n\n## Spring / Spring MVC\n\n90. 为什么要使用 spring？\n\n1.简介\n\n目的：解决企业应用开发的复杂性\n功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能\n范围：任何Java应用\n简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。\n\n2.轻量　　\n\n从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。\n\n3.控制反转　　\n\nSpring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它\n\n4.面向切面　　\n\nSpring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。\n\n5.容器\n\nSpring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。\n\n6.框架\n\nSpring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。\n\n所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。\n\n#### 解释一下什么是 aop？\n\nAOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。\n\n 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。\n\n使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”\n\n#### 解释一下什么是 ioc？\n\nIOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。\n\n　1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。\n\n　IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：\n\n\n\n大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。\n\n　　我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统\n\n\n\n```\n我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！\n\n我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：\n\n软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。\n\n软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。\n\n通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。\n\n```\n\n\n\n#### spring 有哪些主要模块？\n\nSpring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。\n\n\n\n#### spring 常用的注入方式有哪些？\n\nSpring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：\n\n构造方法注入\nsetter注入\n基于注解的注入\n\n\n\n#### spring 中的 bean 是线程安全的吗？\n\nSpring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。\n\n\n\n#### spring 支持几种 bean 的作用域？\n\n当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：\n\nsingleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例\nprototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例\nrequest：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效\nsession：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效\nglobalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效\n    其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。\n\n如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。\n\n\n\n#### spring 自动装配 bean 有哪些方式？\n\nSpring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。\n\nspring中bean装配有两种方式：\n\n隐式的bean发现机制和自动装配\n在java代码或者XML中进行显示配置\n当然这些方式也可以配合使用。\n\n\n\n#### spring 事务实现方式有哪些？\n\n编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。\n基于 TransactionProxyFactoryBean 的声明式事务管理\n基于 @Transactional 的声明式事务管理\n基于 Aspectj AOP 配置事务\n\n\n\n#### 说一下 spring 的事务隔离？\n\n事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：\n\n脏读：一个事务读到另一个事务未提交的更新数据。\n\n幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。\n\n不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。\n\n\n\n#### 说一下 spring mvc 运行流程？\n\nSpring MVC运行流程图：\n\n\n\nSpring MVC运行描述：\n\n1. 用户发送请求至前端控制器DispatcherServlet\n\n2. DispatcherServlet收到请求调用HandlerMapping处理器映射器。\n\n3. 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。\n\n4. DispatcherServlet通过HandlerAdapter处理器适配器调用处理器\n\n5. HandlerAdapter执行处理器(handler，也叫后端控制器)。\n\n6. Controller执行完成返回ModelAndView\n\n7. HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet\n\n8. DispatcherServlet将ModelAndView传给ViewReslover视图解析器\n\n9. ViewReslover解析后返回具体View对象\n\n10. DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。\n\n11. DispatcherServlet响应用户\n\n  ​    \n\n#### spring mvc 有哪些组件？\n\nSpring MVC的核心组件：\n\nDispatcherServlet：中央控制器，把请求给转发到具体的控制类\nController：具体处理请求的控制器\nHandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略\nModelAndView：服务层返回的数据和视图层的封装类\nViewResolver：视图解析器，解析具体的视图\nInterceptors ：拦截器，负责拦截我们定义的请求然后做处理工作\n\n\n\n#### @RequestMapping 的作用是什么？\n\nRequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。\n\nRequestMapping注解有六个属性，下面我们把她分成三类进行说明。\n\nvalue， method：\n\nvalue：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；\nmethod：指定请求的method类型， GET、POST、PUT、DELETE等；\nconsumes，produces\nconsumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；\nproduces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；\nparams，headers\n\nparams： 指定request中必须包含某些参数值是，才让该方法处理。\nheaders：指定request中必须包含某些指定的header值，才能让该方法处理请求。\n\n\n\n#### @Autowired 的作用是什么？\n\n《@Autowired用法详解》：blog.csdn.net/u013257679/article/details/52295106\n\n\n\n## Spring Boot / Spring Cloud\n\n\n\n## Mybatis\n\n#### mybatis 中 #{}和 ${}的区别是什么？\n\n${}是字符串替换；#{}是预编译处理。\n\nMybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；\nMybatis在处理${}时，就是把${}替换成变量的值；\n使用#{}可以有效的防止SQL注入，提高系统安全性。\n\n\n\n#### mybatis 有几种分页方式？\n\n数组分页\nsql分页\n拦截器分页\nRowBounds分页\n\n\n\n#### mybatis 逻辑分页和物理分页的区别是什么？\n\n物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。\n物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。\n\n\n\n#### mybatis 是否支持延迟加载？延迟加载的原理是什么？\n\nMybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。\n\n它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。\n\n当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。\n\n\n\n#### 说一下 mybatis 的一级缓存和二级缓存？\n\n一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。 \n\n二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ； \n\n对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。\n\n\n\n#### mybatis 和 hibernate 的区别有哪些？\n\n（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。\n\n（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 \n\n（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。 \n\n\n\n#### mybatis 有哪些执行器（Executor）？\n\nMybatis有三种基本的执行器（Executor）：\n\nSimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。\nReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。\nBatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。\n\n\n\n#### mybatis 分页插件的实现原理是什么？\n\n分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。\n\n\n\n#### mybatis 如何编写一个自定义插件？\n\n转自：blog.csdn.net/qq_30051265/article/details/80266434\n\n  Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：\n\nExecutor：拦截执行器的方法(log记录) \nStatementHandler ：拦截Sql语法构建的处理 \nParameterHandler ：拦截参数的处理 \nResultSetHandler ：拦截结果集的处理 \nMybatis自定义插件必须实现Interceptor接口：\n\npublic interface Interceptor {\n    Object intercept(Invocation invocation) throws Throwable;\n    Object plugin(Object target);\n    void setProperties(Properties properties);\n}\nintercept方法：拦截器具体处理逻辑方法 \n\nplugin方法：根据签名signatureMap生成动态代理对象 \n\nsetProperties方法：设置Properties属性 \n\n自定义插件demo：\n\n// ExamplePlugin.java\n@Intercepts({@Signature(\n  type= Executor.class,\n  method = \"update\",\n  args = {MappedStatement.class,Object.class})})\npublic class ExamplePlugin implements Interceptor {\n  public Object intercept(Invocation invocation) throws Throwable {\n  Object target = invocation.getTarget(); //被代理对象\n  Method method = invocation.getMethod(); //代理方法\n  Object[] args = invocation.getArgs(); //方法参数\n  // do something ...... 方法拦截前执行代码块\n  Object result = invocation.proceed();\n  // do something .......方法拦截后执行代码块\n  return result;\n  }\n  public Object plugin(Object target) {\n    return Plugin.wrap(target, this);\n  }\n  public void setProperties(Properties properties) {\n  }\n}\n\n一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下： \n\ntype：表示拦截的类，这里是Executor的实现类；\nmethod：表示拦截的方法，这里是拦截Executor的update方法；\nargs：表示方法参数。\n\n\n\n## MySql\n\n#### 数据库的三范式是什么？\n\n第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。\n第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。\n第三范式：任何非主属性不依赖于其它非主属性。\n\n\n\n#### 一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了1条数据，此时 id 是几？\n\n表类型如果是 MyISAM ，那 id 就是 8。\n表类型如果是 InnoDB，那 id 就是 8。并没有变化\n\n\n\n#### 如何获取当前数据库版本？\n\n使用 select version() 获取当前 MySQL 数据库版本。\n\n\n\n#### 说一下 ACID 是什么？\n\nAtomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。\nConsistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。\nIsolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。\nDurability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。\n\n\n\n#### char 和 varchar 的区别是什么？\n\nchar(n) ：固定长度类型，比如订阅 char(10)，当你输入\"abc\"三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。\n\nchat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。\n\nvarchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。\n\n所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。\n\n\n\n#### float 和 double 的区别是什么？\n\nfloat 最多可以存储 8 位的十进制数，并在内存中占 4 字节。\ndouble 最可可以存储 16 位的十进制数，并在内存中占 8 字节。\n\n\n\n#### mysql 的内连接、左连接、右连接有什么区别？\n\n内连接关键字：inner join；左连接：left join；右连接：right join。\n\n内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。\n\n\n\n#### mysql 索引是怎么实现的？\n\n索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。\n\n具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。\n\n\n\n#### 怎么验证 mysql 的索引是否满足需求？\n\n使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。\n\nexplain 语法：explain select * from table where type=1。\n\n\n\n#### 说一下数据库的事务隔离？\n\nMySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ\n\n可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。\n\nREAD-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。\nREAD-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。\nREPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。\nSERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。\n\n不可重复读 ：是指在一个事务内，多次读同一数据。\n\n幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。\n\n\n\n#### 说一下 mysql 常用的引擎？\n\nInnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。\n\nMyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。\n\n\n\n#### 说一下 mysql 的行锁和表锁？\n\nMyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。\n\n表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。\n行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。\n\n\n\n#### 说一下乐观锁和悲观锁？\n\n乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。\n悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。\n\n数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。\n\n\n\n#### mysql 问题排查都有哪些手段？\n\n使用 show processlist 命令查看当前所有连接信息。\n使用 explain 命令查询 SQL 语句执行计划。\n开启慢查询日志，查看慢查询的 SQL。\n\n\n\n#### 如何做 mysql 的性能优化？\n\n为搜索字段创建索引。\n避免使用 select *，列出需要查询的字段。\n垂直分割分表。\n选择正确的存储引擎。\n\n\n\n## Redis\n\n#### redis 是什么？\n\nRedis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n\n#### redis 有哪些使用场景\n\n数据高并发的读写\n海量数据的读写\n对扩展性要求高的数据\n\n\n\n#### redis 有哪些功能？\n\n数据缓存功能\n分布式锁的功能\n支持数据持久化\n支持事务\n支持消息队列\n\n\n\n#### redis 和 memecache 的区别？\n\nmemcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型\nredis的速度比memcached快很多\nredis可以持久化其数据\n\n\n\n#### redis 为什么是单线程的？\n\n因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。\n\n关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。\n\n而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。\n\n\n\n#### 什么是缓存穿透？怎么解决？\n\n缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。\n\n解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n\n\n\n#### redis 支持的数据类型有哪些？\n\nstring、list、hash、set、zset。\n\n\n\n#### redis 支持哪些 java 客户端？\n\nRedisson、Jedis、lettuce等等，官方推荐使用Redisson。\n\n\n\n#### jedis 和 redisson 有哪些区别？\n\nJedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。\n\nRedisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。\n\n\n\n#### redis缓存和数据库数据的一致性？\n\n合理设置缓存的过期时间。\n新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。\n\n\n\n#### redis 持久化有几种方式？\n\nRedis 的持久化有两种方式，或者说有两种策略：\n\nRDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。\n\nAOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。\n\n\n\n#### redis 怎么实现分布式锁？\n\nRedis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。\n\n占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。\n\n\n\n#### redis 分布式锁有什么缺陷？\n\nRedis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。\n\n\n\n#### redis 如何做内存优化？\n\n尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。 \n\n比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。\n\n\n\n#### redis 淘汰策略有哪些？\n\nvolatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。\n\nvolatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。\n\nvolatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。\n\nallkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。\n\nallkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。\nno-enviction（驱逐）：禁止驱逐数据。\n\n\n\n#### redis 常见的性能问题有哪些？\n\n主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。\nRedis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。\n\n\n\n## Zookeeper\n\n#### zookeeper 是什么？\n\nzookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。\n\n\n\n#### zookeeper 都有哪些功能？\n\n集群管理：监控节点存活状态、运行请求等。\n主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。\n分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。\n命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。\n\n\n\n#### 说一下 zookeeper 的通知机制？\n\n客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。\n\n\n\n#### zookeeper 有几种部署模式？\n\nzookeeper 有三种部署模式：\n\n单机部署：一台集群上运行；\n集群部署：多台集群运行；\n伪集群部署：一台集群启动多个 zookeeper 实例运行。\n\n\n\n#### zookeeper 怎么保证主从节点的状态同步？\n\nzookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。\n\n\n\n#### 集群中为什么要有主节点？\n\n在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。\n\n\n\n#### 集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？\n\n可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。\n\n## JVM\n\n#### jvm的主要组成部分和作用？\n\n类加载器（ClassLoader）\n运行时数据区（Runtime Data Area）\n执行引擎（Execution Engine）\n本地库接口（Native Interface）\n\n组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。\n\n\n\n#### jvm 运行时数据区？\n\n程序计数器\n虚拟机栈\n本地方法栈\n堆\n方法区\n\n有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。\n\n\n\n#### 堆栈的区别？\n\n栈内存存储的是局部变量而堆内存存储的是实体；\n\n栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；\n\n栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。\n\n\n\n#### 队列和栈是什么？有什么区别？\n\n队列和栈都是被用来预存储数据的。\n队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。\n栈和队列很相似，但它运行对元素进行后进先出进行检索。\n\n\n\n#### 什么是双亲委派模型？\n\n在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。\n\n类加载器分类：\n\n启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；\n其他类加载器：\n扩展类加载器（Extension ClassLoader）：负责加载<java_home style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;\">\\lib\\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</java_home>\n应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。\n\n双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。\n\n#### 说一下类加载的执行过程？\n\n类加载分为以下 5 个步骤：\n\n加载：根据查找路径找到相应的 class 文件然后导入；\n检查：检查加载的 class 文件的正确性；\n准备：给类中的静态变量分配内存空间；\n解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；\n初始化：对静态变量和静态代码块执行初始化工作。\n\n\n\n#### 怎么判断对象是否可以被回收？\n\n一般有两种方法来判断：\n\n引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；\n可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。\n\n\n\n#### java 中都有哪些引用类型？\n\n强引用\n软引用\n弱引用\n虚引用（幽灵引用/幻影引用）\n\n\n\n#### 说一下 jvm 有哪些垃圾回收算法？\n\n标记-清除算法\n标记-整理算法\n复制算法\n分代算法\n\n\n\n#### 说一下 jvm 有哪些垃圾回收器？\n\nSerial：最早的单线程串行垃圾回收器。\nSerial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。\nParNew：是 Serial 的多线程版本。\nParallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。\nParallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。\nCMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。\nG1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。\n\n\n\n#### 详细介绍一下 CMS 垃圾回收器？\n\nCMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。\n\nCMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。\n\n\n\n#### 新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？\n\n新生代回收器：Serial、ParNew、Parallel Scavenge\n老年代回收器：Serial Old、Parallel Old、CMS\n整堆回收器：G1\n\n新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。\n\n\n\n#### 简述分代垃圾回收器怎么工作的？\n\n分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。\n\n 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：\n\n 把 Eden + From Survivor 存活的对象放入 To Survivor 区；\n清空 Eden 和 From Survivor 分区；\nFrom Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。\n每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。\n\n老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。\n\n\n\n#### 说一下 jvm 调优的工具？\n\nJDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。\n\njconsole：用于对 JVM 中的内存、线程和类等进行监控；\njvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。\n\n\n\n#### 常用的 jvm 调优的参数都有哪些？\n\n-Xms2g：初始化推大小为 2g；\n-Xmx2g：堆最大内存为 2g；\n-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；\n-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；\n–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；\n-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；\n-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；\n-XX:+PrintGC：开启打印 gc 信息；\n-XX:+PrintGCDetails：打印 gc 详细信息。\n\n## 程序优化\n\n#### 慎用异常\n\ntry-catch不要放在循环中，尽量把try-catsh放到循环体外来提升性能。\n\n```java\npublic void test() {        \n    int a = 0;        \n        try {            \n            for (int i = 0; i < 1000000; i++) {\n                a = a + 1;\n                System.out.println(i);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n#### 使用局部环境\n\n局部变量的访问速度高于类的成员变量。\n\n```java\n//  private static int a = 0;\n    public static void main(String[] args) {        \n       int a = 0;        \n       long start = System.currentTimeMillis();        \n       for (int i = 0; i < 1000000; i++) {\n            a = a + 1;\n            System.out.println(i);\n        }\n        System.out.println(System.currentTimeMillis() - start);\n    }\n```\n\n#### 位运算代替乘除法\n\nHashMap的源码中使用了位运算，a*=2和a/=2，用位运算可以写为a<<=1，a>>=1\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```","slug":"article","published":1,"updated":"2020-01-11T05:25:44.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6q61cym0050a6yb8w97o5r0","content":"<h2 id=\"Java-基础\"><a href=\"#Java-基础\" class=\"headerlink\" title=\"Java 基础\"></a>Java 基础</h2><h4 id=\"JDK-和-JRE-有什么区别？\"><a href=\"#JDK-和-JRE-有什么区别？\" class=\"headerlink\" title=\"JDK 和 JRE 有什么区别？\"></a>JDK 和 JRE 有什么区别？</h4><p>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</p>\n<p>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</p>\n<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p>\n<a id=\"more\"></a>\n\n<h4 id=\"和-equals-的区别是什么？\"><a href=\"#和-equals-的区别是什么？\" class=\"headerlink\" title=\"== 和 equals 的区别是什么？\"></a>== 和 equals 的区别是什么？</h4><p>== 解读</p>\n<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>\n<p>基本类型：比较的是值是否相同；</p>\n<p>引用类型：比较的是引用是否相同；</p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String x = <span class=\"string\">\"string\"</span>;</span><br><span class=\"line\">String y = <span class=\"string\">\"string\"</span>;</span><br><span class=\"line\">String z = <span class=\"keyword\">new</span> String(<span class=\"string\">\"string\"</span>);</span><br><span class=\"line\">System.out.println(x==y); <span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(x==z); <span class=\"comment\">// false</span></span><br><span class=\"line\">System.out.println(x.equals(y)); <span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(x.equals(z)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>\n<p>equals 解读</p>\n<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>\n<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cat</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat c1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"xx\"</span>);</span><br><span class=\"line\">Cat c2 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"xx\"</span>);</span><br><span class=\"line\">System.out.println(c1.equals(c2)); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来 equals 本质上就是 ==。</p>\n<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">String s2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">System.out.println(s1.equals(s2)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String anotherString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>\n<p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>\n<h4 id=\"两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？\"><a href=\"#两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？\" class=\"headerlink\" title=\"两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？\"></a>两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h4><p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"通话\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"string\">\"重地\"</span>;</span><br><span class=\"line\">System.out.println(String.format(<span class=\"string\">\"str1：%d | str2：%d\"</span>,  str1.hashCode(),str2.hashCode()));</span><br><span class=\"line\">System.out.println(str1.equals(str2));</span><br></pre></td></tr></table></figure>\n\n<p>执行的结果：</p>\n<p>str1：1179395 | str2：1179395</p>\n<p>false</p>\n<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>\n<h4 id=\"final-在-java-中有什么作用？\"><a href=\"#final-在-java-中有什么作用？\" class=\"headerlink\" title=\"final 在 java 中有什么作用？\"></a>final 在 java 中有什么作用？</h4><p>final 修饰的类不能被继承。</p>\n<p>final 修饰的方法不能被重写。</p>\n<p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>\n<h4 id=\"java-中的-Math-round-1-5-等于多少？\"><a href=\"#java-中的-Math-round-1-5-等于多少？\" class=\"headerlink\" title=\"java 中的 Math.round(-1.5) 等于多少？\"></a>java 中的 Math.round(-1.5) 等于多少？</h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃</p>\n<h4 id=\"String-属于基础的数据类型吗？\"><a href=\"#String-属于基础的数据类型吗？\" class=\"headerlink\" title=\"String 属于基础的数据类型吗？\"></a>String 属于基础的数据类型吗？</h4><p>String 不属于基础类型，属于对象，也就是引用类型。</p>\n<p>基础类型有 8 种：byte、boolean、char、short、int、float、long、double。</p>\n<h4 id=\"java-中操作字符串都有哪些类？它们之间有什么区别？\"><a href=\"#java-中操作字符串都有哪些类？它们之间有什么区别？\" class=\"headerlink\" title=\"java 中操作字符串都有哪些类？它们之间有什么区别？\"></a>java 中操作字符串都有哪些类？它们之间有什么区别？</h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>\n<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>\n<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>\n<h4 id=\"String-str-”i”与-String-str-new-String-“i”-一样吗？\"><a href=\"#String-str-”i”与-String-str-new-String-“i”-一样吗？\" class=\"headerlink\" title=\"String str=”i”与 String str=new String(“i”)一样吗？\"></a>String str=”i”与 String str=new String(“i”)一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>\n<h4 id=\"如何将字符串反转？\"><a href=\"#如何将字符串反转？\" class=\"headerlink\" title=\"如何将字符串反转？\"></a>如何将字符串反转？</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// StringBuffer reverse</span></span><br><span class=\"line\">StringBuffer stringBuffer = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">stringBuffer.append(<span class=\"string\">\"abcdefg\"</span>);</span><br><span class=\"line\">System.out.println(stringBuffer.reverse()); <span class=\"comment\">// gfedcba</span></span><br><span class=\"line\"><span class=\"comment\">// StringBuilder reverse</span></span><br><span class=\"line\">StringBuilder stringBuilder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">stringBuilder.append(<span class=\"string\">\"abcdefg\"</span>);</span><br><span class=\"line\">System.out.println(stringBuilder.reverse()); <span class=\"comment\">// gfedcba</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"String-类的常用方法都有那些？\"><a href=\"#String-类的常用方法都有那些？\" class=\"headerlink\" title=\"String 类的常用方法都有那些？\"></a>String 类的常用方法都有那些？</h4><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p>\n<h4 id=\"抽象类必须要有抽象方法吗？\"><a href=\"#抽象类必须要有抽象方法吗？\" class=\"headerlink\" title=\"抽象类必须要有抽象方法吗？\"></a>抽象类必须要有抽象方法吗？</h4><p>不需要，抽象类不一定非要有抽象方法。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hi~\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>\n<h4 id=\"普通类和抽象类有哪些区别？\"><a href=\"#普通类和抽象类有哪些区别？\" class=\"headerlink\" title=\"普通类和抽象类有哪些区别？\"></a>普通类和抽象类有哪些区别？</h4><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。</p>\n<h4 id=\"抽象类能使用-final-修饰吗？\"><a href=\"#抽象类能使用-final-修饰吗？\" class=\"headerlink\" title=\"抽象类能使用 final 修饰吗？\"></a>抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，编辑器会提示错误信息。</p>\n<h4 id=\"接口和抽象类有什么区别？\"><a href=\"#接口和抽象类有什么区别？\" class=\"headerlink\" title=\"接口和抽象类有什么区别？\"></a>接口和抽象类有什么区别？</h4><p>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。<br>构造函数：抽象类可以有构造函数；接口不能有。<br>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。<br>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。<br>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p>\n<h4 id=\"java-中-IO-流分为几种？\"><a href=\"#java-中-IO-流分为几种？\" class=\"headerlink\" title=\"java 中 IO 流分为几种？\"></a>java 中 IO 流分为几种？</h4><p>按功能来分：输入流（input）、输出流（output）。</p>\n<p>按类型来分：字节流和字符流。</p>\n<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>\n<h4 id=\"BIO、NIO、AIO-有什么区别？\"><a href=\"#BIO、NIO、AIO-有什么区别？\" class=\"headerlink\" title=\"BIO、NIO、AIO 有什么区别？\"></a>BIO、NIO、AIO 有什么区别？</h4><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p>\n<p>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</p>\n<p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>\n<h4 id=\"Files的常用方法都有哪些？\"><a href=\"#Files的常用方法都有哪些？\" class=\"headerlink\" title=\"Files的常用方法都有哪些？\"></a>Files的常用方法都有哪些？</h4><p>Files.exists()：检测文件路径是否存在。<br>Files.createFile()：创建文件。<br>Files.createDirectory()：创建文件夹。<br>Files.delete()：删除一个文件或目录。<br>Files.copy()：复制文件。<br>Files.move()：移动文件。<br>Files.size()：查看文件个数。<br>Files.read()：读取文件。<br>Files.write()：写入文件。</p>\n<h2 id=\"java集合-容器\"><a href=\"#java集合-容器\" class=\"headerlink\" title=\"java集合/容器\"></a>java集合/容器</h2><h4 id=\"java-容器都有哪些？\"><a href=\"#java-容器都有哪些？\" class=\"headerlink\" title=\"java 容器都有哪些？\"></a>java 容器都有哪些？</h4><h4 id=\"Collection-和-Collections-有什么区别？\"><a href=\"#Collection-和-Collections-有什么区别？\" class=\"headerlink\" title=\"Collection 和 Collections 有什么区别？\"></a>Collection 和 Collections 有什么区别？</h4><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p>\n<p>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p>\n<h4 id=\"List、Set、Map-之间的区别是什么？\"><a href=\"#List、Set、Map-之间的区别是什么？\" class=\"headerlink\" title=\"List、Set、Map 之间的区别是什么？\"></a>List、Set、Map 之间的区别是什么？</h4><h4 id=\"HashMap-和-Hashtable-有什么区别？\"><a href=\"#HashMap-和-Hashtable-有什么区别？\" class=\"headerlink\" title=\"HashMap 和 Hashtable 有什么区别？\"></a>HashMap 和 Hashtable 有什么区别？</h4><p>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。<br>hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。<br>hashMap允许空键值，而hashTable不允许。</p>\n<h4 id=\"如何决定使用-HashMap-还是-TreeMap？\"><a href=\"#如何决定使用-HashMap-还是-TreeMap？\" class=\"headerlink\" title=\"如何决定使用 HashMap 还是 TreeMap？\"></a>如何决定使用 HashMap 还是 TreeMap？</h4><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p>\n<h4 id=\"说一下-HashMap-的实现原理？\"><a href=\"#说一下-HashMap-的实现原理？\" class=\"headerlink\" title=\"说一下 HashMap 的实现原理？\"></a>说一下 HashMap 的实现原理？</h4><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 </p>\n<p> HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>\n<p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p>\n<p> 需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p>\n<h4 id=\"说一下-HashSet-的实现原理？\"><a href=\"#说一下-HashSet-的实现原理？\" class=\"headerlink\" title=\"说一下 HashSet 的实现原理？\"></a>说一下 HashSet 的实现原理？</h4><p>HashSet底层由HashMap实现<br>HashSet的值存放于HashMap的key上<br>HashMap的value统一为PRESENT</p>\n<h4 id=\"ArrayList-和-LinkedList-的区别是什么？\"><a href=\"#ArrayList-和-LinkedList-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 的区别是什么？\"></a>ArrayList 和 LinkedList 的区别是什么？</h4><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p>\n<h4 id=\"如何实现数组和-List-之间的转换？\"><a href=\"#如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现数组和 List 之间的转换？\"></a>如何实现数组和 List 之间的转换？</h4><p>List转换成为数组：调用ArrayList的toArray方法。<br>数组转换成为List：调用Arrays的asList方法。</p>\n<h4 id=\"ArrayList-和-Vector-的区别是什么？\"><a href=\"#ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别是什么？\"></a>ArrayList 和 Vector 的区别是什么？</h4><p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 </p>\n<p>ArrayList比Vector快，它因为有同步，不会过载。 </p>\n<p>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>\n<h4 id=\"Array-和-ArrayList-有何区别？\"><a href=\"#Array-和-ArrayList-有何区别？\" class=\"headerlink\" title=\"Array 和 ArrayList 有何区别？\"></a>Array 和 ArrayList 有何区别？</h4><p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。<br>Array是指定大小的，而ArrayList大小是固定的。<br>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</p>\n<h4 id=\"在-Queue-中-poll-和-remove-有什么区别？\"><a href=\"#在-Queue-中-poll-和-remove-有什么区别？\" class=\"headerlink\" title=\"在 Queue 中 poll()和 remove()有什么区别？\"></a>在 Queue 中 poll()和 remove()有什么区别？</h4><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>\n<h4 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h4><p>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。<br>statck：堆栈类，先进后出。<br>hashtable：就比hashmap多了个线程安全。<br>enumeration：枚举，相当于迭代器。</p>\n<h4 id=\"迭代器-Iterator-是什么？\"><a href=\"#迭代器-Iterator-是什么？\" class=\"headerlink\" title=\"迭代器 Iterator 是什么？\"></a>迭代器 Iterator 是什么？</h4><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p>\n<h4 id=\"Iterator-怎么使用？有什么特点？\"><a href=\"#Iterator-怎么使用？有什么特点？\" class=\"headerlink\" title=\"Iterator 怎么使用？有什么特点？\"></a>Iterator 怎么使用？有什么特点？</h4><p>Java中的Iterator功能比较简单，并且只能单向移动：</p>\n<p>　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</p>\n<p>　　(2) 使用next()获得序列中的下一个元素。</p>\n<p>　　(3) 使用hasNext()检查序列中是否还有元素。</p>\n<p>　　(4) 使用remove()将迭代器新返回的元素删除。</p>\n<p>　　Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p>\n<h4 id=\"Iterator-和-ListIterator-有什么区别？\"><a href=\"#Iterator-和-ListIterator-有什么区别？\" class=\"headerlink\" title=\"Iterator 和 ListIterator 有什么区别？\"></a>Iterator 和 ListIterator 有什么区别？</h4><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><h4 id=\"并行和并发有什么区别？\"><a href=\"#并行和并发有什么区别？\" class=\"headerlink\" title=\"并行和并发有什么区别？\"></a>并行和并发有什么区别？</h4><p>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。<br>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p>\n<h4 id=\"线程和进程的区别？\"><a href=\"#线程和进程的区别？\" class=\"headerlink\" title=\"线程和进程的区别？\"></a>线程和进程的区别？</h4><p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>\n<h4 id=\"守护线程是什么？\"><a href=\"#守护线程是什么？\" class=\"headerlink\" title=\"守护线程是什么？\"></a>守护线程是什么？</h4><p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程</p>\n<h4 id=\"创建线程有哪几种方式？\"><a href=\"#创建线程有哪几种方式？\" class=\"headerlink\" title=\"创建线程有哪几种方式？\"></a>创建线程有哪几种方式？</h4><p>①. 继承Thread类创建线程类</p>\n<p>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>创建Thread子类的实例，即创建了线程对象。<br>调用线程对象的start()方法来启动该线程。<br>②. 通过Runnable接口创建线程类</p>\n<p>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。<br>调用线程对象的start()方法来启动该线程。<br>③. 通过Callable和Future创建线程</p>\n<p>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>\n<h4 id=\"说一下-runnable-和-callable-有什么区别？\"><a href=\"#说一下-runnable-和-callable-有什么区别？\" class=\"headerlink\" title=\"说一下 runnable 和 callable 有什么区别？\"></a>说一下 runnable 和 callable 有什么区别？</h4><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p>\n<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；<br>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>\n<h4 id=\"线程有哪些状态？\"><a href=\"#线程有哪些状态？\" class=\"headerlink\" title=\"线程有哪些状态？\"></a>线程有哪些状态？</h4><p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>\n<p>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。<br>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。<br>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。<br>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。<br>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 。</p>\n<h4 id=\"sleep-和-wait-有什么区别？\"><a href=\"#sleep-和-wait-有什么区别？\" class=\"headerlink\" title=\"sleep() 和 wait() 有什么区别？\"></a>sleep() 和 wait() 有什么区别？</h4><p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>\n<p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。</p>\n<h4 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify()和 notifyAll()有什么区别？\"></a>notify()和 notifyAll()有什么区别？</h4><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。<br>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>\n<h4 id=\"线程的-run-和-start-有什么区别？\"><a href=\"#线程的-run-和-start-有什么区别？\" class=\"headerlink\" title=\"线程的 run()和 start()有什么区别？\"></a>线程的 run()和 start()有什么区别？</h4><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>\n<p> start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>\n<p> run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法</p>\n<h4 id=\"创建线程池有哪几种方式？\"><a href=\"#创建线程池有哪几种方式？\" class=\"headerlink\" title=\"创建线程池有哪几种方式？\"></a>创建线程池有哪几种方式？</h4><p>①. newFixedThreadPool(int nThreads)</p>\n<p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>\n<p>②. newCachedThreadPool()</p>\n<p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>\n<p>③. newSingleThreadExecutor()</p>\n<p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行</p>\n<p>④. newScheduledThreadPool(int corePoolSize)</p>\n<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>\n<h4 id=\"线程池都有哪些状态？\"><a href=\"#线程池都有哪些状态？\" class=\"headerlink\" title=\"线程池都有哪些状态？\"></a>线程池都有哪些状态？</h4><p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p>\n<p>线程池各个状态切换框架图：</p>\n<h4 id=\"线程池中-submit-和-execute-方法有什么区别？\"><a href=\"#线程池中-submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"线程池中 submit()和 execute()方法有什么区别？\"></a>线程池中 submit()和 execute()方法有什么区别？</h4><p>接收的参数不一样<br>submit有返回值，而execute没有<br>submit方便Exception处理</p>\n<h4 id=\"在-java-程序中怎么保证多线程的运行安全？\"><a href=\"#在-java-程序中怎么保证多线程的运行安全？\" class=\"headerlink\" title=\"在 java 程序中怎么保证多线程的运行安全？\"></a>在 java 程序中怎么保证多线程的运行安全？</h4><p>线程安全在三个方面体现：</p>\n<p>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；<br>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；<br>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p>\n<h4 id=\"多线程锁的升级原理是什么？\"><a href=\"#多线程锁的升级原理是什么？\" class=\"headerlink\" title=\"多线程锁的升级原理是什么？\"></a>多线程锁的升级原理是什么？</h4><p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p>\n<p>锁升级的图示过程： </p>\n<h4 id=\"什么是死锁？\"><a href=\"#什么是死锁？\" class=\"headerlink\" title=\"什么是死锁？\"></a>什么是死锁？</h4><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p>\n<h4 id=\"怎么防止死锁？\"><a href=\"#怎么防止死锁？\" class=\"headerlink\" title=\"怎么防止死锁？\"></a>怎么防止死锁？</h4><p>死锁的四个必要条件：</p>\n<p>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源<br>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放<br>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放<br>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p>\n<p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p>\n<p>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。</p>\n<p>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>\n<h4 id=\"ThreadLocal-是什么？有哪些使用场景？\"><a href=\"#ThreadLocal-是什么？有哪些使用场景？\" class=\"headerlink\" title=\"ThreadLocal 是什么？有哪些使用场景？\"></a>ThreadLocal 是什么？有哪些使用场景？</h4><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>\n<h4 id=\"说一下-synchronized-底层实现原理？\"><a href=\"#说一下-synchronized-底层实现原理？\" class=\"headerlink\" title=\"说一下 synchronized 底层实现原理？\"></a>说一下 synchronized 底层实现原理？</h4><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>\n<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>\n<p>普通同步方法，锁是当前实例对象<br>静态同步方法，锁是当前类的class对象<br>同步方法块，锁是括号里面的对象</p>\n<h4 id=\"说一下volatile底层实现原理\"><a href=\"#说一下volatile底层实现原理\" class=\"headerlink\" title=\"说一下volatile底层实现原理\"></a>说一下volatile底层实现原理</h4><h4 id=\"synchronized-和-volatile-的区别是什么？\"><a href=\"#synchronized-和-volatile-的区别是什么？\" class=\"headerlink\" title=\"synchronized 和 volatile 的区别是什么？\"></a>synchronized 和 volatile 的区别是什么？</h4><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。<br>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>\n<h4 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h4><p>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；<br>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；<br>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；<br>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；<br>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；<br>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p>\n<h4 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h4><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>\n<p>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br>ReentrantLock可以获取各种锁的信息<br>ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word</p>\n<h4 id=\"说一下-atomic-的原理？\"><a href=\"#说一下-atomic-的原理？\" class=\"headerlink\" title=\"说一下 atomic 的原理？\"></a>说一下 atomic 的原理？</h4><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p>\n<p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h4 id=\"什么是反射？\"><a href=\"#什么是反射？\" class=\"headerlink\" title=\"什么是反射？\"></a>什么是反射？</h4><p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。</p>\n<p>Java反射：在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法。</p>\n<p>Java反射机制主要提供了以下功能：</p>\n<p>在运行时判断任意一个对象所属的类。<br>在运行时构造任意一个类的对象。<br>在运行时判断任意一个类所具有的成员变量和方法。<br>在运行时调用任意一个对象的方法。<br>得到类的字节码文件相同，这三种方式。<br>1.Class cls1=类名.class 相对简单，还是需要明确类名<br>2.cls1.getclass();必须要明确具体的类，并创建对象<br>3.class.forName(“完整的类名（带包名）”);</p>\n<h4 id=\"什么是-java-序列化？什么情况下需要序列化？\"><a href=\"#什么是-java-序列化？什么情况下需要序列化？\" class=\"headerlink\" title=\"什么是 java 序列化？什么情况下需要序列化？\"></a>什么是 java 序列化？什么情况下需要序列化？</h4><p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p>\n<p>什么情况下需要序列化：</p>\n<p>a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>b）当你想用套接字在网络上传送对象的时候；<br>c）当你想通过RMI传输对象的时候；</p>\n<h4 id=\"动态代理是什么？有哪些应用？\"><a href=\"#动态代理是什么？有哪些应用？\" class=\"headerlink\" title=\"动态代理是什么？有哪些应用？\"></a>动态代理是什么？有哪些应用？</h4><p>动态代理：</p>\n<p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p>\n<p>动态代理的应用：</p>\n<p>Spring的AOP<br>加事务<br>加权限<br>加日志</p>\n<h4 id=\"怎么实现动态代理？\"><a href=\"#怎么实现动态代理？\" class=\"headerlink\" title=\"怎么实现动态代理？\"></a>怎么实现动态代理？</h4><p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p>\n<h2 id=\"对象拷贝\"><a href=\"#对象拷贝\" class=\"headerlink\" title=\"对象拷贝\"></a>对象拷贝</h2><h4 id=\"为什么要使用克隆？\"><a href=\"#为什么要使用克隆？\" class=\"headerlink\" title=\"为什么要使用克隆？\"></a>为什么要使用克隆？</h4><p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p>\n<h4 id=\"如何实现对象克隆？\"><a href=\"#如何实现对象克隆？\" class=\"headerlink\" title=\"如何实现对象克隆？\"></a>如何实现对象克隆？</h4><p>有两种方式：</p>\n<p>1). 实现Cloneable接口并重写Object类中的clone()方法；</p>\n<p>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。<br>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时</p>\n<h4 id=\"深拷贝和浅拷贝区别是什么？\"><a href=\"#深拷贝和浅拷贝区别是什么？\" class=\"headerlink\" title=\"深拷贝和浅拷贝区别是什么？\"></a>深拷贝和浅拷贝区别是什么？</h4><p>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）<br>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</p>\n<h2 id=\"Java-Web\"><a href=\"#Java-Web\" class=\"headerlink\" title=\"Java Web\"></a>Java Web</h2><h4 id=\"jsp-和-servlet-有什么区别？\"><a href=\"#jsp-和-servlet-有什么区别？\" class=\"headerlink\" title=\"jsp 和 servlet 有什么区别？\"></a>jsp 和 servlet 有什么区别？</h4><p>jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）<br>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。<br>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。<br>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应</p>\n<h4 id=\"jsp-有哪些内置对象？作用分别是什么？\"><a href=\"#jsp-有哪些内置对象？作用分别是什么？\" class=\"headerlink\" title=\"jsp 有哪些内置对象？作用分别是什么？\"></a>jsp 有哪些内置对象？作用分别是什么？</h4><p>JSP有9个内置对象：</p>\n<p>request：封装客户端的请求，其中包含来自GET或POST请求的参数；<br>response：封装服务器对客户端的响应；<br>pageContext：通过该对象可以获取其他对象；<br>session：封装用户会话的对象；<br>application：封装服务器运行环境的对象；<br>out：输出服务器响应的输出流对象；<br>config：Web应用的配置对象；<br>page：JSP页面本身（相当于Java程序中的this）；<br>exception：封装页面抛出异常的对象。</p>\n<h4 id=\"说一下-jsp-的-4-种作用域？\"><a href=\"#说一下-jsp-的-4-种作用域？\" class=\"headerlink\" title=\"说一下 jsp 的 4 种作用域？\"></a>说一下 jsp 的 4 种作用域？</h4><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p>\n<p>page代表与一个页面相关的对象和属性。<br>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。<br>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。<br>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</p>\n<h4 id=\"session-和-cookie-有什么区别？\"><a href=\"#session-和-cookie-有什么区别？\" class=\"headerlink\" title=\"session 和 cookie 有什么区别？\"></a>session 和 cookie 有什么区别？</h4><h4 id=\"说一下-session-的工作原理？\"><a href=\"#说一下-session-的工作原理？\" class=\"headerlink\" title=\"说一下 session 的工作原理？\"></a>说一下 session 的工作原理？</h4><p>其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了</p>\n<h4 id=\"如何避免SQL注入\"><a href=\"#如何避免SQL注入\" class=\"headerlink\" title=\"如何避免SQL注入\"></a>如何避免SQL注入</h4><ol>\n<li>PreparedStatement（简单又有效的方法）</li>\n<li>使用正则表达式过滤传入的参数</li>\n<li>字符串过滤</li>\n<li>JSP中调用该函数检查是否包函非法字符</li>\n<li>JSP页面判断代码</li>\n</ol>\n<h4 id=\"什么是-XSS-攻击，如何避免？\"><a href=\"#什么是-XSS-攻击，如何避免？\" class=\"headerlink\" title=\"什么是 XSS 攻击，如何避免？\"></a>什么是 XSS 攻击，如何避免？</h4><p>XSS攻击又称CSS,全称Cross Site Script  （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><h4 id=\"throw-和-throws-的区别？\"><a href=\"#throw-和-throws-的区别？\" class=\"headerlink\" title=\"throw 和 throws 的区别？\"></a>throw 和 throws 的区别？</h4><p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型</p>\n<h4 id=\"final、finally、finalize-有什么区别？\"><a href=\"#final、finally、finalize-有什么区别？\" class=\"headerlink\" title=\"final、finally、finalize 有什么区别？\"></a>final、finally、finalize 有什么区别？</h4><p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 </p>\n<h4 id=\"try-catch-finally-中哪个部分可以省略？\"><a href=\"#try-catch-finally-中哪个部分可以省略？\" class=\"headerlink\" title=\"try-catch-finally 中哪个部分可以省略？\"></a>try-catch-finally 中哪个部分可以省略？</h4><p>答：catch 可以省略</p>\n<p>原因：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</span><br><span class=\"line\"> 理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</span><br><span class=\"line\">至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\"><a href=\"#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\" class=\"headerlink\" title=\"try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h4><p>答：会执行，在 return 前执行。</p>\n<h4 id=\"常见的异常类有哪些？\"><a href=\"#常见的异常类有哪些？\" class=\"headerlink\" title=\"常见的异常类有哪些？\"></a>常见的异常类有哪些？</h4><p>NullPointerException：当应用程序试图访问空对象时，则抛出该异常。<br>SQLException：提供关于数据库访问错误或其他错误信息的异常。<br>IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。<br>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。<br>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。<br>IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。<br>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。<br>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。<br>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。<br>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。<br>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。<br>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。<br>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。<br>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。<br>RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h4 id=\"http-响应码-301-和-302-代表的是什么？有什么区别？\"><a href=\"#http-响应码-301-和-302-代表的是什么？有什么区别？\" class=\"headerlink\" title=\"http 响应码 301 和 302 代表的是什么？有什么区别？\"></a>http 响应码 301 和 302 代表的是什么？有什么区别？</h4><p>301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。</p>\n<p>区别： </p>\n<p>301 redirect: 301 代表永久性转移(Permanently Moved)。<br>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</p>\n<h4 id=\"forward-和-redirect-的区别？\"><a href=\"#forward-和-redirect-的区别？\" class=\"headerlink\" title=\"forward 和 redirect 的区别？\"></a>forward 和 redirect 的区别？</h4><p>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。</p>\n<p>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</p>\n<p>间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p>\n<p>举个通俗的例子：</p>\n<p>　　直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</p>\n<p>　　间接转发就相当于：”A找B借钱，B说没有，让A去找C借”</p>\n<h4 id=\"简述-tcp-和-udp的区别？\"><a href=\"#简述-tcp-和-udp的区别？\" class=\"headerlink\" title=\"简述 tcp 和 udp的区别？\"></a>简述 tcp 和 udp的区别？</h4><p>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。<br>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。<br>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。<br>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。<br>TCP对系统资源要求较多，UDP对系统资源要求较少。</p>\n<h4 id=\"tcp-为什么要三次握手，两次不行吗？为什么？\"><a href=\"#tcp-为什么要三次握手，两次不行吗？为什么？\" class=\"headerlink\" title=\"tcp 为什么要三次握手，两次不行吗？为什么？\"></a>tcp 为什么要三次握手，两次不行吗？为什么？</h4><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p>\n<p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p>\n<h4 id=\"说一下-tcp-粘包是怎么产生的？\"><a href=\"#说一下-tcp-粘包是怎么产生的？\" class=\"headerlink\" title=\"说一下 tcp 粘包是怎么产生的？\"></a>说一下 tcp 粘包是怎么产生的？</h4><p>①. 发送方产生粘包</p>\n<p>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>\n<p>②. 接收方产生粘包</p>\n<p>接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度） </p>\n<h4 id=\"OSI-的七层模型都有哪些？\"><a href=\"#OSI-的七层模型都有哪些？\" class=\"headerlink\" title=\"OSI 的七层模型都有哪些？\"></a>OSI 的七层模型都有哪些？</h4><p>应用层：网络服务与最终用户的一个接口。<br>表示层：数据的表示、安全、压缩。<br>会话层：建立、管理、终止会话。<br>传输层：定义传输数据的协议端口号，以及流控和差错校验。<br>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。<br>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。<br>物理层：建立、维护、断开物理连接。</p>\n<h4 id=\"get-和-post-请求有哪些区别？\"><a href=\"#get-和-post-请求有哪些区别？\" class=\"headerlink\" title=\"get 和 post 请求有哪些区别？\"></a>get 和 post 请求有哪些区别？</h4><p>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET产生的URL地址可以被Bookmark，而POST不可以。<br>GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST么有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body中</p>\n<h4 id=\"说一下-JSONP-实现原理？\"><a href=\"#说一下-JSONP-实现原理？\" class=\"headerlink\" title=\"说一下 JSONP 实现原理？\"></a>说一下 JSONP 实现原理？</h4><p>jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返货json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><p>定义：有且仅有一个实例</p>\n<p>用途：</p>\n<p>双重检查、静态内部类、枚举（推荐使用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//双重检查写法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton singleton;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两种写法的优点：线程安全；延迟加载；效率较高。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//静态内部类写法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonInstance</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonInstance.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：内存浪费、线程安全、使用效率</p>\n<h4 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h4><p>定义：从原型实例复制克隆出新实例，而绝不是从类去实例化</p>\n<p>用途：</p>\n<p>写法：原型类要实现Cloneable接口</p>\n<h2 id=\"Spring-Spring-MVC\"><a href=\"#Spring-Spring-MVC\" class=\"headerlink\" title=\"Spring / Spring MVC\"></a>Spring / Spring MVC</h2><ol start=\"90\">\n<li>为什么要使用 spring？</li>\n</ol>\n<p>1.简介</p>\n<p>目的：解决企业应用开发的复杂性<br>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能<br>范围：任何Java应用<br>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p>\n<p>2.轻量　　</p>\n<p>从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</p>\n<p>3.控制反转　　</p>\n<p>Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它</p>\n<p>4.面向切面　　</p>\n<p>Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</p>\n<p>5.容器</p>\n<p>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</p>\n<p>6.框架</p>\n<p>Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</p>\n<p>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p>\n<h4 id=\"解释一下什么是-aop？\"><a href=\"#解释一下什么是-aop？\" class=\"headerlink\" title=\"解释一下什么是 aop？\"></a>解释一下什么是 aop？</h4><p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p> 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p>\n<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>\n<h4 id=\"解释一下什么是-ioc？\"><a href=\"#解释一下什么是-ioc？\" class=\"headerlink\" title=\"解释一下什么是 ioc？\"></a>解释一下什么是 ioc？</h4><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</p>\n<p>　1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p>\n<p>　IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：</p>\n<p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p>\n<p>　　我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！</span><br><span class=\"line\"></span><br><span class=\"line\">我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：</span><br><span class=\"line\"></span><br><span class=\"line\">软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</span><br><span class=\"line\"></span><br><span class=\"line\">软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</span><br><span class=\"line\"></span><br><span class=\"line\">通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"spring-有哪些主要模块？\"><a href=\"#spring-有哪些主要模块？\" class=\"headerlink\" title=\"spring 有哪些主要模块？\"></a>spring 有哪些主要模块？</h4><p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p>\n<h4 id=\"spring-常用的注入方式有哪些？\"><a href=\"#spring-常用的注入方式有哪些？\" class=\"headerlink\" title=\"spring 常用的注入方式有哪些？\"></a>spring 常用的注入方式有哪些？</h4><p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p>\n<p>构造方法注入<br>setter注入<br>基于注解的注入</p>\n<h4 id=\"spring-中的-bean-是线程安全的吗？\"><a href=\"#spring-中的-bean-是线程安全的吗？\" class=\"headerlink\" title=\"spring 中的 bean 是线程安全的吗？\"></a>spring 中的 bean 是线程安全的吗？</h4><p>Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</p>\n<h4 id=\"spring-支持几种-bean-的作用域？\"><a href=\"#spring-支持几种-bean-的作用域？\" class=\"headerlink\" title=\"spring 支持几种 bean 的作用域？\"></a>spring 支持几种 bean 的作用域？</h4><p>当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p>\n<p>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例<br>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例<br>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效<br>session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效<br>globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效<br>    其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</p>\n<p>如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p>\n<h4 id=\"spring-自动装配-bean-有哪些方式？\"><a href=\"#spring-自动装配-bean-有哪些方式？\" class=\"headerlink\" title=\"spring 自动装配 bean 有哪些方式？\"></a>spring 自动装配 bean 有哪些方式？</h4><p>Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。</p>\n<p>spring中bean装配有两种方式：</p>\n<p>隐式的bean发现机制和自动装配<br>在java代码或者XML中进行显示配置<br>当然这些方式也可以配合使用。</p>\n<h4 id=\"spring-事务实现方式有哪些？\"><a href=\"#spring-事务实现方式有哪些？\" class=\"headerlink\" title=\"spring 事务实现方式有哪些？\"></a>spring 事务实现方式有哪些？</h4><p>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。<br>基于 TransactionProxyFactoryBean 的声明式事务管理<br>基于 @Transactional 的声明式事务管理<br>基于 Aspectj AOP 配置事务</p>\n<h4 id=\"说一下-spring-的事务隔离？\"><a href=\"#说一下-spring-的事务隔离？\" class=\"headerlink\" title=\"说一下 spring 的事务隔离？\"></a>说一下 spring 的事务隔离？</h4><p>事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p>\n<p>脏读：一个事务读到另一个事务未提交的更新数据。</p>\n<p>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</p>\n<p>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</p>\n<h4 id=\"说一下-spring-mvc-运行流程？\"><a href=\"#说一下-spring-mvc-运行流程？\" class=\"headerlink\" title=\"说一下 spring mvc 运行流程？\"></a>说一下 spring mvc 运行流程？</h4><p>Spring MVC运行流程图：</p>\n<p>Spring MVC运行描述：</p>\n<ol>\n<li><p>用户发送请求至前端控制器DispatcherServlet</p>\n</li>\n<li><p>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>\n</li>\n<li><p>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>\n</li>\n<li><p>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</p>\n</li>\n<li><p>HandlerAdapter执行处理器(handler，也叫后端控制器)。</p>\n</li>\n<li><p>Controller执行完成返回ModelAndView</p>\n</li>\n<li><p>HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet</p>\n</li>\n<li><p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p>\n</li>\n<li><p>ViewReslover解析后返回具体View对象</p>\n</li>\n<li><p>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p>\n</li>\n<li><p>DispatcherServlet响应用户</p>\n<p>​    </p>\n</li>\n</ol>\n<h4 id=\"spring-mvc-有哪些组件？\"><a href=\"#spring-mvc-有哪些组件？\" class=\"headerlink\" title=\"spring mvc 有哪些组件？\"></a>spring mvc 有哪些组件？</h4><p>Spring MVC的核心组件：</p>\n<p>DispatcherServlet：中央控制器，把请求给转发到具体的控制类<br>Controller：具体处理请求的控制器<br>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略<br>ModelAndView：服务层返回的数据和视图层的封装类<br>ViewResolver：视图解析器，解析具体的视图<br>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</p>\n<h4 id=\"RequestMapping-的作用是什么？\"><a href=\"#RequestMapping-的作用是什么？\" class=\"headerlink\" title=\"@RequestMapping 的作用是什么？\"></a>@RequestMapping 的作用是什么？</h4><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明。</p>\n<p>value， method：</p>\n<p>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；<br>method：指定请求的method类型， GET、POST、PUT、DELETE等；<br>consumes，produces<br>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；<br>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；<br>params，headers</p>\n<p>params： 指定request中必须包含某些参数值是，才让该方法处理。<br>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>\n<h4 id=\"Autowired-的作用是什么？\"><a href=\"#Autowired-的作用是什么？\" class=\"headerlink\" title=\"@Autowired 的作用是什么？\"></a>@Autowired 的作用是什么？</h4><p>《@Autowired用法详解》：blog.csdn.net/u013257679/article/details/52295106</p>\n<h2 id=\"Spring-Boot-Spring-Cloud\"><a href=\"#Spring-Boot-Spring-Cloud\" class=\"headerlink\" title=\"Spring Boot / Spring Cloud\"></a>Spring Boot / Spring Cloud</h2><h2 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h2><h4 id=\"mybatis-中-和-的区别是什么？\"><a href=\"#mybatis-中-和-的区别是什么？\" class=\"headerlink\" title=\"mybatis 中 #{}和 ${}的区别是什么？\"></a>mybatis 中 #{}和 ${}的区别是什么？</h4><p>${}是字符串替换；#{}是预编译处理。</p>\n<p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；<br>Mybatis在处理${}时，就是把${}替换成变量的值；<br>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>\n<h4 id=\"mybatis-有几种分页方式？\"><a href=\"#mybatis-有几种分页方式？\" class=\"headerlink\" title=\"mybatis 有几种分页方式？\"></a>mybatis 有几种分页方式？</h4><p>数组分页<br>sql分页<br>拦截器分页<br>RowBounds分页</p>\n<h4 id=\"mybatis-逻辑分页和物理分页的区别是什么？\"><a href=\"#mybatis-逻辑分页和物理分页的区别是什么？\" class=\"headerlink\" title=\"mybatis 逻辑分页和物理分页的区别是什么？\"></a>mybatis 逻辑分页和物理分页的区别是什么？</h4><p>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。<br>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</p>\n<h4 id=\"mybatis-是否支持延迟加载？延迟加载的原理是什么？\"><a href=\"#mybatis-是否支持延迟加载？延迟加载的原理是什么？\" class=\"headerlink\" title=\"mybatis 是否支持延迟加载？延迟加载的原理是什么？\"></a>mybatis 是否支持延迟加载？延迟加载的原理是什么？</h4><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>\n<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>\n<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>\n<h4 id=\"说一下-mybatis-的一级缓存和二级缓存？\"><a href=\"#说一下-mybatis-的一级缓存和二级缓存？\" class=\"headerlink\" title=\"说一下 mybatis 的一级缓存和二级缓存？\"></a>说一下 mybatis 的一级缓存和二级缓存？</h4><p>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。 </p>\n<p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ； </cache></p>\n<p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>\n<h4 id=\"mybatis-和-hibernate-的区别有哪些？\"><a href=\"#mybatis-和-hibernate-的区别有哪些？\" class=\"headerlink\" title=\"mybatis 和 hibernate 的区别有哪些？\"></a>mybatis 和 hibernate 的区别有哪些？</h4><p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>\n<p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 </p>\n<p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。 </p>\n<h4 id=\"mybatis-有哪些执行器（Executor）？\"><a href=\"#mybatis-有哪些执行器（Executor）？\" class=\"headerlink\" title=\"mybatis 有哪些执行器（Executor）？\"></a>mybatis 有哪些执行器（Executor）？</h4><p>Mybatis有三种基本的执行器（Executor）：</p>\n<p>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。<br>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。<br>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>\n<h4 id=\"mybatis-分页插件的实现原理是什么？\"><a href=\"#mybatis-分页插件的实现原理是什么？\" class=\"headerlink\" title=\"mybatis 分页插件的实现原理是什么？\"></a>mybatis 分页插件的实现原理是什么？</h4><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>\n<h4 id=\"mybatis-如何编写一个自定义插件？\"><a href=\"#mybatis-如何编写一个自定义插件？\" class=\"headerlink\" title=\"mybatis 如何编写一个自定义插件？\"></a>mybatis 如何编写一个自定义插件？</h4><p>转自：blog.csdn.net/qq_30051265/article/details/80266434</p>\n<p>  Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：</p>\n<p>Executor：拦截执行器的方法(log记录)<br>StatementHandler ：拦截Sql语法构建的处理<br>ParameterHandler ：拦截参数的处理<br>ResultSetHandler ：拦截结果集的处理<br>Mybatis自定义插件必须实现Interceptor接口：</p>\n<p>public interface Interceptor {<br>    Object intercept(Invocation invocation) throws Throwable;<br>    Object plugin(Object target);<br>    void setProperties(Properties properties);<br>}<br>intercept方法：拦截器具体处理逻辑方法 </p>\n<p>plugin方法：根据签名signatureMap生成动态代理对象 </p>\n<p>setProperties方法：设置Properties属性 </p>\n<p>自定义插件demo：</p>\n<p>// ExamplePlugin.java<br>@Intercepts({@Signature(<br>  type= Executor.class,<br>  method = “update”,<br>  args = {MappedStatement.class,Object.class})})<br>public class ExamplePlugin implements Interceptor {<br>  public Object intercept(Invocation invocation) throws Throwable {<br>  Object target = invocation.getTarget(); //被代理对象<br>  Method method = invocation.getMethod(); //代理方法<br>  Object[] args = invocation.getArgs(); //方法参数<br>  // do something …… 方法拦截前执行代码块<br>  Object result = invocation.proceed();<br>  // do something …….方法拦截后执行代码块<br>  return result;<br>  }<br>  public Object plugin(Object target) {<br>    return Plugin.wrap(target, this);<br>  }<br>  public void setProperties(Properties properties) {<br>  }<br>}</p>\n<p>一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下： </p>\n<p>type：表示拦截的类，这里是Executor的实现类；<br>method：表示拦截的方法，这里是拦截Executor的update方法；<br>args：表示方法参数。</p>\n<h2 id=\"MySql\"><a href=\"#MySql\" class=\"headerlink\" title=\"MySql\"></a>MySql</h2><h4 id=\"数据库的三范式是什么？\"><a href=\"#数据库的三范式是什么？\" class=\"headerlink\" title=\"数据库的三范式是什么？\"></a>数据库的三范式是什么？</h4><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br>第三范式：任何非主属性不依赖于其它非主属性。</p>\n<h4 id=\"一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了1条数据，此时-id-是几？\"><a href=\"#一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了1条数据，此时-id-是几？\" class=\"headerlink\" title=\"一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了1条数据，此时 id 是几？\"></a>一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了1条数据，此时 id 是几？</h4><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 8。并没有变化</p>\n<h4 id=\"如何获取当前数据库版本？\"><a href=\"#如何获取当前数据库版本？\" class=\"headerlink\" title=\"如何获取当前数据库版本？\"></a>如何获取当前数据库版本？</h4><p>使用 select version() 获取当前 MySQL 数据库版本。</p>\n<h4 id=\"说一下-ACID-是什么？\"><a href=\"#说一下-ACID-是什么？\" class=\"headerlink\" title=\"说一下 ACID 是什么？\"></a>说一下 ACID 是什么？</h4><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>\n<h4 id=\"char-和-varchar-的区别是什么？\"><a href=\"#char-和-varchar-的区别是什么？\" class=\"headerlink\" title=\"char 和 varchar 的区别是什么？\"></a>char 和 varchar 的区别是什么？</h4><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>\n<p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>\n<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>\n<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>\n<h4 id=\"float-和-double-的区别是什么？\"><a href=\"#float-和-double-的区别是什么？\" class=\"headerlink\" title=\"float 和 double 的区别是什么？\"></a>float 和 double 的区别是什么？</h4><p>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p>\n<h4 id=\"mysql-的内连接、左连接、右连接有什么区别？\"><a href=\"#mysql-的内连接、左连接、右连接有什么区别？\" class=\"headerlink\" title=\"mysql 的内连接、左连接、右连接有什么区别？\"></a>mysql 的内连接、左连接、右连接有什么区别？</h4><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>\n<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>\n<h4 id=\"mysql-索引是怎么实现的？\"><a href=\"#mysql-索引是怎么实现的？\" class=\"headerlink\" title=\"mysql 索引是怎么实现的？\"></a>mysql 索引是怎么实现的？</h4><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>\n<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>\n<h4 id=\"怎么验证-mysql-的索引是否满足需求？\"><a href=\"#怎么验证-mysql-的索引是否满足需求？\" class=\"headerlink\" title=\"怎么验证 mysql 的索引是否满足需求？\"></a>怎么验证 mysql 的索引是否满足需求？</h4><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>\n<p>explain 语法：explain select * from table where type=1。</p>\n<h4 id=\"说一下数据库的事务隔离？\"><a href=\"#说一下数据库的事务隔离？\" class=\"headerlink\" title=\"说一下数据库的事务隔离？\"></a>说一下数据库的事务隔离？</h4><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p>\n<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>\n<p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>\n<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>\n<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>\n<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>\n<h4 id=\"说一下-mysql-常用的引擎？\"><a href=\"#说一下-mysql-常用的引擎？\" class=\"headerlink\" title=\"说一下 mysql 常用的引擎？\"></a>说一下 mysql 常用的引擎？</h4><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p>\n<p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>\n<h4 id=\"说一下-mysql-的行锁和表锁？\"><a href=\"#说一下-mysql-的行锁和表锁？\" class=\"headerlink\" title=\"说一下 mysql 的行锁和表锁？\"></a>说一下 mysql 的行锁和表锁？</h4><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>\n<p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p>\n<h4 id=\"说一下乐观锁和悲观锁？\"><a href=\"#说一下乐观锁和悲观锁？\" class=\"headerlink\" title=\"说一下乐观锁和悲观锁？\"></a>说一下乐观锁和悲观锁？</h4><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p>\n<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>\n<h4 id=\"mysql-问题排查都有哪些手段？\"><a href=\"#mysql-问题排查都有哪些手段？\" class=\"headerlink\" title=\"mysql 问题排查都有哪些手段？\"></a>mysql 问题排查都有哪些手段？</h4><p>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。</p>\n<h4 id=\"如何做-mysql-的性能优化？\"><a href=\"#如何做-mysql-的性能优化？\" class=\"headerlink\" title=\"如何做 mysql 的性能优化？\"></a>如何做 mysql 的性能优化？</h4><p>为搜索字段创建索引。<br>避免使用 select *，列出需要查询的字段。<br>垂直分割分表。<br>选择正确的存储引擎。</p>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h4 id=\"redis-是什么？\"><a href=\"#redis-是什么？\" class=\"headerlink\" title=\"redis 是什么？\"></a>redis 是什么？</h4><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>\n<h4 id=\"redis-有哪些使用场景\"><a href=\"#redis-有哪些使用场景\" class=\"headerlink\" title=\"redis 有哪些使用场景\"></a>redis 有哪些使用场景</h4><p>数据高并发的读写<br>海量数据的读写<br>对扩展性要求高的数据</p>\n<h4 id=\"redis-有哪些功能？\"><a href=\"#redis-有哪些功能？\" class=\"headerlink\" title=\"redis 有哪些功能？\"></a>redis 有哪些功能？</h4><p>数据缓存功能<br>分布式锁的功能<br>支持数据持久化<br>支持事务<br>支持消息队列</p>\n<h4 id=\"redis-和-memecache-的区别？\"><a href=\"#redis-和-memecache-的区别？\" class=\"headerlink\" title=\"redis 和 memecache 的区别？\"></a>redis 和 memecache 的区别？</h4><p>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型<br>redis的速度比memcached快很多<br>redis可以持久化其数据</p>\n<h4 id=\"redis-为什么是单线程的？\"><a href=\"#redis-为什么是单线程的？\" class=\"headerlink\" title=\"redis 为什么是单线程的？\"></a>redis 为什么是单线程的？</h4><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>\n<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>\n<h4 id=\"什么是缓存穿透？怎么解决？\"><a href=\"#什么是缓存穿透？怎么解决？\" class=\"headerlink\" title=\"什么是缓存穿透？怎么解决？\"></a>什么是缓存穿透？怎么解决？</h4><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>\n<p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>\n<h4 id=\"redis-支持的数据类型有哪些？\"><a href=\"#redis-支持的数据类型有哪些？\" class=\"headerlink\" title=\"redis 支持的数据类型有哪些？\"></a>redis 支持的数据类型有哪些？</h4><p>string、list、hash、set、zset。</p>\n<h4 id=\"redis-支持哪些-java-客户端？\"><a href=\"#redis-支持哪些-java-客户端？\" class=\"headerlink\" title=\"redis 支持哪些 java 客户端？\"></a>redis 支持哪些 java 客户端？</h4><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>\n<h4 id=\"jedis-和-redisson-有哪些区别？\"><a href=\"#jedis-和-redisson-有哪些区别？\" class=\"headerlink\" title=\"jedis 和 redisson 有哪些区别？\"></a>jedis 和 redisson 有哪些区别？</h4><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。</p>\n<p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>\n<h4 id=\"redis缓存和数据库数据的一致性？\"><a href=\"#redis缓存和数据库数据的一致性？\" class=\"headerlink\" title=\"redis缓存和数据库数据的一致性？\"></a>redis缓存和数据库数据的一致性？</h4><p>合理设置缓存的过期时间。<br>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p>\n<h4 id=\"redis-持久化有几种方式？\"><a href=\"#redis-持久化有几种方式？\" class=\"headerlink\" title=\"redis 持久化有几种方式？\"></a>redis 持久化有几种方式？</h4><p>Redis 的持久化有两种方式，或者说有两种策略：</p>\n<p>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</p>\n<p>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</p>\n<h4 id=\"redis-怎么实现分布式锁？\"><a href=\"#redis-怎么实现分布式锁？\" class=\"headerlink\" title=\"redis 怎么实现分布式锁？\"></a>redis 怎么实现分布式锁？</h4><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>\n<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>\n<h4 id=\"redis-分布式锁有什么缺陷？\"><a href=\"#redis-分布式锁有什么缺陷？\" class=\"headerlink\" title=\"redis 分布式锁有什么缺陷？\"></a>redis 分布式锁有什么缺陷？</h4><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>\n<h4 id=\"redis-如何做内存优化？\"><a href=\"#redis-如何做内存优化？\" class=\"headerlink\" title=\"redis 如何做内存优化？\"></a>redis 如何做内存优化？</h4><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。 </p>\n<p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>\n<h4 id=\"redis-淘汰策略有哪些？\"><a href=\"#redis-淘汰策略有哪些？\" class=\"headerlink\" title=\"redis 淘汰策略有哪些？\"></a>redis 淘汰策略有哪些？</h4><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</p>\n<p>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</p>\n<p>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</p>\n<p>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</p>\n<p>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。<br>no-enviction（驱逐）：禁止驱逐数据。</p>\n<h4 id=\"redis-常见的性能问题有哪些？\"><a href=\"#redis-常见的性能问题有哪些？\" class=\"headerlink\" title=\"redis 常见的性能问题有哪些？\"></a>redis 常见的性能问题有哪些？</h4><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p>\n<h2 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h2><h4 id=\"zookeeper-是什么？\"><a href=\"#zookeeper-是什么？\" class=\"headerlink\" title=\"zookeeper 是什么？\"></a>zookeeper 是什么？</h4><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>\n<h4 id=\"zookeeper-都有哪些功能？\"><a href=\"#zookeeper-都有哪些功能？\" class=\"headerlink\" title=\"zookeeper 都有哪些功能？\"></a>zookeeper 都有哪些功能？</h4><p>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p>\n<h4 id=\"说一下-zookeeper-的通知机制？\"><a href=\"#说一下-zookeeper-的通知机制？\" class=\"headerlink\" title=\"说一下 zookeeper 的通知机制？\"></a>说一下 zookeeper 的通知机制？</h4><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>\n<h4 id=\"zookeeper-有几种部署模式？\"><a href=\"#zookeeper-有几种部署模式？\" class=\"headerlink\" title=\"zookeeper 有几种部署模式？\"></a>zookeeper 有几种部署模式？</h4><p>zookeeper 有三种部署模式：</p>\n<p>单机部署：一台集群上运行；<br>集群部署：多台集群运行；<br>伪集群部署：一台集群启动多个 zookeeper 实例运行。</p>\n<h4 id=\"zookeeper-怎么保证主从节点的状态同步？\"><a href=\"#zookeeper-怎么保证主从节点的状态同步？\" class=\"headerlink\" title=\"zookeeper 怎么保证主从节点的状态同步？\"></a>zookeeper 怎么保证主从节点的状态同步？</h4><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>\n<h4 id=\"集群中为什么要有主节点？\"><a href=\"#集群中为什么要有主节点？\" class=\"headerlink\" title=\"集群中为什么要有主节点？\"></a>集群中为什么要有主节点？</h4><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>\n<h4 id=\"集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？\"><a href=\"#集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？\" class=\"headerlink\" title=\"集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？\"></a>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h4><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h4 id=\"jvm的主要组成部分和作用？\"><a href=\"#jvm的主要组成部分和作用？\" class=\"headerlink\" title=\"jvm的主要组成部分和作用？\"></a>jvm的主要组成部分和作用？</h4><p>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）</p>\n<p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>\n<h4 id=\"jvm-运行时数据区？\"><a href=\"#jvm-运行时数据区？\" class=\"headerlink\" title=\"jvm 运行时数据区？\"></a>jvm 运行时数据区？</h4><p>程序计数器<br>虚拟机栈<br>本地方法栈<br>堆<br>方法区</p>\n<p>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</p>\n<h4 id=\"堆栈的区别？\"><a href=\"#堆栈的区别？\" class=\"headerlink\" title=\"堆栈的区别？\"></a>堆栈的区别？</h4><p>栈内存存储的是局部变量而堆内存存储的是实体；</p>\n<p>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p>\n<p>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p>\n<h4 id=\"队列和栈是什么？有什么区别？\"><a href=\"#队列和栈是什么？有什么区别？\" class=\"headerlink\" title=\"队列和栈是什么？有什么区别？\"></a>队列和栈是什么？有什么区别？</h4><p>队列和栈都是被用来预存储数据的。<br>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>\n<h4 id=\"什么是双亲委派模型？\"><a href=\"#什么是双亲委派模型？\" class=\"headerlink\" title=\"什么是双亲委派模型？\"></a>什么是双亲委派模型？</h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>\n<p>类加载器分类：</p>\n<p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载<java_home style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;\">\\lib\\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</java_home><br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p>\n<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>\n<h4 id=\"说一下类加载的执行过程？\"><a href=\"#说一下类加载的执行过程？\" class=\"headerlink\" title=\"说一下类加载的执行过程？\"></a>说一下类加载的执行过程？</h4><p>类加载分为以下 5 个步骤：</p>\n<p>加载：根据查找路径找到相应的 class 文件然后导入；<br>检查：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。</p>\n<h4 id=\"怎么判断对象是否可以被回收？\"><a href=\"#怎么判断对象是否可以被回收？\" class=\"headerlink\" title=\"怎么判断对象是否可以被回收？\"></a>怎么判断对象是否可以被回收？</h4><p>一般有两种方法来判断：</p>\n<p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p>\n<h4 id=\"java-中都有哪些引用类型？\"><a href=\"#java-中都有哪些引用类型？\" class=\"headerlink\" title=\"java 中都有哪些引用类型？\"></a>java 中都有哪些引用类型？</h4><p>强引用<br>软引用<br>弱引用<br>虚引用（幽灵引用/幻影引用）</p>\n<h4 id=\"说一下-jvm-有哪些垃圾回收算法？\"><a href=\"#说一下-jvm-有哪些垃圾回收算法？\" class=\"headerlink\" title=\"说一下 jvm 有哪些垃圾回收算法？\"></a>说一下 jvm 有哪些垃圾回收算法？</h4><p>标记-清除算法<br>标记-整理算法<br>复制算法<br>分代算法</p>\n<h4 id=\"说一下-jvm-有哪些垃圾回收器？\"><a href=\"#说一下-jvm-有哪些垃圾回收器？\" class=\"headerlink\" title=\"说一下 jvm 有哪些垃圾回收器？\"></a>说一下 jvm 有哪些垃圾回收器？</h4><p>Serial：最早的单线程串行垃圾回收器。<br>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。<br>ParNew：是 Serial 的多线程版本。<br>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<br>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。<br>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。<br>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p>\n<h4 id=\"详细介绍一下-CMS-垃圾回收器？\"><a href=\"#详细介绍一下-CMS-垃圾回收器？\" class=\"headerlink\" title=\"详细介绍一下 CMS 垃圾回收器？\"></a>详细介绍一下 CMS 垃圾回收器？</h4><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>\n<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>\n<h4 id=\"新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？\"><a href=\"#新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？\" class=\"headerlink\" title=\"新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？\"></a>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h4><p>新生代回收器：Serial、ParNew、Parallel Scavenge<br>老年代回收器：Serial Old、Parallel Old、CMS<br>整堆回收器：G1</p>\n<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>\n<h4 id=\"简述分代垃圾回收器怎么工作的？\"><a href=\"#简述分代垃圾回收器怎么工作的？\" class=\"headerlink\" title=\"简述分代垃圾回收器怎么工作的？\"></a>简述分代垃圾回收器怎么工作的？</h4><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>\n<p> 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>\n<p> 把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>\n<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>\n<h4 id=\"说一下-jvm-调优的工具？\"><a href=\"#说一下-jvm-调优的工具？\" class=\"headerlink\" title=\"说一下 jvm 调优的工具？\"></a>说一下 jvm 调优的工具？</h4><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>\n<p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>\n<h4 id=\"常用的-jvm-调优的参数都有哪些？\"><a href=\"#常用的-jvm-调优的参数都有哪些？\" class=\"headerlink\" title=\"常用的 jvm 调优的参数都有哪些？\"></a>常用的 jvm 调优的参数都有哪些？</h4><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p>\n<h2 id=\"程序优化\"><a href=\"#程序优化\" class=\"headerlink\" title=\"程序优化\"></a>程序优化</h2><h4 id=\"慎用异常\"><a href=\"#慎用异常\" class=\"headerlink\" title=\"慎用异常\"></a>慎用异常</h4><p>try-catch不要放在循环中，尽量把try-catsh放到循环体外来提升性能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">                a = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用局部环境\"><a href=\"#使用局部环境\" class=\"headerlink\" title=\"使用局部环境\"></a>使用局部环境</h4><p>局部变量的访问速度高于类的成员变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  private static int a = 0;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;        </span><br><span class=\"line\">       <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;        </span><br><span class=\"line\">       <span class=\"keyword\">long</span> start = System.currentTimeMillis();        </span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            a = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(System.currentTimeMillis() - start);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"位运算代替乘除法\"><a href=\"#位运算代替乘除法\" class=\"headerlink\" title=\"位运算代替乘除法\"></a>位运算代替乘除法</h4><p>HashMap的源码中使用了位运算，a*=2和a/=2，用位运算可以写为a&lt;&lt;=1，a&gt;&gt;=1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"Java-基础\"><a href=\"#Java-基础\" class=\"headerlink\" title=\"Java 基础\"></a>Java 基础</h2><h4 id=\"JDK-和-JRE-有什么区别？\"><a href=\"#JDK-和-JRE-有什么区别？\" class=\"headerlink\" title=\"JDK 和 JRE 有什么区别？\"></a>JDK 和 JRE 有什么区别？</h4><p>JDK：Java Development Kit 的简称，java 开发工具包，提供了 java 的开发环境和运行环境。</p>\n<p>JRE：Java Runtime Environment 的简称，java 运行环境，为 java 的运行提供了所需环境。</p>\n<p>具体来说 JDK 其实包含了 JRE，同时还包含了编译 java 源码的编译器 javac，还包含了很多 java 程序调试和分析的工具。简单来说：如果你需要运行 java 程序，只需安装 JRE 就可以了，如果你需要编写 java 程序，需要安装 JDK。</p>","more":"<h4 id=\"和-equals-的区别是什么？\"><a href=\"#和-equals-的区别是什么？\" class=\"headerlink\" title=\"== 和 equals 的区别是什么？\"></a>== 和 equals 的区别是什么？</h4><p>== 解读</p>\n<p>对于基本类型和引用类型 == 的作用效果是不同的，如下所示：</p>\n<p>基本类型：比较的是值是否相同；</p>\n<p>引用类型：比较的是引用是否相同；</p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String x = <span class=\"string\">\"string\"</span>;</span><br><span class=\"line\">String y = <span class=\"string\">\"string\"</span>;</span><br><span class=\"line\">String z = <span class=\"keyword\">new</span> String(<span class=\"string\">\"string\"</span>);</span><br><span class=\"line\">System.out.println(x==y); <span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(x==z); <span class=\"comment\">// false</span></span><br><span class=\"line\">System.out.println(x.equals(y)); <span class=\"comment\">// true</span></span><br><span class=\"line\">System.out.println(x.equals(z)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>代码解读：因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。</p>\n<p>equals 解读</p>\n<p>equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。</p>\n<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Cat</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  \t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">return</span> name;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">    \t\t<span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Cat c1 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"xx\"</span>);</span><br><span class=\"line\">Cat c2 = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"xx\"</span>);</span><br><span class=\"line\">System.out.println(c1.equals(c2)); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来 equals 本质上就是 ==。</p>\n<p>那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s1 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">String s2 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"老王\"</span>);</span><br><span class=\"line\">System.out.println(s1.equals(s2)); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String anotherString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>\n<p>总结 ：== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。</p>\n<h4 id=\"两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？\"><a href=\"#两个对象的-hashCode-相同，则-equals-也一定为-true，对吗？\" class=\"headerlink\" title=\"两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？\"></a>两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</h4><p>不对，两个对象的 hashCode()相同，equals()不一定 true。</p>\n<p>代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String str1 = <span class=\"string\">\"通话\"</span>;</span><br><span class=\"line\">String str2 = <span class=\"string\">\"重地\"</span>;</span><br><span class=\"line\">System.out.println(String.format(<span class=\"string\">\"str1：%d | str2：%d\"</span>,  str1.hashCode(),str2.hashCode()));</span><br><span class=\"line\">System.out.println(str1.equals(str2));</span><br></pre></td></tr></table></figure>\n\n<p>执行的结果：</p>\n<p>str1：1179395 | str2：1179395</p>\n<p>false</p>\n<p>代码解读：很显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。</p>\n<h4 id=\"final-在-java-中有什么作用？\"><a href=\"#final-在-java-中有什么作用？\" class=\"headerlink\" title=\"final 在 java 中有什么作用？\"></a>final 在 java 中有什么作用？</h4><p>final 修饰的类不能被继承。</p>\n<p>final 修饰的方法不能被重写。</p>\n<p>final 修饰的变量叫常量，常量必须初始化，初始化之后值就不能被修改。</p>\n<h4 id=\"java-中的-Math-round-1-5-等于多少？\"><a href=\"#java-中的-Math-round-1-5-等于多少？\" class=\"headerlink\" title=\"java 中的 Math.round(-1.5) 等于多少？\"></a>java 中的 Math.round(-1.5) 等于多少？</h4><p>等于 -1，因为在数轴上取值时，中间值（0.5）向右取整，所以正 0.5 是往上取整，负 0.5 是直接舍弃</p>\n<h4 id=\"String-属于基础的数据类型吗？\"><a href=\"#String-属于基础的数据类型吗？\" class=\"headerlink\" title=\"String 属于基础的数据类型吗？\"></a>String 属于基础的数据类型吗？</h4><p>String 不属于基础类型，属于对象，也就是引用类型。</p>\n<p>基础类型有 8 种：byte、boolean、char、short、int、float、long、double。</p>\n<h4 id=\"java-中操作字符串都有哪些类？它们之间有什么区别？\"><a href=\"#java-中操作字符串都有哪些类？它们之间有什么区别？\" class=\"headerlink\" title=\"java 中操作字符串都有哪些类？它们之间有什么区别？\"></a>java 中操作字符串都有哪些类？它们之间有什么区别？</h4><p>操作字符串的类有：String、StringBuffer、StringBuilder。</p>\n<p>String 和 StringBuffer、StringBuilder 的区别在于 String 声明的是不可变的对象，每次操作都会生成新的 String 对象，然后将指针指向新的 String 对象，而 StringBuffer、StringBuilder 可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最好不要使用 String。</p>\n<p>StringBuffer 和 StringBuilder 最大的区别在于，StringBuffer 是线程安全的，而 StringBuilder 是非线程安全的，但 StringBuilder 的性能却高于 StringBuffer，所以在单线程环境下推荐使用 StringBuilder，多线程环境下推荐使用 StringBuffer。</p>\n<h4 id=\"String-str-”i”与-String-str-new-String-“i”-一样吗？\"><a href=\"#String-str-”i”与-String-str-new-String-“i”-一样吗？\" class=\"headerlink\" title=\"String str=”i”与 String str=new String(“i”)一样吗？\"></a>String str=”i”与 String str=new String(“i”)一样吗？</h4><p>不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</p>\n<h4 id=\"如何将字符串反转？\"><a href=\"#如何将字符串反转？\" class=\"headerlink\" title=\"如何将字符串反转？\"></a>如何将字符串反转？</h4><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// StringBuffer reverse</span></span><br><span class=\"line\">StringBuffer stringBuffer = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">stringBuffer.append(<span class=\"string\">\"abcdefg\"</span>);</span><br><span class=\"line\">System.out.println(stringBuffer.reverse()); <span class=\"comment\">// gfedcba</span></span><br><span class=\"line\"><span class=\"comment\">// StringBuilder reverse</span></span><br><span class=\"line\">StringBuilder stringBuilder = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">stringBuilder.append(<span class=\"string\">\"abcdefg\"</span>);</span><br><span class=\"line\">System.out.println(stringBuilder.reverse()); <span class=\"comment\">// gfedcba</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"String-类的常用方法都有那些？\"><a href=\"#String-类的常用方法都有那些？\" class=\"headerlink\" title=\"String 类的常用方法都有那些？\"></a>String 类的常用方法都有那些？</h4><p>indexOf()：返回指定字符的索引。<br>charAt()：返回指定索引处的字符。<br>replace()：字符串替换。<br>trim()：去除字符串两端空白。<br>split()：分割字符串，返回一个分割后的字符串数组。<br>getBytes()：返回字符串的 byte 类型数组。<br>length()：返回字符串长度。<br>toLowerCase()：将字符串转成小写字母。<br>toUpperCase()：将字符串转成大写字符。<br>substring()：截取字符串。<br>equals()：字符串比较。</p>\n<h4 id=\"抽象类必须要有抽象方法吗？\"><a href=\"#抽象类必须要有抽象方法吗？\" class=\"headerlink\" title=\"抽象类必须要有抽象方法吗？\"></a>抽象类必须要有抽象方法吗？</h4><p>不需要，抽象类不一定非要有抽象方法。</p>\n<p>示例代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sayHi</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"hi~\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代码，抽象类并没有抽象方法但完全可以正常运行。</p>\n<h4 id=\"普通类和抽象类有哪些区别？\"><a href=\"#普通类和抽象类有哪些区别？\" class=\"headerlink\" title=\"普通类和抽象类有哪些区别？\"></a>普通类和抽象类有哪些区别？</h4><p>普通类不能包含抽象方法，抽象类可以包含抽象方法。<br>抽象类不能直接实例化，普通类可以直接实例化。</p>\n<h4 id=\"抽象类能使用-final-修饰吗？\"><a href=\"#抽象类能使用-final-修饰吗？\" class=\"headerlink\" title=\"抽象类能使用 final 修饰吗？\"></a>抽象类能使用 final 修饰吗？</h4><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类，编辑器会提示错误信息。</p>\n<h4 id=\"接口和抽象类有什么区别？\"><a href=\"#接口和抽象类有什么区别？\" class=\"headerlink\" title=\"接口和抽象类有什么区别？\"></a>接口和抽象类有什么区别？</h4><p>实现：抽象类的子类使用 extends 来继承；接口必须使用 implements 来实现接口。<br>构造函数：抽象类可以有构造函数；接口不能有。<br>main 方法：抽象类可以有 main 方法，并且我们能运行它；接口不能有 main 方法。<br>实现数量：类可以实现很多个接口；但是只能继承一个抽象类。<br>访问修饰符：接口中的方法默认使用 public 修饰；抽象类中的方法可以是任意访问修饰符。</p>\n<h4 id=\"java-中-IO-流分为几种？\"><a href=\"#java-中-IO-流分为几种？\" class=\"headerlink\" title=\"java 中 IO 流分为几种？\"></a>java 中 IO 流分为几种？</h4><p>按功能来分：输入流（input）、输出流（output）。</p>\n<p>按类型来分：字节流和字符流。</p>\n<p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p>\n<h4 id=\"BIO、NIO、AIO-有什么区别？\"><a href=\"#BIO、NIO、AIO-有什么区别？\" class=\"headerlink\" title=\"BIO、NIO、AIO 有什么区别？\"></a>BIO、NIO、AIO 有什么区别？</h4><p>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</p>\n<p>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</p>\n<p>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</p>\n<h4 id=\"Files的常用方法都有哪些？\"><a href=\"#Files的常用方法都有哪些？\" class=\"headerlink\" title=\"Files的常用方法都有哪些？\"></a>Files的常用方法都有哪些？</h4><p>Files.exists()：检测文件路径是否存在。<br>Files.createFile()：创建文件。<br>Files.createDirectory()：创建文件夹。<br>Files.delete()：删除一个文件或目录。<br>Files.copy()：复制文件。<br>Files.move()：移动文件。<br>Files.size()：查看文件个数。<br>Files.read()：读取文件。<br>Files.write()：写入文件。</p>\n<h2 id=\"java集合-容器\"><a href=\"#java集合-容器\" class=\"headerlink\" title=\"java集合/容器\"></a>java集合/容器</h2><h4 id=\"java-容器都有哪些？\"><a href=\"#java-容器都有哪些？\" class=\"headerlink\" title=\"java 容器都有哪些？\"></a>java 容器都有哪些？</h4><h4 id=\"Collection-和-Collections-有什么区别？\"><a href=\"#Collection-和-Collections-有什么区别？\" class=\"headerlink\" title=\"Collection 和 Collections 有什么区别？\"></a>Collection 和 Collections 有什么区别？</h4><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p>\n<p>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p>\n<h4 id=\"List、Set、Map-之间的区别是什么？\"><a href=\"#List、Set、Map-之间的区别是什么？\" class=\"headerlink\" title=\"List、Set、Map 之间的区别是什么？\"></a>List、Set、Map 之间的区别是什么？</h4><h4 id=\"HashMap-和-Hashtable-有什么区别？\"><a href=\"#HashMap-和-Hashtable-有什么区别？\" class=\"headerlink\" title=\"HashMap 和 Hashtable 有什么区别？\"></a>HashMap 和 Hashtable 有什么区别？</h4><p>hashMap去掉了HashTable 的contains方法，但是加上了containsValue（）和containsKey（）方法。<br>hashTable同步的，而HashMap是非同步的，效率上逼hashTable要高。<br>hashMap允许空键值，而hashTable不允许。</p>\n<h4 id=\"如何决定使用-HashMap-还是-TreeMap？\"><a href=\"#如何决定使用-HashMap-还是-TreeMap？\" class=\"headerlink\" title=\"如何决定使用 HashMap 还是 TreeMap？\"></a>如何决定使用 HashMap 还是 TreeMap？</h4><p>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p>\n<h4 id=\"说一下-HashMap-的实现原理？\"><a href=\"#说一下-HashMap-的实现原理？\" class=\"headerlink\" title=\"说一下 HashMap 的实现原理？\"></a>说一下 HashMap 的实现原理？</h4><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 </p>\n<p> HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>\n<p>当我们往Hashmap中put元素时,首先根据key的hashcode重新计算hash值,根绝hash值得到这个元素在数组中的位置(下标),如果该数组在该位置上已经存放了其他元素,那么在这个位置上的元素将以链表的形式存放,新加入的放在链头,最先加入的放入链尾.如果数组中该位置没有元素,就直接将该元素放到数组的该位置上。</p>\n<p> 需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p>\n<h4 id=\"说一下-HashSet-的实现原理？\"><a href=\"#说一下-HashSet-的实现原理？\" class=\"headerlink\" title=\"说一下 HashSet 的实现原理？\"></a>说一下 HashSet 的实现原理？</h4><p>HashSet底层由HashMap实现<br>HashSet的值存放于HashMap的key上<br>HashMap的value统一为PRESENT</p>\n<h4 id=\"ArrayList-和-LinkedList-的区别是什么？\"><a href=\"#ArrayList-和-LinkedList-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 LinkedList 的区别是什么？\"></a>ArrayList 和 LinkedList 的区别是什么？</h4><p>最明显的区别是 ArrrayList底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构是双向循环链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p>\n<h4 id=\"如何实现数组和-List-之间的转换？\"><a href=\"#如何实现数组和-List-之间的转换？\" class=\"headerlink\" title=\"如何实现数组和 List 之间的转换？\"></a>如何实现数组和 List 之间的转换？</h4><p>List转换成为数组：调用ArrayList的toArray方法。<br>数组转换成为List：调用Arrays的asList方法。</p>\n<h4 id=\"ArrayList-和-Vector-的区别是什么？\"><a href=\"#ArrayList-和-Vector-的区别是什么？\" class=\"headerlink\" title=\"ArrayList 和 Vector 的区别是什么？\"></a>ArrayList 和 Vector 的区别是什么？</h4><p>Vector是同步的，而ArrayList不是。然而，如果你寻求在迭代的时候对列表进行改变，你应该使用CopyOnWriteArrayList。 </p>\n<p>ArrayList比Vector快，它因为有同步，不会过载。 </p>\n<p>ArrayList更加通用，因为我们可以使用Collections工具类轻易地获取同步列表和只读列表。</p>\n<h4 id=\"Array-和-ArrayList-有何区别？\"><a href=\"#Array-和-ArrayList-有何区别？\" class=\"headerlink\" title=\"Array 和 ArrayList 有何区别？\"></a>Array 和 ArrayList 有何区别？</h4><p>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。<br>Array是指定大小的，而ArrayList大小是固定的。<br>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</p>\n<h4 id=\"在-Queue-中-poll-和-remove-有什么区别？\"><a href=\"#在-Queue-中-poll-和-remove-有什么区别？\" class=\"headerlink\" title=\"在 Queue 中 poll()和 remove()有什么区别？\"></a>在 Queue 中 poll()和 remove()有什么区别？</h4><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p>\n<h4 id=\"哪些集合类是线程安全的？\"><a href=\"#哪些集合类是线程安全的？\" class=\"headerlink\" title=\"哪些集合类是线程安全的？\"></a>哪些集合类是线程安全的？</h4><p>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。<br>statck：堆栈类，先进后出。<br>hashtable：就比hashmap多了个线程安全。<br>enumeration：枚举，相当于迭代器。</p>\n<h4 id=\"迭代器-Iterator-是什么？\"><a href=\"#迭代器-Iterator-是什么？\" class=\"headerlink\" title=\"迭代器 Iterator 是什么？\"></a>迭代器 Iterator 是什么？</h4><p>迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。</p>\n<h4 id=\"Iterator-怎么使用？有什么特点？\"><a href=\"#Iterator-怎么使用？有什么特点？\" class=\"headerlink\" title=\"Iterator 怎么使用？有什么特点？\"></a>Iterator 怎么使用？有什么特点？</h4><p>Java中的Iterator功能比较简单，并且只能单向移动：</p>\n<p>　　(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。</p>\n<p>　　(2) 使用next()获得序列中的下一个元素。</p>\n<p>　　(3) 使用hasNext()检查序列中是否还有元素。</p>\n<p>　　(4) 使用remove()将迭代器新返回的元素删除。</p>\n<p>　　Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。</p>\n<h4 id=\"Iterator-和-ListIterator-有什么区别？\"><a href=\"#Iterator-和-ListIterator-有什么区别？\" class=\"headerlink\" title=\"Iterator 和 ListIterator 有什么区别？\"></a>Iterator 和 ListIterator 有什么区别？</h4><p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。<br>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。<br>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><h4 id=\"并行和并发有什么区别？\"><a href=\"#并行和并发有什么区别？\" class=\"headerlink\" title=\"并行和并发有什么区别？\"></a>并行和并发有什么区别？</h4><p>并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。<br>并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。<br>在一台处理器上“同时”处理多个任务，在多台处理器上同时处理多个任务。如hadoop分布式集群。<br>所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能。</p>\n<h4 id=\"线程和进程的区别？\"><a href=\"#线程和进程的区别？\" class=\"headerlink\" title=\"线程和进程的区别？\"></a>线程和进程的区别？</h4><p>简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程共享内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。</p>\n<h4 id=\"守护线程是什么？\"><a href=\"#守护线程是什么？\" class=\"headerlink\" title=\"守护线程是什么？\"></a>守护线程是什么？</h4><p>守护线程（即daemon thread），是个服务线程，准确地来说就是服务其他的线程</p>\n<h4 id=\"创建线程有哪几种方式？\"><a href=\"#创建线程有哪几种方式？\" class=\"headerlink\" title=\"创建线程有哪几种方式？\"></a>创建线程有哪几种方式？</h4><p>①. 继承Thread类创建线程类</p>\n<p>定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。<br>创建Thread子类的实例，即创建了线程对象。<br>调用线程对象的start()方法来启动该线程。<br>②. 通过Runnable接口创建线程类</p>\n<p>定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。<br>创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。<br>调用线程对象的start()方法来启动该线程。<br>③. 通过Callable和Future创建线程</p>\n<p>创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。<br>创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。<br>使用FutureTask对象作为Thread对象的target创建并启动新线程。<br>调用FutureTask对象的get()方法来获得子线程执行结束后的返回值</p>\n<h4 id=\"说一下-runnable-和-callable-有什么区别？\"><a href=\"#说一下-runnable-和-callable-有什么区别？\" class=\"headerlink\" title=\"说一下 runnable 和 callable 有什么区别？\"></a>说一下 runnable 和 callable 有什么区别？</h4><p>有点深的问题了，也看出一个Java程序员学习知识的广度。</p>\n<p>Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；<br>Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p>\n<h4 id=\"线程有哪些状态？\"><a href=\"#线程有哪些状态？\" class=\"headerlink\" title=\"线程有哪些状态？\"></a>线程有哪些状态？</h4><p>线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>\n<p>创建状态。在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。<br>就绪状态。当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。<br>运行状态。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。<br>阻塞状态。线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。<br>死亡状态。如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪 。</p>\n<h4 id=\"sleep-和-wait-有什么区别？\"><a href=\"#sleep-和-wait-有什么区别？\" class=\"headerlink\" title=\"sleep() 和 wait() 有什么区别？\"></a>sleep() 和 wait() 有什么区别？</h4><p>sleep()：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁没有被释放，其他线程依然无法访问这个对象。</p>\n<p>wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。</p>\n<h4 id=\"notify-和-notifyAll-有什么区别？\"><a href=\"#notify-和-notifyAll-有什么区别？\" class=\"headerlink\" title=\"notify()和 notifyAll()有什么区别？\"></a>notify()和 notifyAll()有什么区别？</h4><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。<br>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。<br>优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。</p>\n<h4 id=\"线程的-run-和-start-有什么区别？\"><a href=\"#线程的-run-和-start-有什么区别？\" class=\"headerlink\" title=\"线程的 run()和 start()有什么区别？\"></a>线程的 run()和 start()有什么区别？</h4><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>\n<p> start()方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码； 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p>\n<p> run()方法是在本线程里的，只是线程里的一个函数,而不是多线程的。 如果直接调用run(),其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法</p>\n<h4 id=\"创建线程池有哪几种方式？\"><a href=\"#创建线程池有哪几种方式？\" class=\"headerlink\" title=\"创建线程池有哪几种方式？\"></a>创建线程池有哪几种方式？</h4><p>①. newFixedThreadPool(int nThreads)</p>\n<p>创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程规模将不再变化，当线程发生未预期的错误而结束时，线程池会补充一个新的线程。</p>\n<p>②. newCachedThreadPool()</p>\n<p>创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</p>\n<p>③. newSingleThreadExecutor()</p>\n<p>这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行</p>\n<p>④. newScheduledThreadPool(int corePoolSize)</p>\n<p>创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。</p>\n<h4 id=\"线程池都有哪些状态？\"><a href=\"#线程池都有哪些状态？\" class=\"headerlink\" title=\"线程池都有哪些状态？\"></a>线程池都有哪些状态？</h4><p>线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated。</p>\n<p>线程池各个状态切换框架图：</p>\n<h4 id=\"线程池中-submit-和-execute-方法有什么区别？\"><a href=\"#线程池中-submit-和-execute-方法有什么区别？\" class=\"headerlink\" title=\"线程池中 submit()和 execute()方法有什么区别？\"></a>线程池中 submit()和 execute()方法有什么区别？</h4><p>接收的参数不一样<br>submit有返回值，而execute没有<br>submit方便Exception处理</p>\n<h4 id=\"在-java-程序中怎么保证多线程的运行安全？\"><a href=\"#在-java-程序中怎么保证多线程的运行安全？\" class=\"headerlink\" title=\"在 java 程序中怎么保证多线程的运行安全？\"></a>在 java 程序中怎么保证多线程的运行安全？</h4><p>线程安全在三个方面体现：</p>\n<p>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；<br>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；<br>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。</p>\n<h4 id=\"多线程锁的升级原理是什么？\"><a href=\"#多线程锁的升级原理是什么？\" class=\"headerlink\" title=\"多线程锁的升级原理是什么？\"></a>多线程锁的升级原理是什么？</h4><p>在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级。</p>\n<p>锁升级的图示过程： </p>\n<h4 id=\"什么是死锁？\"><a href=\"#什么是死锁？\" class=\"headerlink\" title=\"什么是死锁？\"></a>什么是死锁？</h4><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p>\n<h4 id=\"怎么防止死锁？\"><a href=\"#怎么防止死锁？\" class=\"headerlink\" title=\"怎么防止死锁？\"></a>怎么防止死锁？</h4><p>死锁的四个必要条件：</p>\n<p>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源<br>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放<br>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放<br>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系<br>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p>\n<p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p>\n<p>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。</p>\n<p>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>\n<h4 id=\"ThreadLocal-是什么？有哪些使用场景？\"><a href=\"#ThreadLocal-是什么？有哪些使用场景？\" class=\"headerlink\" title=\"ThreadLocal 是什么？有哪些使用场景？\"></a>ThreadLocal 是什么？有哪些使用场景？</h4><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p>\n<h4 id=\"说一下-synchronized-底层实现原理？\"><a href=\"#说一下-synchronized-底层实现原理？\" class=\"headerlink\" title=\"说一下 synchronized 底层实现原理？\"></a>说一下 synchronized 底层实现原理？</h4><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>\n<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>\n<p>普通同步方法，锁是当前实例对象<br>静态同步方法，锁是当前类的class对象<br>同步方法块，锁是括号里面的对象</p>\n<h4 id=\"说一下volatile底层实现原理\"><a href=\"#说一下volatile底层实现原理\" class=\"headerlink\" title=\"说一下volatile底层实现原理\"></a>说一下volatile底层实现原理</h4><h4 id=\"synchronized-和-volatile-的区别是什么？\"><a href=\"#synchronized-和-volatile-的区别是什么？\" class=\"headerlink\" title=\"synchronized 和 volatile 的区别是什么？\"></a>synchronized 和 volatile 的区别是什么？</h4><p>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。<br>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。<br>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p>\n<h4 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h4><p>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；<br>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；<br>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；<br>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；<br>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；<br>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</p>\n<h4 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h4><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p>\n<p>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁<br>ReentrantLock可以获取各种锁的信息<br>ReentrantLock可以灵活地实现多路通知<br>另外，二者的锁机制其实也是不一样的:ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word</p>\n<h4 id=\"说一下-atomic-的原理？\"><a href=\"#说一下-atomic-的原理？\" class=\"headerlink\" title=\"说一下 atomic 的原理？\"></a>说一下 atomic 的原理？</h4><p>Atomic包中的类基本的特性就是在多线程环境下，当有多个线程同时对单个（包括基本类型及引用类型）变量进行操作时，具有排他性，即当多个线程同时对该变量的值进行更新时，仅有一个线程能成功，而未成功的线程可以向自旋锁一样，继续尝试，一直等到执行成功。</p>\n<p>Atomic系列的类中的核心方法都会调用unsafe类中的几个本地方法。我们需要先知道一个东西就是Unsafe类，全名为：sun.misc.Unsafe，这个类包含了大量的对C代码的操作，包括很多直接内存分配以及原子操作的调用，而它之所以标记为非安全的，是告诉你这个里面大量的方法调用都会存在安全隐患，需要小心使用，否则会导致严重的后果，例如在通过unsafe分配内存的时候，如果自己指定某些区域可能会导致一些类似C++一样的指针越界到其他进程的问题。</p>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h4 id=\"什么是反射？\"><a href=\"#什么是反射？\" class=\"headerlink\" title=\"什么是反射？\"></a>什么是反射？</h4><p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力。</p>\n<p>Java反射：在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法。</p>\n<p>Java反射机制主要提供了以下功能：</p>\n<p>在运行时判断任意一个对象所属的类。<br>在运行时构造任意一个类的对象。<br>在运行时判断任意一个类所具有的成员变量和方法。<br>在运行时调用任意一个对象的方法。<br>得到类的字节码文件相同，这三种方式。<br>1.Class cls1=类名.class 相对简单，还是需要明确类名<br>2.cls1.getclass();必须要明确具体的类，并创建对象<br>3.class.forName(“完整的类名（带包名）”);</p>\n<h4 id=\"什么是-java-序列化？什么情况下需要序列化？\"><a href=\"#什么是-java-序列化？什么情况下需要序列化？\" class=\"headerlink\" title=\"什么是 java 序列化？什么情况下需要序列化？\"></a>什么是 java 序列化？什么情况下需要序列化？</h4><p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p>\n<p>什么情况下需要序列化：</p>\n<p>a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；<br>b）当你想用套接字在网络上传送对象的时候；<br>c）当你想通过RMI传输对象的时候；</p>\n<h4 id=\"动态代理是什么？有哪些应用？\"><a href=\"#动态代理是什么？有哪些应用？\" class=\"headerlink\" title=\"动态代理是什么？有哪些应用？\"></a>动态代理是什么？有哪些应用？</h4><p>动态代理：</p>\n<p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p>\n<p>动态代理的应用：</p>\n<p>Spring的AOP<br>加事务<br>加权限<br>加日志</p>\n<h4 id=\"怎么实现动态代理？\"><a href=\"#怎么实现动态代理？\" class=\"headerlink\" title=\"怎么实现动态代理？\"></a>怎么实现动态代理？</h4><p>首先必须定义一个接口，还要有一个InvocationHandler(将实现接口的类的对象传递给它)处理类。再有一个工具类Proxy(习惯性将其称为代理类，因为调用他的newInstance()可以产生代理对象,其实他只是一个产生代理对象的工具类）。利用到InvocationHandler，拼接代理类源码，将其编译生成代理类的二进制码，利用加载器加载，并将其实例化产生代理对象，最后返回。</p>\n<h2 id=\"对象拷贝\"><a href=\"#对象拷贝\" class=\"headerlink\" title=\"对象拷贝\"></a>对象拷贝</h2><h4 id=\"为什么要使用克隆？\"><a href=\"#为什么要使用克隆？\" class=\"headerlink\" title=\"为什么要使用克隆？\"></a>为什么要使用克隆？</h4><p>想对一个对象进行处理，又想保留原有的数据进行接下来的操作，就需要克隆了，Java语言中克隆针对的是类的实例。</p>\n<h4 id=\"如何实现对象克隆？\"><a href=\"#如何实现对象克隆？\" class=\"headerlink\" title=\"如何实现对象克隆？\"></a>如何实现对象克隆？</h4><p>有两种方式：</p>\n<p>1). 实现Cloneable接口并重写Object类中的clone()方法；</p>\n<p>2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。<br>注意：基于序列化和反序列化实现的克隆不仅仅是深度克隆，更重要的是通过泛型限定，可以检查出要克隆的对象是否支持序列化，这项检查是编译器完成的，不是在运行时抛出异常，这种是方案明显优于使用Object类的clone方法克隆对象。让问题在编译的时候暴露出来总是好过把问题留到运行时</p>\n<h4 id=\"深拷贝和浅拷贝区别是什么？\"><a href=\"#深拷贝和浅拷贝区别是什么？\" class=\"headerlink\" title=\"深拷贝和浅拷贝区别是什么？\"></a>深拷贝和浅拷贝区别是什么？</h4><p>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）<br>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</p>\n<h2 id=\"Java-Web\"><a href=\"#Java-Web\" class=\"headerlink\" title=\"Java Web\"></a>Java Web</h2><h4 id=\"jsp-和-servlet-有什么区别？\"><a href=\"#jsp-和-servlet-有什么区别？\" class=\"headerlink\" title=\"jsp 和 servlet 有什么区别？\"></a>jsp 和 servlet 有什么区别？</h4><p>jsp经编译后就变成了Servlet.（JSP的本质就是Servlet，JVM只能识别java的类，不能识别JSP的代码，Web容器将JSP的代码编译成JVM能够识别的java类）<br>jsp更擅长表现于页面显示，servlet更擅长于逻辑控制。<br>Servlet中没有内置对象，Jsp中的内置对象都是必须通过HttpServletRequest对象，HttpServletResponse对象以及HttpServlet对象得到。<br>Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成。而Servlet则是个完整的Java类，这个类的Service方法用于生成对客户端的响应</p>\n<h4 id=\"jsp-有哪些内置对象？作用分别是什么？\"><a href=\"#jsp-有哪些内置对象？作用分别是什么？\" class=\"headerlink\" title=\"jsp 有哪些内置对象？作用分别是什么？\"></a>jsp 有哪些内置对象？作用分别是什么？</h4><p>JSP有9个内置对象：</p>\n<p>request：封装客户端的请求，其中包含来自GET或POST请求的参数；<br>response：封装服务器对客户端的响应；<br>pageContext：通过该对象可以获取其他对象；<br>session：封装用户会话的对象；<br>application：封装服务器运行环境的对象；<br>out：输出服务器响应的输出流对象；<br>config：Web应用的配置对象；<br>page：JSP页面本身（相当于Java程序中的this）；<br>exception：封装页面抛出异常的对象。</p>\n<h4 id=\"说一下-jsp-的-4-种作用域？\"><a href=\"#说一下-jsp-的-4-种作用域？\" class=\"headerlink\" title=\"说一下 jsp 的 4 种作用域？\"></a>说一下 jsp 的 4 种作用域？</h4><p>JSP中的四种作用域包括page、request、session和application，具体来说：</p>\n<p>page代表与一个页面相关的对象和属性。<br>request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。<br>session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。<br>application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</p>\n<h4 id=\"session-和-cookie-有什么区别？\"><a href=\"#session-和-cookie-有什么区别？\" class=\"headerlink\" title=\"session 和 cookie 有什么区别？\"></a>session 和 cookie 有什么区别？</h4><h4 id=\"说一下-session-的工作原理？\"><a href=\"#说一下-session-的工作原理？\" class=\"headerlink\" title=\"说一下 session 的工作原理？\"></a>说一下 session 的工作原理？</h4><p>其实session是一个存在服务器上的类似于一个散列表格的文件。里面存有我们需要的信息，在我们需要用的时候可以从里面取出来。类似于一个大号的map吧，里面的键存储的是用户的sessionid，用户向服务器发送请求的时候会带上这个sessionid。这时就可以从中取出对应的值了</p>\n<h4 id=\"如何避免SQL注入\"><a href=\"#如何避免SQL注入\" class=\"headerlink\" title=\"如何避免SQL注入\"></a>如何避免SQL注入</h4><ol>\n<li>PreparedStatement（简单又有效的方法）</li>\n<li>使用正则表达式过滤传入的参数</li>\n<li>字符串过滤</li>\n<li>JSP中调用该函数检查是否包函非法字符</li>\n<li>JSP页面判断代码</li>\n</ol>\n<h4 id=\"什么是-XSS-攻击，如何避免？\"><a href=\"#什么是-XSS-攻击，如何避免？\" class=\"headerlink\" title=\"什么是 XSS 攻击，如何避免？\"></a>什么是 XSS 攻击，如何避免？</h4><p>XSS攻击又称CSS,全称Cross Site Script  （跨站脚本攻击），其原理是攻击者向有XSS漏洞的网站中输入恶意的 HTML 代码，当用户浏览该网站时，这段 HTML 代码会自动执行，从而达到攻击的目的。XSS 攻击类似于 SQL 注入攻击，SQL注入攻击中以SQL语句作为用户输入，从而达到查询/修改/删除数据的目的，而在xss攻击中，通过插入恶意脚本，实现对用户游览器的控制，获取用户的一些信息。 XSS是 Web 程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式。</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><h4 id=\"throw-和-throws-的区别？\"><a href=\"#throw-和-throws-的区别？\" class=\"headerlink\" title=\"throw 和 throws 的区别？\"></a>throw 和 throws 的区别？</h4><p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型</p>\n<h4 id=\"final、finally、finalize-有什么区别？\"><a href=\"#final、finally、finalize-有什么区别？\" class=\"headerlink\" title=\"final、finally、finalize 有什么区别？\"></a>final、finally、finalize 有什么区别？</h4><p>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。<br>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。<br>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 </p>\n<h4 id=\"try-catch-finally-中哪个部分可以省略？\"><a href=\"#try-catch-finally-中哪个部分可以省略？\" class=\"headerlink\" title=\"try-catch-finally 中哪个部分可以省略？\"></a>try-catch-finally 中哪个部分可以省略？</h4><p>答：catch 可以省略</p>\n<p>原因：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</span><br><span class=\"line\"> 理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</span><br><span class=\"line\">至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\"><a href=\"#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\" class=\"headerlink\" title=\"try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h4><p>答：会执行，在 return 前执行。</p>\n<h4 id=\"常见的异常类有哪些？\"><a href=\"#常见的异常类有哪些？\" class=\"headerlink\" title=\"常见的异常类有哪些？\"></a>常见的异常类有哪些？</h4><p>NullPointerException：当应用程序试图访问空对象时，则抛出该异常。<br>SQLException：提供关于数据库访问错误或其他错误信息的异常。<br>IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。<br>NumberFormatException：当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。<br>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常。<br>IOException：当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。<br>ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。<br>ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常。<br>IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。<br>ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。<br>NegativeArraySizeException：如果应用程序试图创建大小为负的数组，则抛出该异常。<br>NoSuchMethodException：无法找到某一特定方法时，抛出该异常。<br>SecurityException：由安全管理器抛出的异常，指示存在安全侵犯。<br>UnsupportedOperationException：当不支持请求的操作时，抛出该异常。<br>RuntimeExceptionRuntimeException：是那些可能在Java虚拟机正常运行期间抛出的异常的超类。</p>\n<h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><h4 id=\"http-响应码-301-和-302-代表的是什么？有什么区别？\"><a href=\"#http-响应码-301-和-302-代表的是什么？有什么区别？\" class=\"headerlink\" title=\"http 响应码 301 和 302 代表的是什么？有什么区别？\"></a>http 响应码 301 和 302 代表的是什么？有什么区别？</h4><p>301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。</p>\n<p>区别： </p>\n<p>301 redirect: 301 代表永久性转移(Permanently Moved)。<br>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</p>\n<h4 id=\"forward-和-redirect-的区别？\"><a href=\"#forward-和-redirect-的区别？\" class=\"headerlink\" title=\"forward 和 redirect 的区别？\"></a>forward 和 redirect 的区别？</h4><p>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。</p>\n<p>直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。</p>\n<p>间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。</p>\n<p>举个通俗的例子：</p>\n<p>　　直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；</p>\n<p>　　间接转发就相当于：”A找B借钱，B说没有，让A去找C借”</p>\n<h4 id=\"简述-tcp-和-udp的区别？\"><a href=\"#简述-tcp-和-udp的区别？\" class=\"headerlink\" title=\"简述 tcp 和 udp的区别？\"></a>简述 tcp 和 udp的区别？</h4><p>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。<br>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。<br>Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。<br>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。<br>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。<br>TCP对系统资源要求较多，UDP对系统资源要求较少。</p>\n<h4 id=\"tcp-为什么要三次握手，两次不行吗？为什么？\"><a href=\"#tcp-为什么要三次握手，两次不行吗？为什么？\" class=\"headerlink\" title=\"tcp 为什么要三次握手，两次不行吗？为什么？\"></a>tcp 为什么要三次握手，两次不行吗？为什么？</h4><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p>\n<p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p>\n<h4 id=\"说一下-tcp-粘包是怎么产生的？\"><a href=\"#说一下-tcp-粘包是怎么产生的？\" class=\"headerlink\" title=\"说一下 tcp 粘包是怎么产生的？\"></a>说一下 tcp 粘包是怎么产生的？</h4><p>①. 发送方产生粘包</p>\n<p>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>\n<p>②. 接收方产生粘包</p>\n<p>接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度） </p>\n<h4 id=\"OSI-的七层模型都有哪些？\"><a href=\"#OSI-的七层模型都有哪些？\" class=\"headerlink\" title=\"OSI 的七层模型都有哪些？\"></a>OSI 的七层模型都有哪些？</h4><p>应用层：网络服务与最终用户的一个接口。<br>表示层：数据的表示、安全、压缩。<br>会话层：建立、管理、终止会话。<br>传输层：定义传输数据的协议端口号，以及流控和差错校验。<br>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。<br>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。<br>物理层：建立、维护、断开物理连接。</p>\n<h4 id=\"get-和-post-请求有哪些区别？\"><a href=\"#get-和-post-请求有哪些区别？\" class=\"headerlink\" title=\"get 和 post 请求有哪些区别？\"></a>get 和 post 请求有哪些区别？</h4><p>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET产生的URL地址可以被Bookmark，而POST不可以。<br>GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST么有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body中</p>\n<h4 id=\"说一下-JSONP-实现原理？\"><a href=\"#说一下-JSONP-实现原理？\" class=\"headerlink\" title=\"说一下 JSONP 实现原理？\"></a>说一下 JSONP 实现原理？</h4><p>jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返货json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p>\n<h2 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h2><h4 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h4><p>定义：有且仅有一个实例</p>\n<p>用途：</p>\n<p>双重检查、静态内部类、枚举（推荐使用）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//双重检查写法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">volatile</span> Singleton singleton;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (Singleton.class) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (singleton == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> singleton;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这两种写法的优点：线程安全；延迟加载；效率较高。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//静态内部类写法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonInstance</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Singleton INSTANCE = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> SingletonInstance.INSTANCE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>注意：内存浪费、线程安全、使用效率</p>\n<h4 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h4><p>定义：从原型实例复制克隆出新实例，而绝不是从类去实例化</p>\n<p>用途：</p>\n<p>写法：原型类要实现Cloneable接口</p>\n<h2 id=\"Spring-Spring-MVC\"><a href=\"#Spring-Spring-MVC\" class=\"headerlink\" title=\"Spring / Spring MVC\"></a>Spring / Spring MVC</h2><ol start=\"90\">\n<li>为什么要使用 spring？</li>\n</ol>\n<p>1.简介</p>\n<p>目的：解决企业应用开发的复杂性<br>功能：使用基本的JavaBean代替EJB，并提供了更多的企业应用功能<br>范围：任何Java应用<br>简单来说，Spring是一个轻量级的控制反转(IoC)和面向切面(AOP)的容器框架。</p>\n<p>2.轻量　　</p>\n<p>从大小与开销两方面而言Spring都是轻量的。完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。</p>\n<p>3.控制反转　　</p>\n<p>Spring通过一种称作控制反转（IoC）的技术促进了松耦合。当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它</p>\n<p>4.面向切面　　</p>\n<p>Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</p>\n<p>5.容器</p>\n<p>Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。</p>\n<p>6.框架</p>\n<p>Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。Spring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。</p>\n<p>所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。它们也为Spring中的各种模块提供了基础支持。</p>\n<h4 id=\"解释一下什么是-aop？\"><a href=\"#解释一下什么是-aop？\" class=\"headerlink\" title=\"解释一下什么是 aop？\"></a>解释一下什么是 aop？</h4><p>AOP（Aspect-Oriented Programming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>\n<p> 而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p>\n<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>\n<h4 id=\"解释一下什么是-ioc？\"><a href=\"#解释一下什么是-ioc？\" class=\"headerlink\" title=\"解释一下什么是 ioc？\"></a>解释一下什么是 ioc？</h4><p>IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。</p>\n<p>　1996年，Michael Mattson在一篇有关探讨面向对象框架的文章中，首先提出了IOC 这个概念。对于面向对象设计及编程的基本思想，前面我们已经讲了很多了，不再赘述，简单来说就是把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。</p>\n<p>　IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：</p>\n<p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p>\n<p>　　我们再来做个试验：把上图中间的IOC容器拿掉，然后再来看看这套系统</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！</span><br><span class=\"line\"></span><br><span class=\"line\">我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：</span><br><span class=\"line\"></span><br><span class=\"line\">软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。</span><br><span class=\"line\"></span><br><span class=\"line\">软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。</span><br><span class=\"line\"></span><br><span class=\"line\">通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"spring-有哪些主要模块？\"><a href=\"#spring-有哪些主要模块？\" class=\"headerlink\" title=\"spring 有哪些主要模块？\"></a>spring 有哪些主要模块？</h4><p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p>\n<h4 id=\"spring-常用的注入方式有哪些？\"><a href=\"#spring-常用的注入方式有哪些？\" class=\"headerlink\" title=\"spring 常用的注入方式有哪些？\"></a>spring 常用的注入方式有哪些？</h4><p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p>\n<p>构造方法注入<br>setter注入<br>基于注解的注入</p>\n<h4 id=\"spring-中的-bean-是线程安全的吗？\"><a href=\"#spring-中的-bean-是线程安全的吗？\" class=\"headerlink\" title=\"spring 中的 bean 是线程安全的吗？\"></a>spring 中的 bean 是线程安全的吗？</h4><p>Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</p>\n<h4 id=\"spring-支持几种-bean-的作用域？\"><a href=\"#spring-支持几种-bean-的作用域？\" class=\"headerlink\" title=\"spring 支持几种 bean 的作用域？\"></a>spring 支持几种 bean 的作用域？</h4><p>当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p>\n<p>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例<br>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例<br>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效<br>session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效<br>globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效<br>    其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</p>\n<p>如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p>\n<h4 id=\"spring-自动装配-bean-有哪些方式？\"><a href=\"#spring-自动装配-bean-有哪些方式？\" class=\"headerlink\" title=\"spring 自动装配 bean 有哪些方式？\"></a>spring 自动装配 bean 有哪些方式？</h4><p>Spring容器负责创建应用程序中的bean同时通过ID来协调这些对象之间的关系。作为开发人员，我们需要告诉Spring要创建哪些bean并且如何将其装配到一起。</p>\n<p>spring中bean装配有两种方式：</p>\n<p>隐式的bean发现机制和自动装配<br>在java代码或者XML中进行显示配置<br>当然这些方式也可以配合使用。</p>\n<h4 id=\"spring-事务实现方式有哪些？\"><a href=\"#spring-事务实现方式有哪些？\" class=\"headerlink\" title=\"spring 事务实现方式有哪些？\"></a>spring 事务实现方式有哪些？</h4><p>编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。<br>基于 TransactionProxyFactoryBean 的声明式事务管理<br>基于 @Transactional 的声明式事务管理<br>基于 Aspectj AOP 配置事务</p>\n<h4 id=\"说一下-spring-的事务隔离？\"><a href=\"#说一下-spring-的事务隔离？\" class=\"headerlink\" title=\"说一下 spring 的事务隔离？\"></a>说一下 spring 的事务隔离？</h4><p>事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p>\n<p>脏读：一个事务读到另一个事务未提交的更新数据。</p>\n<p>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</p>\n<p>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</p>\n<h4 id=\"说一下-spring-mvc-运行流程？\"><a href=\"#说一下-spring-mvc-运行流程？\" class=\"headerlink\" title=\"说一下 spring mvc 运行流程？\"></a>说一下 spring mvc 运行流程？</h4><p>Spring MVC运行流程图：</p>\n<p>Spring MVC运行描述：</p>\n<ol>\n<li><p>用户发送请求至前端控制器DispatcherServlet</p>\n</li>\n<li><p>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p>\n</li>\n<li><p>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>\n</li>\n<li><p>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</p>\n</li>\n<li><p>HandlerAdapter执行处理器(handler，也叫后端控制器)。</p>\n</li>\n<li><p>Controller执行完成返回ModelAndView</p>\n</li>\n<li><p>HandlerAdapter将handler执行结果ModelAndView返回给DispatcherServlet</p>\n</li>\n<li><p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p>\n</li>\n<li><p>ViewReslover解析后返回具体View对象</p>\n</li>\n<li><p>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p>\n</li>\n<li><p>DispatcherServlet响应用户</p>\n<p>​    </p>\n</li>\n</ol>\n<h4 id=\"spring-mvc-有哪些组件？\"><a href=\"#spring-mvc-有哪些组件？\" class=\"headerlink\" title=\"spring mvc 有哪些组件？\"></a>spring mvc 有哪些组件？</h4><p>Spring MVC的核心组件：</p>\n<p>DispatcherServlet：中央控制器，把请求给转发到具体的控制类<br>Controller：具体处理请求的控制器<br>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略<br>ModelAndView：服务层返回的数据和视图层的封装类<br>ViewResolver：视图解析器，解析具体的视图<br>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</p>\n<h4 id=\"RequestMapping-的作用是什么？\"><a href=\"#RequestMapping-的作用是什么？\" class=\"headerlink\" title=\"@RequestMapping 的作用是什么？\"></a>@RequestMapping 的作用是什么？</h4><p>RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。</p>\n<p>RequestMapping注解有六个属性，下面我们把她分成三类进行说明。</p>\n<p>value， method：</p>\n<p>value：指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；<br>method：指定请求的method类型， GET、POST、PUT、DELETE等；<br>consumes，produces<br>consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html；<br>produces：指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；<br>params，headers</p>\n<p>params： 指定request中必须包含某些参数值是，才让该方法处理。<br>headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。</p>\n<h4 id=\"Autowired-的作用是什么？\"><a href=\"#Autowired-的作用是什么？\" class=\"headerlink\" title=\"@Autowired 的作用是什么？\"></a>@Autowired 的作用是什么？</h4><p>《@Autowired用法详解》：blog.csdn.net/u013257679/article/details/52295106</p>\n<h2 id=\"Spring-Boot-Spring-Cloud\"><a href=\"#Spring-Boot-Spring-Cloud\" class=\"headerlink\" title=\"Spring Boot / Spring Cloud\"></a>Spring Boot / Spring Cloud</h2><h2 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h2><h4 id=\"mybatis-中-和-的区别是什么？\"><a href=\"#mybatis-中-和-的区别是什么？\" class=\"headerlink\" title=\"mybatis 中 #{}和 ${}的区别是什么？\"></a>mybatis 中 #{}和 ${}的区别是什么？</h4><p>${}是字符串替换；#{}是预编译处理。</p>\n<p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；<br>Mybatis在处理${}时，就是把${}替换成变量的值；<br>使用#{}可以有效的防止SQL注入，提高系统安全性。</p>\n<h4 id=\"mybatis-有几种分页方式？\"><a href=\"#mybatis-有几种分页方式？\" class=\"headerlink\" title=\"mybatis 有几种分页方式？\"></a>mybatis 有几种分页方式？</h4><p>数组分页<br>sql分页<br>拦截器分页<br>RowBounds分页</p>\n<h4 id=\"mybatis-逻辑分页和物理分页的区别是什么？\"><a href=\"#mybatis-逻辑分页和物理分页的区别是什么？\" class=\"headerlink\" title=\"mybatis 逻辑分页和物理分页的区别是什么？\"></a>mybatis 逻辑分页和物理分页的区别是什么？</h4><p>物理分页速度上并不一定快于逻辑分页，逻辑分页速度上也并不一定快于物理分页。<br>物理分页总是优于逻辑分页：没有必要将属于数据库端的压力加诸到应用端来，就算速度上存在优势,然而其它性能上的优点足以弥补这个缺点。</p>\n<h4 id=\"mybatis-是否支持延迟加载？延迟加载的原理是什么？\"><a href=\"#mybatis-是否支持延迟加载？延迟加载的原理是什么？\" class=\"headerlink\" title=\"mybatis 是否支持延迟加载？延迟加载的原理是什么？\"></a>mybatis 是否支持延迟加载？延迟加载的原理是什么？</h4><p>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p>\n<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p>\n<p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>\n<h4 id=\"说一下-mybatis-的一级缓存和二级缓存？\"><a href=\"#说一下-mybatis-的一级缓存和二级缓存？\" class=\"headerlink\" title=\"说一下 mybatis 的一级缓存和二级缓存？\"></a>说一下 mybatis 的一级缓存和二级缓存？</h4><p>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。 </p>\n<p>二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache> ； </cache></p>\n<p>对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>\n<h4 id=\"mybatis-和-hibernate-的区别有哪些？\"><a href=\"#mybatis-和-hibernate-的区别有哪些？\" class=\"headerlink\" title=\"mybatis 和 hibernate 的区别有哪些？\"></a>mybatis 和 hibernate 的区别有哪些？</h4><p>（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</p>\n<p>（2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 </p>\n<p>（3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。 </p>\n<h4 id=\"mybatis-有哪些执行器（Executor）？\"><a href=\"#mybatis-有哪些执行器（Executor）？\" class=\"headerlink\" title=\"mybatis 有哪些执行器（Executor）？\"></a>mybatis 有哪些执行器（Executor）？</h4><p>Mybatis有三种基本的执行器（Executor）：</p>\n<p>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。<br>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。<br>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p>\n<h4 id=\"mybatis-分页插件的实现原理是什么？\"><a href=\"#mybatis-分页插件的实现原理是什么？\" class=\"headerlink\" title=\"mybatis 分页插件的实现原理是什么？\"></a>mybatis 分页插件的实现原理是什么？</h4><p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>\n<h4 id=\"mybatis-如何编写一个自定义插件？\"><a href=\"#mybatis-如何编写一个自定义插件？\" class=\"headerlink\" title=\"mybatis 如何编写一个自定义插件？\"></a>mybatis 如何编写一个自定义插件？</h4><p>转自：blog.csdn.net/qq_30051265/article/details/80266434</p>\n<p>  Mybatis自定义插件针对Mybatis四大对象（Executor、StatementHandler 、ParameterHandler 、ResultSetHandler ）进行拦截，具体拦截方式为：</p>\n<p>Executor：拦截执行器的方法(log记录)<br>StatementHandler ：拦截Sql语法构建的处理<br>ParameterHandler ：拦截参数的处理<br>ResultSetHandler ：拦截结果集的处理<br>Mybatis自定义插件必须实现Interceptor接口：</p>\n<p>public interface Interceptor {<br>    Object intercept(Invocation invocation) throws Throwable;<br>    Object plugin(Object target);<br>    void setProperties(Properties properties);<br>}<br>intercept方法：拦截器具体处理逻辑方法 </p>\n<p>plugin方法：根据签名signatureMap生成动态代理对象 </p>\n<p>setProperties方法：设置Properties属性 </p>\n<p>自定义插件demo：</p>\n<p>// ExamplePlugin.java<br>@Intercepts({@Signature(<br>  type= Executor.class,<br>  method = “update”,<br>  args = {MappedStatement.class,Object.class})})<br>public class ExamplePlugin implements Interceptor {<br>  public Object intercept(Invocation invocation) throws Throwable {<br>  Object target = invocation.getTarget(); //被代理对象<br>  Method method = invocation.getMethod(); //代理方法<br>  Object[] args = invocation.getArgs(); //方法参数<br>  // do something …… 方法拦截前执行代码块<br>  Object result = invocation.proceed();<br>  // do something …….方法拦截后执行代码块<br>  return result;<br>  }<br>  public Object plugin(Object target) {<br>    return Plugin.wrap(target, this);<br>  }<br>  public void setProperties(Properties properties) {<br>  }<br>}</p>\n<p>一个@Intercepts可以配置多个@Signature，@Signature中的参数定义如下： </p>\n<p>type：表示拦截的类，这里是Executor的实现类；<br>method：表示拦截的方法，这里是拦截Executor的update方法；<br>args：表示方法参数。</p>\n<h2 id=\"MySql\"><a href=\"#MySql\" class=\"headerlink\" title=\"MySql\"></a>MySql</h2><h4 id=\"数据库的三范式是什么？\"><a href=\"#数据库的三范式是什么？\" class=\"headerlink\" title=\"数据库的三范式是什么？\"></a>数据库的三范式是什么？</h4><p>第一范式：强调的是列的原子性，即数据库表的每一列都是不可分割的原子数据项。<br>第二范式：要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性。<br>第三范式：任何非主属性不依赖于其它非主属性。</p>\n<h4 id=\"一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了1条数据，此时-id-是几？\"><a href=\"#一张自增表里面总共有-7-条数据，删除了最后-2-条数据，重启-mysql-数据库，又插入了1条数据，此时-id-是几？\" class=\"headerlink\" title=\"一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了1条数据，此时 id 是几？\"></a>一张自增表里面总共有 7 条数据，删除了最后 2 条数据，重启 mysql 数据库，又插入了1条数据，此时 id 是几？</h4><p>表类型如果是 MyISAM ，那 id 就是 8。<br>表类型如果是 InnoDB，那 id 就是 8。并没有变化</p>\n<h4 id=\"如何获取当前数据库版本？\"><a href=\"#如何获取当前数据库版本？\" class=\"headerlink\" title=\"如何获取当前数据库版本？\"></a>如何获取当前数据库版本？</h4><p>使用 select version() 获取当前 MySQL 数据库版本。</p>\n<h4 id=\"说一下-ACID-是什么？\"><a href=\"#说一下-ACID-是什么？\" class=\"headerlink\" title=\"说一下 ACID 是什么？\"></a>说一下 ACID 是什么？</h4><p>Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。<br>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br>Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。<br>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>\n<h4 id=\"char-和-varchar-的区别是什么？\"><a href=\"#char-和-varchar-的区别是什么？\" class=\"headerlink\" title=\"char 和 varchar 的区别是什么？\"></a>char 和 varchar 的区别是什么？</h4><p>char(n) ：固定长度类型，比如订阅 char(10)，当你输入”abc”三个字符的时候，它们占的空间还是 10 个字节，其他 7 个是空字节。</p>\n<p>chat 优点：效率高；缺点：占用空间；适用场景：存储密码的 md5 值，固定长度的，使用 char 非常合适。</p>\n<p>varchar(n) ：可变长度，存储的值是每个值占用的字节再加上一个用来记录其长度的字节的长度。</p>\n<p>所以，从空间上考虑 varcahr 比较合适；从效率上考虑 char 比较合适，二者使用需要权衡。</p>\n<h4 id=\"float-和-double-的区别是什么？\"><a href=\"#float-和-double-的区别是什么？\" class=\"headerlink\" title=\"float 和 double 的区别是什么？\"></a>float 和 double 的区别是什么？</h4><p>float 最多可以存储 8 位的十进制数，并在内存中占 4 字节。<br>double 最可可以存储 16 位的十进制数，并在内存中占 8 字节。</p>\n<h4 id=\"mysql-的内连接、左连接、右连接有什么区别？\"><a href=\"#mysql-的内连接、左连接、右连接有什么区别？\" class=\"headerlink\" title=\"mysql 的内连接、左连接、右连接有什么区别？\"></a>mysql 的内连接、左连接、右连接有什么区别？</h4><p>内连接关键字：inner join；左连接：left join；右连接：right join。</p>\n<p>内连接是把匹配的关联数据显示出来；左连接是左边的表全部显示出来，右边的表显示出符合条件的数据；右连接正好相反。</p>\n<h4 id=\"mysql-索引是怎么实现的？\"><a href=\"#mysql-索引是怎么实现的？\" class=\"headerlink\" title=\"mysql 索引是怎么实现的？\"></a>mysql 索引是怎么实现的？</h4><p>索引是满足某种特定查找算法的数据结构，而这些数据结构会以某种方式指向数据，从而实现高效查找数据。</p>\n<p>具体来说 MySQL 中的索引，不同的数据引擎实现有所不同，但目前主流的数据库引擎的索引都是 B+ 树实现的，B+ 树的搜索效率，可以到达二分法的性能，找到数据区域之后就找到了完整的数据结构了，所有索引的性能也是更好的。</p>\n<h4 id=\"怎么验证-mysql-的索引是否满足需求？\"><a href=\"#怎么验证-mysql-的索引是否满足需求？\" class=\"headerlink\" title=\"怎么验证 mysql 的索引是否满足需求？\"></a>怎么验证 mysql 的索引是否满足需求？</h4><p>使用 explain 查看 SQL 是如何执行查询语句的，从而分析你的索引是否满足需求。</p>\n<p>explain 语法：explain select * from table where type=1。</p>\n<h4 id=\"说一下数据库的事务隔离？\"><a href=\"#说一下数据库的事务隔离？\" class=\"headerlink\" title=\"说一下数据库的事务隔离？\"></a>说一下数据库的事务隔离？</h4><p>MySQL 的事务隔离是在 MySQL. ini 配置文件里添加的，在文件的最后添加：transaction-isolation = REPEATABLE-READ</p>\n<p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p>\n<p>READ-UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）。<br>READ-COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读）。<br>REPEATABLE-READ：可重复读，默认级别，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读）。<br>SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p>\n<p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p>\n<p>不可重复读 ：是指在一个事务内，多次读同一数据。</p>\n<p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p>\n<h4 id=\"说一下-mysql-常用的引擎？\"><a href=\"#说一下-mysql-常用的引擎？\" class=\"headerlink\" title=\"说一下 mysql 常用的引擎？\"></a>说一下 mysql 常用的引擎？</h4><p>InnoDB 引擎：InnoDB 引擎提供了对数据库 acid 事务的支持，并且还提供了行级锁和外键的约束，它的设计的目标就是处理大数据容量的数据库系统。MySQL 运行的时候，InnoDB 会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎是不支持全文搜索，同时启动也比较的慢，它是不会保存表的行数的，所以当进行 select count(*) from table 指令的时候，需要进行扫描全表。由于锁的粒度小，写操作是不会锁定全表的,所以在并发度较高的场景下使用会提升效率的。</p>\n<p>MyIASM 引擎：MySQL 的默认引擎，但不提供事务的支持，也不支持行级锁和外键。因此当执行插入和更新语句时，即执行写操作的时候需要锁定这个表，所以会导致效率会降低。不过和 InnoDB 不同的是，MyIASM 引擎是保存了表的行数，于是当进行 select count(*) from table 语句时，可以直接的读取已经保存的值而不需要进行扫描全表。所以，如果表的读操作远远多于写操作时，并且不需要事务的支持的，可以将 MyIASM 作为数据库引擎的首选。</p>\n<h4 id=\"说一下-mysql-的行锁和表锁？\"><a href=\"#说一下-mysql-的行锁和表锁？\" class=\"headerlink\" title=\"说一下 mysql 的行锁和表锁？\"></a>说一下 mysql 的行锁和表锁？</h4><p>MyISAM 只支持表锁，InnoDB 支持表锁和行锁，默认为行锁。</p>\n<p>表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低。<br>行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。</p>\n<h4 id=\"说一下乐观锁和悲观锁？\"><a href=\"#说一下乐观锁和悲观锁？\" class=\"headerlink\" title=\"说一下乐观锁和悲观锁？\"></a>说一下乐观锁和悲观锁？</h4><p>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。<br>悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。</p>\n<p>数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。</p>\n<h4 id=\"mysql-问题排查都有哪些手段？\"><a href=\"#mysql-问题排查都有哪些手段？\" class=\"headerlink\" title=\"mysql 问题排查都有哪些手段？\"></a>mysql 问题排查都有哪些手段？</h4><p>使用 show processlist 命令查看当前所有连接信息。<br>使用 explain 命令查询 SQL 语句执行计划。<br>开启慢查询日志，查看慢查询的 SQL。</p>\n<h4 id=\"如何做-mysql-的性能优化？\"><a href=\"#如何做-mysql-的性能优化？\" class=\"headerlink\" title=\"如何做 mysql 的性能优化？\"></a>如何做 mysql 的性能优化？</h4><p>为搜索字段创建索引。<br>避免使用 select *，列出需要查询的字段。<br>垂直分割分表。<br>选择正确的存储引擎。</p>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><h4 id=\"redis-是什么？\"><a href=\"#redis-是什么？\" class=\"headerlink\" title=\"redis 是什么？\"></a>redis 是什么？</h4><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>\n<h4 id=\"redis-有哪些使用场景\"><a href=\"#redis-有哪些使用场景\" class=\"headerlink\" title=\"redis 有哪些使用场景\"></a>redis 有哪些使用场景</h4><p>数据高并发的读写<br>海量数据的读写<br>对扩展性要求高的数据</p>\n<h4 id=\"redis-有哪些功能？\"><a href=\"#redis-有哪些功能？\" class=\"headerlink\" title=\"redis 有哪些功能？\"></a>redis 有哪些功能？</h4><p>数据缓存功能<br>分布式锁的功能<br>支持数据持久化<br>支持事务<br>支持消息队列</p>\n<h4 id=\"redis-和-memecache-的区别？\"><a href=\"#redis-和-memecache-的区别？\" class=\"headerlink\" title=\"redis 和 memecache 的区别？\"></a>redis 和 memecache 的区别？</h4><p>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型<br>redis的速度比memcached快很多<br>redis可以持久化其数据</p>\n<h4 id=\"redis-为什么是单线程的？\"><a href=\"#redis-为什么是单线程的？\" class=\"headerlink\" title=\"redis 为什么是单线程的？\"></a>redis 为什么是单线程的？</h4><p>因为 cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。</p>\n<p>关于 Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。</p>\n<p>而且单线程并不代表就慢 nginx 和 nodejs 也都是高性能单线程的代表。</p>\n<h4 id=\"什么是缓存穿透？怎么解决？\"><a href=\"#什么是缓存穿透？怎么解决？\" class=\"headerlink\" title=\"什么是缓存穿透？怎么解决？\"></a>什么是缓存穿透？怎么解决？</h4><p>缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。</p>\n<p>解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p>\n<h4 id=\"redis-支持的数据类型有哪些？\"><a href=\"#redis-支持的数据类型有哪些？\" class=\"headerlink\" title=\"redis 支持的数据类型有哪些？\"></a>redis 支持的数据类型有哪些？</h4><p>string、list、hash、set、zset。</p>\n<h4 id=\"redis-支持哪些-java-客户端？\"><a href=\"#redis-支持哪些-java-客户端？\" class=\"headerlink\" title=\"redis 支持哪些 java 客户端？\"></a>redis 支持哪些 java 客户端？</h4><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p>\n<h4 id=\"jedis-和-redisson-有哪些区别？\"><a href=\"#jedis-和-redisson-有哪些区别？\" class=\"headerlink\" title=\"jedis 和 redisson 有哪些区别？\"></a>jedis 和 redisson 有哪些区别？</h4><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持。</p>\n<p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p>\n<h4 id=\"redis缓存和数据库数据的一致性？\"><a href=\"#redis缓存和数据库数据的一致性？\" class=\"headerlink\" title=\"redis缓存和数据库数据的一致性？\"></a>redis缓存和数据库数据的一致性？</h4><p>合理设置缓存的过期时间。<br>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</p>\n<h4 id=\"redis-持久化有几种方式？\"><a href=\"#redis-持久化有几种方式？\" class=\"headerlink\" title=\"redis 持久化有几种方式？\"></a>redis 持久化有几种方式？</h4><p>Redis 的持久化有两种方式，或者说有两种策略：</p>\n<p>RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。</p>\n<p>AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。</p>\n<h4 id=\"redis-怎么实现分布式锁？\"><a href=\"#redis-怎么实现分布式锁？\" class=\"headerlink\" title=\"redis 怎么实现分布式锁？\"></a>redis 怎么实现分布式锁？</h4><p>Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。</p>\n<p>占坑一般使用 setnx(set if not exists)指令，只允许被一个程序占有，使用完调用 del 释放锁。</p>\n<h4 id=\"redis-分布式锁有什么缺陷？\"><a href=\"#redis-分布式锁有什么缺陷？\" class=\"headerlink\" title=\"redis 分布式锁有什么缺陷？\"></a>redis 分布式锁有什么缺陷？</h4><p>Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。</p>\n<h4 id=\"redis-如何做内存优化？\"><a href=\"#redis-如何做内存优化？\" class=\"headerlink\" title=\"redis 如何做内存优化？\"></a>redis 如何做内存优化？</h4><p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。 </p>\n<p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>\n<h4 id=\"redis-淘汰策略有哪些？\"><a href=\"#redis-淘汰策略有哪些？\" class=\"headerlink\" title=\"redis 淘汰策略有哪些？\"></a>redis 淘汰策略有哪些？</h4><p>volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰。</p>\n<p>volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。</p>\n<p>volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。</p>\n<p>allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。</p>\n<p>allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。<br>no-enviction（驱逐）：禁止驱逐数据。</p>\n<h4 id=\"redis-常见的性能问题有哪些？\"><a href=\"#redis-常见的性能问题有哪些？\" class=\"headerlink\" title=\"redis 常见的性能问题有哪些？\"></a>redis 常见的性能问题有哪些？</h4><p>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。<br>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</p>\n<h2 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h2><h4 id=\"zookeeper-是什么？\"><a href=\"#zookeeper-是什么？\" class=\"headerlink\" title=\"zookeeper 是什么？\"></a>zookeeper 是什么？</h4><p>zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 google chubby 的开源实现，是 hadoop 和 hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。</p>\n<h4 id=\"zookeeper-都有哪些功能？\"><a href=\"#zookeeper-都有哪些功能？\" class=\"headerlink\" title=\"zookeeper 都有哪些功能？\"></a>zookeeper 都有哪些功能？</h4><p>集群管理：监控节点存活状态、运行请求等。<br>主节点选举：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 zookeeper 可以协助完成这个过程。<br>分布式锁：zookeeper 提供两种锁：独占锁、共享锁。独占锁即一次只能有一个线程使用资源，共享锁是读锁共享，读写互斥，即可以有多线线程同时读同一个资源，如果要使用写锁也只能有一个线程使用。zookeeper可以对分布式锁进行控制。<br>命名服务：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息。</p>\n<h4 id=\"说一下-zookeeper-的通知机制？\"><a href=\"#说一下-zookeeper-的通知机制？\" class=\"headerlink\" title=\"说一下 zookeeper 的通知机制？\"></a>说一下 zookeeper 的通知机制？</h4><p>客户端端会对某个 znode 建立一个 watcher 事件，当该 znode 发生变化时，这些客户端会收到 zookeeper 的通知，然后客户端可以根据 znode 变化来做出业务上的改变。</p>\n<h4 id=\"zookeeper-有几种部署模式？\"><a href=\"#zookeeper-有几种部署模式？\" class=\"headerlink\" title=\"zookeeper 有几种部署模式？\"></a>zookeeper 有几种部署模式？</h4><p>zookeeper 有三种部署模式：</p>\n<p>单机部署：一台集群上运行；<br>集群部署：多台集群运行；<br>伪集群部署：一台集群启动多个 zookeeper 实例运行。</p>\n<h4 id=\"zookeeper-怎么保证主从节点的状态同步？\"><a href=\"#zookeeper-怎么保证主从节点的状态同步？\" class=\"headerlink\" title=\"zookeeper 怎么保证主从节点的状态同步？\"></a>zookeeper 怎么保证主从节点的状态同步？</h4><p>zookeeper 的核心是原子广播，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 zab 协议。 zab 协议有两种模式，分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 server 具有相同的系统状态。</p>\n<h4 id=\"集群中为什么要有主节点？\"><a href=\"#集群中为什么要有主节点？\" class=\"headerlink\" title=\"集群中为什么要有主节点？\"></a>集群中为什么要有主节点？</h4><p>在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，所以就需要主节点。</p>\n<h4 id=\"集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？\"><a href=\"#集群中有-3-台服务器，其中一个节点宕机，这个时候-zookeeper-还可以使用吗？\" class=\"headerlink\" title=\"集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？\"></a>集群中有 3 台服务器，其中一个节点宕机，这个时候 zookeeper 还可以使用吗？</h4><p>可以继续使用，单数服务器只要没超过一半的服务器宕机就可以继续使用。</p>\n<h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h4 id=\"jvm的主要组成部分和作用？\"><a href=\"#jvm的主要组成部分和作用？\" class=\"headerlink\" title=\"jvm的主要组成部分和作用？\"></a>jvm的主要组成部分和作用？</h4><p>类加载器（ClassLoader）<br>运行时数据区（Runtime Data Area）<br>执行引擎（Execution Engine）<br>本地库接口（Native Interface）</p>\n<p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p>\n<h4 id=\"jvm-运行时数据区？\"><a href=\"#jvm-运行时数据区？\" class=\"headerlink\" title=\"jvm 运行时数据区？\"></a>jvm 运行时数据区？</h4><p>程序计数器<br>虚拟机栈<br>本地方法栈<br>堆<br>方法区</p>\n<p>有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户进程的启动和结束而创建和销毁。</p>\n<h4 id=\"堆栈的区别？\"><a href=\"#堆栈的区别？\" class=\"headerlink\" title=\"堆栈的区别？\"></a>堆栈的区别？</h4><p>栈内存存储的是局部变量而堆内存存储的是实体；</p>\n<p>栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；</p>\n<p>栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。</p>\n<h4 id=\"队列和栈是什么？有什么区别？\"><a href=\"#队列和栈是什么？有什么区别？\" class=\"headerlink\" title=\"队列和栈是什么？有什么区别？\"></a>队列和栈是什么？有什么区别？</h4><p>队列和栈都是被用来预存储数据的。<br>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。<br>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p>\n<h4 id=\"什么是双亲委派模型？\"><a href=\"#什么是双亲委派模型？\" class=\"headerlink\" title=\"什么是双亲委派模型？\"></a>什么是双亲委派模型？</h4><p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p>\n<p>类加载器分类：</p>\n<p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；<br>其他类加载器：<br>扩展类加载器（Extension ClassLoader）：负责加载<java_home style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; outline: 0px !important;\">\\lib\\ext目录或Java. ext. dirs系统变量指定的路径中的所有类库；</java_home><br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p>\n<p>双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加载请求都会被传送到顶层的启动类加载器中，只有当父加载无法完成加载请求（它的搜索范围中没找到所需的类）时，子加载器才会尝试去加载类。</p>\n<h4 id=\"说一下类加载的执行过程？\"><a href=\"#说一下类加载的执行过程？\" class=\"headerlink\" title=\"说一下类加载的执行过程？\"></a>说一下类加载的执行过程？</h4><p>类加载分为以下 5 个步骤：</p>\n<p>加载：根据查找路径找到相应的 class 文件然后导入；<br>检查：检查加载的 class 文件的正确性；<br>准备：给类中的静态变量分配内存空间；<br>解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；<br>初始化：对静态变量和静态代码块执行初始化工作。</p>\n<h4 id=\"怎么判断对象是否可以被回收？\"><a href=\"#怎么判断对象是否可以被回收？\" class=\"headerlink\" title=\"怎么判断对象是否可以被回收？\"></a>怎么判断对象是否可以被回收？</h4><p>一般有两种方法来判断：</p>\n<p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；<br>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p>\n<h4 id=\"java-中都有哪些引用类型？\"><a href=\"#java-中都有哪些引用类型？\" class=\"headerlink\" title=\"java 中都有哪些引用类型？\"></a>java 中都有哪些引用类型？</h4><p>强引用<br>软引用<br>弱引用<br>虚引用（幽灵引用/幻影引用）</p>\n<h4 id=\"说一下-jvm-有哪些垃圾回收算法？\"><a href=\"#说一下-jvm-有哪些垃圾回收算法？\" class=\"headerlink\" title=\"说一下 jvm 有哪些垃圾回收算法？\"></a>说一下 jvm 有哪些垃圾回收算法？</h4><p>标记-清除算法<br>标记-整理算法<br>复制算法<br>分代算法</p>\n<h4 id=\"说一下-jvm-有哪些垃圾回收器？\"><a href=\"#说一下-jvm-有哪些垃圾回收器？\" class=\"headerlink\" title=\"说一下 jvm 有哪些垃圾回收器？\"></a>说一下 jvm 有哪些垃圾回收器？</h4><p>Serial：最早的单线程串行垃圾回收器。<br>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。<br>ParNew：是 Serial 的多线程版本。<br>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。<br>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。<br>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。<br>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p>\n<h4 id=\"详细介绍一下-CMS-垃圾回收器？\"><a href=\"#详细介绍一下-CMS-垃圾回收器？\" class=\"headerlink\" title=\"详细介绍一下 CMS 垃圾回收器？\"></a>详细介绍一下 CMS 垃圾回收器？</h4><p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p>\n<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p>\n<h4 id=\"新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？\"><a href=\"#新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？\" class=\"headerlink\" title=\"新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？\"></a>新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h4><p>新生代回收器：Serial、ParNew、Parallel Scavenge<br>老年代回收器：Serial Old、Parallel Old、CMS<br>整堆回收器：G1</p>\n<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p>\n<h4 id=\"简述分代垃圾回收器怎么工作的？\"><a href=\"#简述分代垃圾回收器怎么工作的？\" class=\"headerlink\" title=\"简述分代垃圾回收器怎么工作的？\"></a>简述分代垃圾回收器怎么工作的？</h4><p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。</p>\n<p> 新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p>\n<p> 把 Eden + From Survivor 存活的对象放入 To Survivor 区；<br>清空 Eden 和 From Survivor 分区；<br>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。<br>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</p>\n<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>\n<h4 id=\"说一下-jvm-调优的工具？\"><a href=\"#说一下-jvm-调优的工具？\" class=\"headerlink\" title=\"说一下 jvm 调优的工具？\"></a>说一下 jvm 调优的工具？</h4><p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p>\n<p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；<br>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p>\n<h4 id=\"常用的-jvm-调优的参数都有哪些？\"><a href=\"#常用的-jvm-调优的参数都有哪些？\" class=\"headerlink\" title=\"常用的 jvm 调优的参数都有哪些？\"></a>常用的 jvm 调优的参数都有哪些？</h4><p>-Xms2g：初始化推大小为 2g；<br>-Xmx2g：堆最大内存为 2g；<br>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；<br>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；<br>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；<br>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；<br>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；<br>-XX:+PrintGC：开启打印 gc 信息；<br>-XX:+PrintGCDetails：打印 gc 详细信息。</p>\n<h2 id=\"程序优化\"><a href=\"#程序优化\" class=\"headerlink\" title=\"程序优化\"></a>程序优化</h2><h4 id=\"慎用异常\"><a href=\"#慎用异常\" class=\"headerlink\" title=\"慎用异常\"></a>慎用异常</h4><p>try-catch不要放在循环中，尽量把try-catsh放到循环体外来提升性能。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;        </span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;        </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">                a = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">                System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用局部环境\"><a href=\"#使用局部环境\" class=\"headerlink\" title=\"使用局部环境\"></a>使用局部环境</h4><p>局部变量的访问速度高于类的成员变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  private static int a = 0;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;        </span><br><span class=\"line\">       <span class=\"keyword\">int</span> a = <span class=\"number\">0</span>;        </span><br><span class=\"line\">       <span class=\"keyword\">long</span> start = System.currentTimeMillis();        </span><br><span class=\"line\">       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000000</span>; i++) &#123;</span><br><span class=\"line\">            a = a + <span class=\"number\">1</span>;</span><br><span class=\"line\">            System.out.println(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(System.currentTimeMillis() - start);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"位运算代替乘除法\"><a href=\"#位运算代替乘除法\" class=\"headerlink\" title=\"位运算代替乘除法\"></a>位运算代替乘除法</h4><p>HashMap的源码中使用了位运算，a*=2和a/=2，用位运算可以写为a&lt;&lt;=1，a&gt;&gt;=1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck6q61bie0006a6ybtctnipa3","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bit000qa6ybq002iqwc"},{"post_id":"ck6q61bie0006a6ybtctnipa3","category_id":"ck6q61bin000ha6ybd6434d7o","_id":"ck6q61biu000ua6ybc5zhu7i9"},{"post_id":"ck6q61bi40000a6yb9mmmc62x","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61biv000ya6yb8mmmxi1z"},{"post_id":"ck6q61bi40000a6yb9mmmc62x","category_id":"ck6q61biq000ma6yb87o1vpvj","_id":"ck6q61bix0012a6ybnq2hk7rh"},{"post_id":"ck6q61bit000ta6ybxp4nqhox","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61biy0016a6yb87sturs5"},{"post_id":"ck6q61bif0007a6ybpy2jsvmj","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bj00019a6ybzyo51sua"},{"post_id":"ck6q61bif0007a6ybpy2jsvmj","category_id":"ck6q61bin000ha6ybd6434d7o","_id":"ck6q61bj2001da6yb5mhq7j37"},{"post_id":"ck6q61bii000aa6ybf1clbo56","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bj3001ga6yb3ximsett"},{"post_id":"ck6q61bii000aa6ybf1clbo56","category_id":"ck6q61bin000ha6ybd6434d7o","_id":"ck6q61bj4001ia6yb3afjinvj"},{"post_id":"ck6q61biz0017a6ybenu5rvm4","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bj4001ja6yb27ifuksk"},{"post_id":"ck6q61bi90002a6ybrrqva6fd","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bj5001na6yboopfzxgl"},{"post_id":"ck6q61bi90002a6ybrrqva6fd","category_id":"ck6q61biq000ma6yb87o1vpvj","_id":"ck6q61bj6001pa6ybrdnwvrjr"},{"post_id":"ck6q61bj0001ba6ybeva6hrl9","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bj7001ra6ybhrannr66"},{"post_id":"ck6q61bik000ea6ybb7um2c4d","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bj9001ta6ybgfg5dmxh"},{"post_id":"ck6q61bik000ea6ybb7um2c4d","category_id":"ck6q61bin000ha6ybd6434d7o","_id":"ck6q61bja001va6yb6g6peu92"},{"post_id":"ck6q61bid0005a6ybbvaxq4lc","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bja001ya6yb7iz7nmdm"},{"post_id":"ck6q61bid0005a6ybbvaxq4lc","category_id":"ck6q61biq000ma6yb87o1vpvj","_id":"ck6q61bjb0021a6ybwdiy751q"},{"post_id":"ck6q61bil000ga6ybvqvdka2a","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bjc0023a6ybop2kazrf"},{"post_id":"ck6q61bil000ga6ybvqvdka2a","category_id":"ck6q61bj5001ma6ybnuj7jniw","_id":"ck6q61bjc0025a6yb5xx098ke"},{"post_id":"ck6q61bio000ka6ybraxtcqaw","category_id":"ck6q61bj8001sa6ybof88zfi9","_id":"ck6q61bjc0028a6ybgjqprrj3"},{"post_id":"ck6q61biq000la6ybc0kua0yz","category_id":"ck6q61bj8001sa6ybof88zfi9","_id":"ck6q61bjd002ba6ybjqk9qdt7"},{"post_id":"ck6q61biv000wa6yb8mlvt8cq","category_id":"ck6q61bj8001sa6ybof88zfi9","_id":"ck6q61bjd002da6ybqk941j98"},{"post_id":"ck6q61biw0011a6ybwkcddtcf","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bje002fa6yb1oimtm2m"},{"post_id":"ck6q61biw0011a6ybwkcddtcf","category_id":"ck6q61bj5001ma6ybnuj7jniw","_id":"ck6q61bje002ha6ybgx4pmvzr"},{"post_id":"ck6q61bix0014a6yb17in9nac","category_id":"ck6q61bj8001sa6ybof88zfi9","_id":"ck6q61bje002ka6ybj4qtcisl"},{"post_id":"ck6q61bjt003qa6ybhagsbxdb","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bjx003wa6ybo025dwg3"},{"post_id":"ck6q61bju003sa6yb7luw8v0a","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bjy003ya6ybvk36a50u"},{"post_id":"ck6q61bjv003ua6ybc54rojzy","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bjz0041a6ybap9uccf0"},{"post_id":"ck6q61bjw003va6ybnoh59c2f","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bjz0043a6ybpcvu48gk"},{"post_id":"ck6q61bjx003xa6ybjfgvguy3","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61bjz0045a6ybfmb7k1qx"},{"post_id":"ck6q61cna004ia6ybkwdzdhzi","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61cne004ka6ybu0w2pnmh"},{"post_id":"ck6q61cna004ia6ybkwdzdhzi","category_id":"ck6q61bin000ha6ybd6434d7o","_id":"ck6q61cne004la6ybs0p5rrhh"},{"post_id":"ck6q61cno004pa6ybrotjuccn","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61cnp004sa6ybmepjxhye"},{"post_id":"ck6q61cnn004oa6ybaoe058f8","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61cnq004wa6ybjnxzstcq"},{"post_id":"ck6q61cnn004oa6ybaoe058f8","category_id":"ck6q61cnp004ra6yb6vruz1lt","_id":"ck6q61cnq004ya6ybdbbuiyvo"},{"post_id":"ck6q61cym0050a6yb8w97o5r0","category_id":"ck6q61bia0003a6ybtqtkebc1","_id":"ck6q61cyn0052a6ybmc8u1chm"}],"PostTag":[{"post_id":"ck6q61bi40000a6yb9mmmc62x","tag_id":"ck6q61bic0004a6ybksry934v","_id":"ck6q61bil000fa6ybqkwvsqb4"},{"post_id":"ck6q61bi40000a6yb9mmmc62x","tag_id":"ck6q61big0009a6ybzmqyzxvc","_id":"ck6q61bin000ia6yb2hzhl3xo"},{"post_id":"ck6q61bi90002a6ybrrqva6fd","tag_id":"ck6q61bic0004a6ybksry934v","_id":"ck6q61biu000va6yb0ee6w0mw"},{"post_id":"ck6q61bi90002a6ybrrqva6fd","tag_id":"ck6q61bio000ja6ybdbhanogo","_id":"ck6q61biv000za6ybpye6nc1b"},{"post_id":"ck6q61bi90002a6ybrrqva6fd","tag_id":"ck6q61bir000na6ybw0ccsdaa","_id":"ck6q61bix0013a6ybumr06gcj"},{"post_id":"ck6q61bid0005a6ybbvaxq4lc","tag_id":"ck6q61bic0004a6ybksry934v","_id":"ck6q61bj0001aa6yb3j75qvjk"},{"post_id":"ck6q61bid0005a6ybbvaxq4lc","tag_id":"ck6q61biw0010a6yb5xqd4lwd","_id":"ck6q61bj2001ea6ybpg672kux"},{"post_id":"ck6q61bie0006a6ybtctnipa3","tag_id":"ck6q61bj00018a6ybdb321ce7","_id":"ck6q61bj5001la6ybh4dmlaxi"},{"post_id":"ck6q61bie0006a6ybtctnipa3","tag_id":"ck6q61bj3001fa6ybuvpcsrro","_id":"ck6q61bj6001oa6ybsoyauyyg"},{"post_id":"ck6q61bif0007a6ybpy2jsvmj","tag_id":"ck6q61bj00018a6ybdb321ce7","_id":"ck6q61bja001wa6yb7u9dlm2u"},{"post_id":"ck6q61bif0007a6ybpy2jsvmj","tag_id":"ck6q61bj6001qa6ybgwuwrcjs","_id":"ck6q61bja001za6ybcvc1pq02"},{"post_id":"ck6q61bii000aa6ybf1clbo56","tag_id":"ck6q61bj00018a6ybdb321ce7","_id":"ck6q61bjc0026a6ybm78ljl6o"},{"post_id":"ck6q61bii000aa6ybf1clbo56","tag_id":"ck6q61bja0020a6ybxpun9r7l","_id":"ck6q61bjc0029a6ybyiyrivho"},{"post_id":"ck6q61bij000ba6ybj7q9l3rx","tag_id":"ck6q61bjc0024a6yb0ar2pd5e","_id":"ck6q61bje002ga6ybvz7y6ss4"},{"post_id":"ck6q61bij000ba6ybj7q9l3rx","tag_id":"ck6q61bjd002aa6yb35ryjacq","_id":"ck6q61bje002ia6yby4n1kxg7"},{"post_id":"ck6q61bik000ea6ybb7um2c4d","tag_id":"ck6q61bj00018a6ybdb321ce7","_id":"ck6q61bjf002ma6ybnc78ivf0"},{"post_id":"ck6q61bik000ea6ybb7um2c4d","tag_id":"ck6q61bje002ja6ybo0iuurqy","_id":"ck6q61bjf002na6yb5dqhxmnb"},{"post_id":"ck6q61bil000ga6ybvqvdka2a","tag_id":"ck6q61bjf002la6ybg4nkhgpg","_id":"ck6q61bjf002qa6ybl04jkght"},{"post_id":"ck6q61bil000ga6ybvqvdka2a","tag_id":"ck6q61bjf002oa6yb7ug6bd4q","_id":"ck6q61bjf002ra6ybztml9ym4"},{"post_id":"ck6q61bio000ka6ybraxtcqaw","tag_id":"ck6q61bjf002pa6ybjdaq3knm","_id":"ck6q61bjg002ua6ybmjjuhqd7"},{"post_id":"ck6q61bio000ka6ybraxtcqaw","tag_id":"ck6q61bjf002sa6ybaa78hj8u","_id":"ck6q61bjg002va6ybzre85ij7"},{"post_id":"ck6q61biq000la6ybc0kua0yz","tag_id":"ck6q61bjg002ta6ybx7ylbzp4","_id":"ck6q61bjh002ya6yb0iqdux3x"},{"post_id":"ck6q61biq000la6ybc0kua0yz","tag_id":"ck6q61bjg002wa6yb5qbwxnbo","_id":"ck6q61bjh002za6ybgpiete5e"},{"post_id":"ck6q61bir000oa6yb1u4zku5r","tag_id":"ck6q61bjc0024a6yb0ar2pd5e","_id":"ck6q61bjh0032a6ybvknct5n6"},{"post_id":"ck6q61bir000oa6yb1u4zku5r","tag_id":"ck6q61bjh0030a6ybvicwhhl7","_id":"ck6q61bjh0033a6yb9xqiaveg"},{"post_id":"ck6q61bit000ta6ybxp4nqhox","tag_id":"ck6q61bjh0031a6ybp02yvcay","_id":"ck6q61bji0036a6ybcjs2hxx9"},{"post_id":"ck6q61bit000ta6ybxp4nqhox","tag_id":"ck6q61bji0034a6ybi40d1onx","_id":"ck6q61bji0037a6ybf55hi8rg"},{"post_id":"ck6q61biv000wa6yb8mlvt8cq","tag_id":"ck6q61bjg002ta6ybx7ylbzp4","_id":"ck6q61bjj003aa6ybtzeway9e"},{"post_id":"ck6q61biv000wa6yb8mlvt8cq","tag_id":"ck6q61bji0038a6ybjf9t95an","_id":"ck6q61bjj003ba6yb25dmjzes"},{"post_id":"ck6q61biw0011a6ybwkcddtcf","tag_id":"ck6q61bjf002la6ybg4nkhgpg","_id":"ck6q61bjk003ea6yb3bcclu69"},{"post_id":"ck6q61biw0011a6ybwkcddtcf","tag_id":"ck6q61bjj003ca6ybedfwuvb9","_id":"ck6q61bjk003fa6ybq2tx7o5j"},{"post_id":"ck6q61bix0014a6yb17in9nac","tag_id":"ck6q61bjj003da6ybq7olgf40","_id":"ck6q61bjk003ia6ybpkiv3ncq"},{"post_id":"ck6q61bix0014a6yb17in9nac","tag_id":"ck6q61bjk003ga6ybunr0l2wy","_id":"ck6q61bjk003ja6yba1atpfoc"},{"post_id":"ck6q61biz0017a6ybenu5rvm4","tag_id":"ck6q61bjk003ha6yb8kewwvlu","_id":"ck6q61bjl003ma6ybw6z3itbq"},{"post_id":"ck6q61biz0017a6ybenu5rvm4","tag_id":"ck6q61bjk003ka6ybg5l9us7l","_id":"ck6q61bjl003na6ybxt9gjd5k"},{"post_id":"ck6q61bj0001ba6ybeva6hrl9","tag_id":"ck6q61bio000ja6ybdbhanogo","_id":"ck6q61bjl003oa6ybekl0zacr"},{"post_id":"ck6q61bj0001ba6ybeva6hrl9","tag_id":"ck6q61bjk003la6ybe78j3z3p","_id":"ck6q61bjl003pa6ybnzuu3z8i"},{"post_id":"ck6q61bjt003qa6ybhagsbxdb","tag_id":"ck6q61bjk003ha6yb8kewwvlu","_id":"ck6q61bjy0040a6ybvrj703rn"},{"post_id":"ck6q61bjt003qa6ybhagsbxdb","tag_id":"ck6q61bjv003ta6yb1esqyy0e","_id":"ck6q61bjz0042a6ybhki02dex"},{"post_id":"ck6q61bju003sa6yb7luw8v0a","tag_id":"ck6q61bjy003za6ybl4967b04","_id":"ck6q61bk00047a6yb3p29an5m"},{"post_id":"ck6q61bju003sa6yb7luw8v0a","tag_id":"ck6q61bjz0044a6ybdfs4y2ps","_id":"ck6q61bk00048a6ybp4lmb04i"},{"post_id":"ck6q61bjv003ua6ybc54rojzy","tag_id":"ck6q61bjh0031a6ybp02yvcay","_id":"ck6q61bk0004aa6ybm66uzkng"},{"post_id":"ck6q61bjv003ua6ybc54rojzy","tag_id":"ck6q61bjz0046a6yboxv2cua2","_id":"ck6q61bk0004ba6yb6max40bx"},{"post_id":"ck6q61bjw003va6ybnoh59c2f","tag_id":"ck6q61bk00049a6yb3fvi6h84","_id":"ck6q61bk1004ea6ybmke4gbbn"},{"post_id":"ck6q61bjw003va6ybnoh59c2f","tag_id":"ck6q61bk1004ca6ybdru10oie","_id":"ck6q61bk1004fa6ybd93t6der"},{"post_id":"ck6q61bjx003xa6ybjfgvguy3","tag_id":"ck6q61bjk003ha6yb8kewwvlu","_id":"ck6q61bk1004ga6ybdhorj1vq"},{"post_id":"ck6q61bjx003xa6ybjfgvguy3","tag_id":"ck6q61bk1004da6ybqbp7dusn","_id":"ck6q61bk1004ha6ybv4j93oob"},{"post_id":"ck6q61cna004ia6ybkwdzdhzi","tag_id":"ck6q61bj00018a6ybdb321ce7","_id":"ck6q61cne004ma6ybg0zjkfex"},{"post_id":"ck6q61cna004ia6ybkwdzdhzi","tag_id":"ck6q61cnc004ja6yby6hqhebo","_id":"ck6q61cnf004na6ybx4iecien"},{"post_id":"ck6q61cnn004oa6ybaoe058f8","tag_id":"ck6q61bio000ja6ybdbhanogo","_id":"ck6q61cnq004ua6yb3zuenjvp"},{"post_id":"ck6q61cnn004oa6ybaoe058f8","tag_id":"ck6q61cnp004qa6yb352rh2uu","_id":"ck6q61cnq004va6ybgbk9iu7f"},{"post_id":"ck6q61cno004pa6ybrotjuccn","tag_id":"ck6q61bjk003ha6yb8kewwvlu","_id":"ck6q61cnq004xa6ybk9zstbtj"},{"post_id":"ck6q61cno004pa6ybrotjuccn","tag_id":"ck6q61cnp004ta6yblttd278a","_id":"ck6q61cnq004za6ybqob5ls8l"},{"post_id":"ck6q61cym0050a6yb8w97o5r0","tag_id":"ck6q61cyn0051a6ybxbsygyrt","_id":"ck6q61cyn0053a6ybybw1e4ge"}],"Tag":[{"name":"数据结构","_id":"ck6q61bic0004a6ybksry934v"},{"name":"B+Tree","_id":"ck6q61big0009a6ybzmqyzxvc"},{"name":"高并发","_id":"ck6q61bio000ja6ybdbhanogo"},{"name":"ConcurrentHashMap","_id":"ck6q61bir000na6ybw0ccsdaa"},{"name":"HashMap","_id":"ck6q61biw0010a6yb5xqd4lwd"},{"name":"算法","_id":"ck6q61bj00018a6ybdb321ce7"},{"name":"链表逆序算法","_id":"ck6q61bj3001fa6ybuvpcsrro"},{"name":"AES算法","_id":"ck6q61bj6001qa6ybgwuwrcjs"},{"name":"MD5算法","_id":"ck6q61bja0020a6ybxpun9r7l"},{"name":"Google plugin","_id":"ck6q61bjc0024a6yb0ar2pd5e"},{"name":"Tampermonkey","_id":"ck6q61bjd002aa6yb35ryjacq"},{"name":"加密算法","_id":"ck6q61bje002ja6ybo0iuurqy"},{"name":"设计模式","_id":"ck6q61bjf002la6ybg4nkhgpg"},{"name":"factory","_id":"ck6q61bjf002oa6yb7ug6bd4q"},{"name":"CentOS","_id":"ck6q61bjf002pa6ybjdaq3knm"},{"name":"FireWall","_id":"ck6q61bjf002sa6ybaa78hj8u"},{"name":"macOS","_id":"ck6q61bjg002ta6ybx7ylbzp4"},{"name":"free apps","_id":"ck6q61bjg002wa6yb5qbwxnbo"},{"name":"Ghelper","_id":"ck6q61bjh0030a6ybvicwhhl7"},{"name":"version control","_id":"ck6q61bjh0031a6ybp02yvcay"},{"name":"maven","_id":"ck6q61bji0034a6ybi40d1onx"},{"name":"paid apps","_id":"ck6q61bji0038a6ybjf9t95an"},{"name":"singleton","_id":"ck6q61bjj003ca6ybedfwuvb9"},{"name":"Windows","_id":"ck6q61bjj003da6ybq7olgf40"},{"name":"activation","_id":"ck6q61bjk003ga6ybunr0l2wy"},{"name":"分布式","_id":"ck6q61bjk003ha6yb8kewwvlu"},{"name":"nginx","_id":"ck6q61bjk003ka6ybg5l9us7l"},{"name":"volatile","_id":"ck6q61bjk003la6ybe78j3z3p"},{"name":"消息队列","_id":"ck6q61bjv003ta6yb1esqyy0e"},{"name":"数据库","_id":"ck6q61bjy003za6ybl4967b04"},{"name":"Sub-table","_id":"ck6q61bjz0044a6ybdfs4y2ps"},{"name":"git","_id":"ck6q61bjz0046a6yboxv2cua2"},{"name":"web框架","_id":"ck6q61bk00049a6yb3fvi6h84"},{"name":"mybatis","_id":"ck6q61bk1004ca6ybdru10oie"},{"name":"zookeeper","_id":"ck6q61bk1004da6ybqbp7dusn"},{"name":"八大排序算法","_id":"ck6q61cnc004ja6yby6hqhebo"},{"name":"线程池","_id":"ck6q61cnp004qa6yb352rh2uu"},{"name":"redis","_id":"ck6q61cnp004ta6yblttd278a"},{"name":"develop frame summary","_id":"ck6q61cyn0051a6ybxbsygyrt"}]}}