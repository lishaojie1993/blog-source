---
title: AES对称加密算法
date: 2019-07-05 23:36:05
categories: 
  - Java
  - 算法
tags:
  - 算法
  - AES算法
top_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg
---

## AES算法的特点

AES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客[《MD5底层实现和解密方法》](http://www.lishaojie.top/2019/07/04/MD5/)所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。

### 密钥

密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用**同一个密钥**。AES支持三种长度的密钥：**128位，192位，256位**。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。

从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。

<!--more-->

### 填充

AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。

假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行**填充**（Padding）。

#### NoPadding

不做任何填充，但是要求明文必须是16字节的整数倍。

#### PKCS5Padding（默认）

如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。

比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}

#### ISO10126Padding

如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。

比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}

**注意：如果在AES加密时使用了某一种填充方式，解密的时候也必须采用同样的填充方式。**

### 模式

AES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。

#### ECB模式（默认）

电码本模式  Electronic Codebook Book

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazosrcxlxj30j60apdg3.jpg)

ECB模式是最简单的工作模式，在该模式下，每一个明文块的加密都是独立完成的，互不干涉。好处是简单，有利于并行计算。缺点也很明显，相同的明文块经过加密会变成相同的密文块，因此安全性较差。

#### CBC模式

密码分组链接模式  Cipher Block Chaining

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazou8zo61j30l40bcdgu.jpg)

CBC模式引入了一个新的概念：初始向量IV（Initialization Vector），它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它**前一个明文块所加密出的密文块**相异或。这样以来，相同的明文块加密出的密文块显然是不一样的。好处是安全性更好，缺点是无法并行计算，性能上不如ECB；引入初始化向量IV，增加复杂度。

#### CTR模式

计算器模式  Counter（实现省略……）

#### CFB模式

密码反馈模式  Cipher FeedBack（实现省略……）

#### OFB模式

输出反馈模式  Output FeedBack（实现省略……）

**注意：如果在AES加密时使用了某一种工作模式，解密的时候也必须采用同样的工作模式。**

在Java代码中，如何修改不同长度的密钥和填充模式？

AES算法在Java的 javax.crypto 包里有很好的封装，调用方式如下：

![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazo71c7glj30f90963zq.jpg)

1. kgen.init传入的第一个参数128决定了密钥的长度是**128bit**。
2. Cipher.getInstance("AES/CBC/NoPadding")决定了AES选择的填充方式是**NoPadding**，工作模式是**CBC**模式。

## 补充

1. 我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。
2. 填充明文时，如果明文长度原本就是16字节的整数倍，那么除了NoPadding以外，其他的填充方式都会填充一组额外的16字节明文块。

## AES加密算法底层原理

### AES加密步骤

1. 把明文按照128bit拆分成若干个明文块。
2. 按照选择的填充方式来填充最后一个明文块。
3. 每一个明文块利用AES加密器和密钥，加密成密文块。
4. 拼接所有的密文块，成为最终的密文结果。

### AES加密器需要经过多少轮加密

- 初始轮（Initial Round） 1次
- 普通轮（Rounds）     N次
- 最终轮（Final Round）  1次

上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。

### 除去初始轮各种Key长度对应的轮数

- AES128：10轮
- AES192：12轮
- AES256：14轮

### 不同阶段Round的处理步骤

**初始轮只有一个步骤**

- 加轮密钥（AddRoundKey）

**普通轮有四个步骤**

- 字节代替（SubBytes）

  首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为**S盒**（Subtitution Box）的16X16大小的二维常量数组。假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。

- 行移位（ShiftRows）

  这一步很简单，就像图中所描述的：第一行不变，第二行循环左移**1**个字节，第三行循环左移**2**个字节，第四行循环左移**3**个字节。

- 列混淆（MixColumns）

  这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。

- 加轮密钥（AddRoundKey）

  这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：**扩展密钥**（KeyExpansions）——AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。

**最终轮有三个步骤**

- 字节代替（SubBytes）
- 行移位（ShiftRows）
- 加轮密钥（AddRoundKey）

## AES解密流程

解密流程基本是把加密流程倒置过来，顺序变为 最终轮->普通轮->初始轮。扩展密钥的使用顺序也和加密相反。





