---
title: MD5加密的底层实现和破解方法
date: 2019-07-04 22:07:27
categories: 
  - Java
  - 算法
tags:
  - 算法
  - MD5算法
top_img: https://tva1.sinaimg.cn/large/006tNbRwgy1gash4k2x0uj31900u0b1g.jpg
---

## 信息摘要技术

信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。

MD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。

## 摘要哈希的生成过程

1. 收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。
2. 按照规则，把参数名和参数值拼接成一个字符串，同时把给定的**密钥**也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。
3. 利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。

<!--More-->

## 第三方支付平台验证签名

1. 发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。
2. 第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。
3. 用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做**验签**。

## MD5算法底层实现原理

简单概括起来，MD5算法的过程分为四步：

1. 处理原文

   首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512\*N+448。之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。

2. 设置初始值

   MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）：

   A=0x01234567

   B=0x89ABCDEF

   C=0xFEDCBA98

   D=0x76543210

3. 循环加工

   ![](https://tva1.sinaimg.cn/large/006tNbRwgy1gazpyfvzzgj309s0ae3yq.jpg)

   图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。假设处理后的原文长度是M，主循环次数 = **M / 512**，每个主循环中包含 **512 / 32 \* 4 = 64** 次 子循环。上面这张图所表达的就是**单次子循环**的流程。下面对图中其他元素一一解释：

   **1.绿色F**

   图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种：

   F(X, Y, Z) =(X&Y) | ((~X) & Z)

   G(X, Y, Z) =(X&Z) | (Y & (~Z))

   H(X, Y, Z) =X^Y^Z

   I(X, Y, Z)=Y^(X|(~Z))

   在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。

   **2.红色“田”字**

   很简单，红色的田字代表相加的意思。

   **3.Mi**

   Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0~M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1~M16之一。

   **4.Ki**

   一个常量，在64次子循环中，每一次用到的常量都是不同的。

   **5.黄色的<<**

   左移S位，S的值也是常量。

4. 拼接结果

   这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。

------

## MD5破解

这里要提一点，所谓的MD5破解，并非要把摘要还原成原文，而是通过[碰撞]生成同样的摘要。

MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，所以我们只需要碰撞出原文的哈希值即可欺骗过应用系统的验签。

### MD5碰撞方法

#### 暴力枚举法

顾名思义，就是简单粗暴的枚举出所有原文，并计算出它们的哈希值，看哪个哈希值和给定的信息摘要一致，这种方法虽简单，但是时间复杂度极高。不过优先尝试生日和有意义的单词可以缩小范围。

#### 字典法

如果说暴力枚举法是用时间换空间，那么字典法则就是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值，每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。不过这样虽然每次破解速度很快，但是生成字典所需要的空间极大。取巧的方式是优先存储常用的密码和摘要。

#### 彩虹表法

彩虹表法可以说是字典法的优化，它采用了一种有趣的数据结构：**彩虹表**。

彩虹表对哈希链进行了改进，把原先的R(X)函数改进成从R1(X)到Rk(X)，一共k个衰减函数。这样一来虽然可能发生碰撞，但是碰撞只会发生在同一级运算，大大减小了存储重复的几率。

#### 差分攻击

2009年，冯登国、谢涛利用差分攻击，将MD5的碰撞算法复杂度进一步降低，想了解的小伙伴可以自行查阅相关资料。

### 补充

对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。