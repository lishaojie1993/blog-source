<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李少杰のBlog</title>
  
  <subtitle>Do what you love,Love what you do</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lishaojie1993.github.io/"/>
  <updated>2020-02-17T07:56:54.817Z</updated>
  <id>https://lishaojie1993.github.io/</id>
  
  <author>
    <name>lishaojie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CentOS 7防火墙设置-iptables</title>
    <link href="https://lishaojie1993.github.io/2020/02/17/firewall/"/>
    <id>https://lishaojie1993.github.io/2020/02/17/firewall/</id>
    <published>2020-02-17T07:29:48.000Z</published>
    <updated>2020-02-17T07:56:54.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关闭默认防火墙"><a href="#关闭默认防火墙" class="headerlink" title="关闭默认防火墙"></a>关闭默认防火墙</h3><p>CentOS 7默认使用的防火墙是firewall，需要将其关闭</p><ul><li>systemctl stop firewalld.service #停止firewall</li><li>systemctl disable firewalld.service #禁止firewall开机启动</li></ul><h3 id="安装-iptables-service"><a href="#安装-iptables-service" class="headerlink" title="安装 iptables service"></a>安装 iptables service</h3><p>yum -y install iptables-services</p><h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>vi /etc/sysconfig/iptables <a id="more"></a></p><h3 id="在配置文件中增加规则"><a href="#在配置文件中增加规则" class="headerlink" title="在配置文件中增加规则"></a>在配置文件中增加规则</h3><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT</p><h3 id="保存退出，重启防火墙"><a href="#保存退出，重启防火墙" class="headerlink" title="保存退出，重启防火墙"></a>保存退出，重启防火墙</h3><ul><li>systemctl restart iptables.service #重启防火墙使配置生效</li><li>systemctl enable iptables.service #设置防火墙开机启动</li></ul><h3 id="iptables防火墙常用命令"><a href="#iptables防火墙常用命令" class="headerlink" title="iptables防火墙常用命令"></a>iptables防火墙常用命令</h3><ul><li>systemctl start iptables.service #打开防火墙</li><li>systemctl stop iptables.service #关闭防火墙</li><li>systemctl restart iptables.service #重启防火墙</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;关闭默认防火墙&quot;&gt;&lt;a href=&quot;#关闭默认防火墙&quot; class=&quot;headerlink&quot; title=&quot;关闭默认防火墙&quot;&gt;&lt;/a&gt;关闭默认防火墙&lt;/h3&gt;&lt;p&gt;CentOS 7默认使用的防火墙是firewall，需要将其关闭&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;systemctl stop firewalld.service #停止firewall&lt;/li&gt;
&lt;li&gt;systemctl disable firewalld.service #禁止firewall开机启动&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;安装-iptables-service&quot;&gt;&lt;a href=&quot;#安装-iptables-service&quot; class=&quot;headerlink&quot; title=&quot;安装 iptables service&quot;&gt;&lt;/a&gt;安装 iptables service&lt;/h3&gt;&lt;p&gt;yum -y install iptables-services&lt;/p&gt;
&lt;h3 id=&quot;编辑配置文件&quot;&gt;&lt;a href=&quot;#编辑配置文件&quot; class=&quot;headerlink&quot; title=&quot;编辑配置文件&quot;&gt;&lt;/a&gt;编辑配置文件&lt;/h3&gt;&lt;p&gt;vi /etc/sysconfig/iptables
    
    </summary>
    
    
      <category term="System" scheme="https://lishaojie1993.github.io/categories/System/"/>
    
    
      <category term="CentOS" scheme="https://lishaojie1993.github.io/tags/CentOS/"/>
    
      <category term="FireWall" scheme="https://lishaojie1993.github.io/tags/FireWall/"/>
    
  </entry>
  
  <entry>
    <title>神一样的存在,万能插件-Tampermonkey</title>
    <link href="https://lishaojie1993.github.io/2020/01/10/Tampermonkey/"/>
    <id>https://lishaojie1993.github.io/2020/01/10/Tampermonkey/</id>
    <published>2020-01-10T15:35:36.000Z</published>
    <updated>2020-01-12T09:03:20.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：<a href="http://www.lishaojie.top/2020/01/09/ghelper" target="_blank" rel="noopener">科学上网推荐,谷歌浏览器插件Ghelper</a>  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg" alt></p><a id="more"></a><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>说到这款插件就不得不说一个网址：<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">Greasy Fork</a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnhrmut5j316m0u0gye.jpg" alt></p><p>这个网站上可以搜索你想实现的任意功能，比如百度云盘下载不限速、优酷腾讯爱奇艺等各大视频网站的VIP破解、B站以及YouTube视频下载、智能划词翻译等等。该页面还记录了不同浏览器所支持的插件名称，详细介绍了用户脚本的安装和使用。</p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><p>根据你想要实现的功能直接在搜索框中搜索，根据安装量以及更新日期进行筛选，选择最佳的用户脚本安装使用，一般安装量很大并且更新时间较近的都没问题。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnt5lrbfj31030u0aji.jpg" alt></p><p>选中用户脚本点击进入，直接安装脚本即可使用，简单粗暴。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqny4zi10j31fo0gu782.jpg" alt></p><p>点击插件进入管理面板，可以直接对下载安装的用户脚本进行管理。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqnzslx0dj30m00fw0uf.jpg" alt></p><h2 id="脚本推荐"><a href="#脚本推荐" class="headerlink" title="脚本推荐"></a>脚本推荐</h2><p>管理面板页面如下所示，可以打开和关闭脚本功能，对脚本进行编辑和删除操作等等。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqo2lzm5uj32480huwj7.jpg" alt></p><p>我比较常用的是这几个，划词翻译真的很方便，下面分享几张使用截图。</p><p>划词翻译</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqbf4eyuj31fq0bogo9.jpg" alt></p><p>BiliBili会员站点解析</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqdpljsxj31yh0u07b0.jpg" alt></p><p>YouTube视频下载</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqqgr61xqj31850u04qp.jpg" alt></p><p>是不是感觉自己发现了新大陆，更多的功能等待你发掘，赶紧下载体验吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天要介绍的这个插件来头不小，分支也有很多，俗称“油猴”、“暴力猴”都是它，许多浏览器都支持这款插件，比如Chrome、FireFox、Safari、Microsoft Edge、UC……所以说它是万能的一点也不夸张，它拥有超过1000万的庞大用户群体，好评如潮！&lt;/p&gt;
&lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;p&gt;既然是插件，自然登陆谷歌应用商店就可以搜索下载了，登陆不上谷歌商店的，可以参考我的上一篇博客：&lt;a href=&quot;http://www.lishaojie.top/2020/01/09/ghelper&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;科学上网推荐,谷歌浏览器插件Ghelper&lt;/a&gt;  想免费体验的用户也可以通过火狐浏览器来安装Tampermonkey。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gaqn3buuvsj31uk0iggoo.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Google plugin" scheme="https://lishaojie1993.github.io/tags/Google-plugin/"/>
    
      <category term="Tampermonkey" scheme="https://lishaojie1993.github.io/tags/Tampermonkey/"/>
    
  </entry>
  
  <entry>
    <title>科学上网推荐,谷歌浏览器插件Ghelper</title>
    <link href="https://lishaojie1993.github.io/2020/01/09/ghelper/"/>
    <id>https://lishaojie1993.github.io/2020/01/09/ghelper/</id>
    <published>2020-01-09T14:18:05.000Z</published>
    <updated>2020-01-12T09:06:58.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg" alt></p><a id="more"></a><p>不能打开谷歌应用商店的小伙伴可以在网上随便找个免费的翻墙软件试用一下，蓝灯或者SSR机场都可以，这里推荐一个免费的网站，速度慢些 <a href="https://usky.ml/tool/free_ssr" target="_blank" rel="noopener">SSR工具</a></p><p>把Ghelper插件添加到Chrome浏览器，免费试用3天，由于网速受地域的影响，这期间正好可以测试下你的网络环境适不适合购买这款插件。</p><h2 id="插件介绍"><a href="#插件介绍" class="headerlink" title="插件介绍"></a>插件介绍</h2><p>安装成功后就是下图的样子，简洁的外观，不需要繁杂的设置，快速上手。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqkuh644nj30uk0lcwh2.jpg" alt></p><p>点击Settings，设置页面显示如下，标志1显示的是到期时间，标志2是你的账户，标志3是用户等级，这里要说明一下，只有VIP达到3级以后才能使用手机代理，等级在1，2级时侧栏的手机代理V2是不显示的，不过个人感觉手机翻墙没啥用。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqlos1mdkj31vw0u0dmv.jpg" alt></p><h2 id="资费详情"><a href="#资费详情" class="headerlink" title="资费详情"></a>资费详情</h2><p>介绍一下费用情况，一个月是15.99元，一次性购买3个月可以直达VIP3，享受手机代理服务，选择套餐后直接跳转到支付宝扫码付款页面，即时生效。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmpb00pzj30um0ec75z.jpg" alt></p><h2 id="手机代理"><a href="#手机代理" class="headerlink" title="手机代理"></a>手机代理</h2><p>页面中提供代理软件下载，点击二维码扫描添加到手机代理中即可翻墙。其他的设置我没有修改，感兴趣的小伙伴可以自行下载体验。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmnnv0fbj31pp0u0n7r.jpg" alt></p><h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2><p>YouTube可以秒开，播放很少有卡顿现象，如果本身网络环境比较好的情况下，上网速度还是很理想的，这里不鼓励大家购买，凡事都要根据自己的需求来判断，以保证物有所值！</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaqm8jedszj31lk0u0b2a.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;今天给大家推荐一款科学上网的插件——Ghelper。网上免费的翻墙软件也不少，不过免费的要么速度慢，要么用不了两天就被封，所以我就想寻求一条性价比高的科学上网途径。几经周折，最后选择了这款Google的插件。（据说前段时间搬瓦工出了一款自家的梯子，性价比也还可以，感兴趣的小伙伴可以自己钻研下，这里不再赘述）&lt;/p&gt;
&lt;h2 id=&quot;下载安装&quot;&gt;&lt;a href=&quot;#下载安装&quot; class=&quot;headerlink&quot; title=&quot;下载安装&quot;&gt;&lt;/a&gt;下载安装&lt;/h2&gt;&lt;p&gt;直接到谷歌应用商店搜索下载就可以了，中文名“谷歌上网助手”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gaqmkm9l01j31na0u0gpu.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Google plugin" scheme="https://lishaojie1993.github.io/tags/Google-plugin/"/>
    
      <category term="Ghelper" scheme="https://lishaojie1993.github.io/tags/Ghelper/"/>
    
  </entry>
  
  <entry>
    <title>macOS 超实用的「付费」软件推荐,分享一波福利！</title>
    <link href="https://lishaojie1993.github.io/2020/01/08/macapp/"/>
    <id>https://lishaojie1993.github.io/2020/01/08/macapp/</id>
    <published>2020-01-08T03:17:15.000Z</published>
    <updated>2020-01-13T03:46:12.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Alfred-4"><a href="#Alfred-4" class="headerlink" title="Alfred 4"></a>Alfred 4</h2><p>版本号: 4.0.6</p><p>功能介绍: <a href="https://www.alfredapp.com/whats-new/" target="_blank" rel="noopener">https://www.alfredapp.com/whats-new/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA" target="_blank" rel="noopener">https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA</a>  密码:9onb</p><p>推荐指数: ★★★★★</p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8z0whdj31a70u0q6x.jpg" alt></p><h2 id="CleanMyMac-X"><a href="#CleanMyMac-X" class="headerlink" title="CleanMyMac X"></a>CleanMyMac X</h2><p>版本号: 4.4.6</p><p>功能介绍: <a href="https://macpaw.com/cleanmymac" target="_blank" rel="noopener">https://macpaw.com/cleanmymac</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA" target="_blank" rel="noopener">https://pan.baidu.com/s/1mdJj0Oe8J9k-lVnDnosXmA</a>  密码:mslx</p><p>推荐指数: ★★★★☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8yp8etj31e80u0go2.jpg" alt></p><h2 id="Movist-Pro"><a href="#Movist-Pro" class="headerlink" title="Movist Pro"></a>Movist Pro</h2><p>版本号: 2.2.13</p><p>功能介绍: <a href="https://movistprime.com/" target="_blank" rel="noopener">https://movistprime.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg" target="_blank" rel="noopener">https://pan.baidu.com/s/1_rzNpIpagPjx0Ujfv_6elg</a>  密码:8ocb</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xhyx8j30rs0frabv.jpg" alt></p><h2 id="Final-Cut-Pro-X"><a href="#Final-Cut-Pro-X" class="headerlink" title="Final Cut Pro X"></a>Final Cut Pro X</h2><p>版本号: 10.4.5</p><p>功能介绍: <a href="https://www.apple.com/final-cut-pro/" target="_blank" rel="noopener">https://www.apple.com/final-cut-pro/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ" target="_blank" rel="noopener">https://pan.baidu.com/s/10IygIIYxOlR4MvW1-mZSvQ</a>  密码:wqdk</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y1fq5j31gs0u0jti.jpg" alt></p><h2 id="Compressor"><a href="#Compressor" class="headerlink" title="Compressor"></a>Compressor</h2><p>版本号: 4.4.3</p><p>功能介绍: <a href="https://www.apple.com.cn/cn/final-cut-pro/compressor/" target="_blank" rel="noopener">https://www.apple.com.cn/cn/final-cut-pro/compressor/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA" target="_blank" rel="noopener">https://pan.baidu.com/s/1KGLWhkaMMh88ZTQj-PlsvA</a>  密码:8mng</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gauscey8r0j319x0u0gnq.jpg" alt></p><h2 id="iStat-Menus-6"><a href="#iStat-Menus-6" class="headerlink" title="iStat Menus 6"></a>iStat Menus 6</h2><p>版本号: 6.31</p><p>功能介绍: <a href="https://bjango.com/mac/istatmenus/" target="_blank" rel="noopener">https://bjango.com/mac/istatmenus/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1k21TzILoPb8Nf7e13phZYQ</a>  密码:r8yx</p><p>推荐指数: ★★★★☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8xrx3hj319e0u0tca.jpg" alt></p><h2 id="Parallels-Desktop-15"><a href="#Parallels-Desktop-15" class="headerlink" title="Parallels Desktop 15"></a>Parallels Desktop 15</h2><p>版本号: 15.1.2</p><p>功能介绍: <a href="https://www.parallels.com/cn/landingpage/pd/general/" target="_blank" rel="noopener">https://www.parallels.com/cn/landingpage/pd/general/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA" target="_blank" rel="noopener">https://pan.baidu.com/s/1dN1pGkpkJ-6Zh9WDoNEAzA</a>  密码:xfxi</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wjkifj319y0u00u6.jpg" alt></p><h2 id="XMind-8-Pro"><a href="#XMind-8-Pro" class="headerlink" title="XMind 8 Pro"></a>XMind 8 Pro</h2><p>版本号: 3.7.7</p><p>功能介绍: <a href="https://www.xmind.cn/xmind8-pro/" target="_blank" rel="noopener">https://www.xmind.cn/xmind8-pro/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA" target="_blank" rel="noopener">https://pan.baidu.com/s/1tmONGIw7b9rdsVfG_BZ6IA</a>  密码:3dio</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vmmwaj31cv0u0wfn.jpg" alt></p><h2 id="PDF-Expert"><a href="#PDF-Expert" class="headerlink" title="PDF Expert"></a>PDF Expert</h2><p>版本号: 2.4.23</p><p>功能介绍: <a href="https://pdfexpert.com/" target="_blank" rel="noopener">https://pdfexpert.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow" target="_blank" rel="noopener">https://pan.baidu.com/s/1DosmAW1sBTe3cY_EAUPlow</a>  密码:gkyo</p><p>推荐指数: ★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8w7qu7j31g20u0myq.jpg" alt></p><h2 id="Things-3"><a href="#Things-3" class="headerlink" title="Things 3"></a>Things 3</h2><p>版本号: 3.11</p><p>功能介绍: <a href="https://culturedcode.com/things/" target="_blank" rel="noopener">https://culturedcode.com/things/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1HdREFywypYxU_2fa-cSJrQ</a>  密码:ddv6</p><p>推荐指数: ★★★☆☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8vwlmgj311q0u0js9.jpg" alt></p><h2 id="Downie-3"><a href="#Downie-3" class="headerlink" title="Downie 3"></a>Downie 3</h2><p>版本号: 3.9.4</p><p>功能介绍: <a href="https://software.charliemonroe.net/downie/" target="_blank" rel="noopener">https://software.charliemonroe.net/downie/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA" target="_blank" rel="noopener">https://pan.baidu.com/s/1qQ8GY0wwAXeLXzNX6zBttA</a>  密码:cqma</p><p>推荐指数: ★★★★☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8y7letj31ck0l0mxq.jpg" alt></p><h2 id="Paste"><a href="#Paste" class="headerlink" title="Paste"></a>Paste</h2><p>版本号: 2.4.4</p><p>功能介绍: <a href="https://pasteapp.me/" target="_blank" rel="noopener">https://pasteapp.me/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g" target="_blank" rel="noopener">https://pan.baidu.com/s/17dRY_Gggz9wQFwBIQMgq3g</a>  密码:4bxn</p><p>推荐指数: ★★★★☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8wqkbxj30vk0mu3zl.jpg" alt></p><h2 id="Bartender-3"><a href="#Bartender-3" class="headerlink" title="Bartender 3"></a>Bartender 3</h2><p>版本号: 3.1.1</p><p>功能介绍: <a href="https://www.macbartender.com/" target="_blank" rel="noopener">https://www.macbartender.com/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1ce2WSPPNUWxDgsds-vnB4Q</a>  密码:b00n</p><p>推荐指数: ★★★☆☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxotf6egj30q106wgmk.jpg" alt></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxpip1rej30q106wgm1.jpg" alt></p><h2 id="MWeb"><a href="#MWeb" class="headerlink" title="MWeb"></a>MWeb</h2><p>版本号: 3.2.2</p><p>功能介绍: <a href="https://zh.mweb.im/" target="_blank" rel="noopener">https://zh.mweb.im/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw" target="_blank" rel="noopener">https://pan.baidu.com/s/1kxXwDUUEdGbn69eaRm7uzw</a>  密码:87dx</p><p>推荐指数: ★★★☆☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaus8x805fj31fl0u0juk.jpg" alt></p><h2 id="Smooze"><a href="#Smooze" class="headerlink" title="Smooze"></a>Smooze</h2><p>版本号: 1.8.6</p><p>功能介绍: <a href="https://smooze.co/" target="_blank" rel="noopener">https://smooze.co/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw" target="_blank" rel="noopener">https://pan.baidu.com/s/1IVfZfsajy_GKDx7svdZNjw</a>  密码:upjo</p><p>推荐指数: ★★☆☆☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoxu7eqksj31el0u0x6p.jpg" alt></p><h2 id="Keka"><a href="#Keka" class="headerlink" title="Keka"></a>Keka</h2><p>版本号: 1.1.5</p><p>功能介绍: <a href="https://www.keka.io/en/" target="_blank" rel="noopener">https://www.keka.io/en/</a></p><p>破解版下载链接:<a href="https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1AtKKfJ7ipGGhQ0jXGMD8IQ</a>  密码:7sdf</p><p>推荐指数: ★★★☆☆</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaoy9qvhhfj30jo0oa43j.jpg" alt></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>正版软件比破解版更稳定,且可以享受持续更新,在资金能力允许的范围内,呼吁大家支持正版!</p><p>本站所有软件仅供学习使用,请在24小时内删除,本人不承担任何相关责任!</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Alfred-4&quot;&gt;&lt;a href=&quot;#Alfred-4&quot; class=&quot;headerlink&quot; title=&quot;Alfred 4&quot;&gt;&lt;/a&gt;Alfred 4&lt;/h2&gt;&lt;p&gt;版本号: 4.0.6&lt;/p&gt;
&lt;p&gt;功能介绍: &lt;a href=&quot;https://www.alfredapp.com/whats-new/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.alfredapp.com/whats-new/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;破解版下载链接:&lt;a href=&quot;https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.com/s/1fpewIqFp0-JF3lpaJtcHHA&lt;/a&gt;  密码:9onb&lt;/p&gt;
&lt;p&gt;推荐指数: ★★★★★&lt;/p&gt;
    
    </summary>
    
    
      <category term="System" scheme="https://lishaojie1993.github.io/categories/System/"/>
    
    
      <category term="macOS" scheme="https://lishaojie1993.github.io/tags/macOS/"/>
    
      <category term="paid apps" scheme="https://lishaojie1993.github.io/tags/paid-apps/"/>
    
  </entry>
  
  <entry>
    <title>macOS 超实用的「免费」软件推荐,使用经验分享！</title>
    <link href="https://lishaojie1993.github.io/2020/01/06/macappfree/"/>
    <id>https://lishaojie1993.github.io/2020/01/06/macappfree/</id>
    <published>2020-01-06T14:34:14.000Z</published>
    <updated>2020-01-13T02:30:21.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h2><p>概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它</p><p>功能介绍：<a href="https://iterm2.com/features.html" target="_blank" rel="noopener">https://iterm2.com/features.html</a></p><p>官方下载地址：<a href="https://iterm2.com/downloads.html" target="_blank" rel="noopener">https://iterm2.com/downloads.html</a></p><p>推荐指数：★★★★★</p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapj5io7l5j30wo0oqtxl.jpg" alt></p><h2 id="IINA"><a href="#IINA" class="headerlink" title="IINA"></a>IINA</h2><p>概括：强大的本地视频播放器，解析能力稍逊于Movist Pro，优点是启动快</p><p>功能介绍：<a href="https://zhuanlan.zhihu.com/p/24700324" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24700324</a></p><p>官方下载地址：<a href="https://iina.io/" target="_blank" rel="noopener">https://iina.io/</a></p><p>推荐指数：★★★★☆（Movist Pro 是满分😄）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjhaq2s3j31100n87wh.jpg" alt></p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>概括：支持实时预览的Markdown文本编辑器</p><p>功能介绍：<a href="https://sspai.com/post/54912" target="_blank" rel="noopener">https://sspai.com/post/54912</a></p><p>官方下载地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p><p>推荐指数：★★★★★（我的博文都是用Typora编辑的，功不可没，必须满分💯）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjq9ocukj31140u07wh.jpg" alt></p><h2 id="iPic"><a href="#iPic" class="headerlink" title="iPic"></a>iPic</h2><p>概括：Markdown 图床、文件上传工具，免费版足够用</p><p>功能介绍：<a href="https://toolinbox.net/iPic/" target="_blank" rel="noopener">https://toolinbox.net/iPic/</a></p><p>官方下载地址：已经上架 App Store，搜索下载即可</p><p>推荐指数：★★★★★（博文中使用到的图片都是通过 iPic 实现加载的）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapkz2l0nbj30kr0eswxg.jpg" alt></p><h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>概括：简称 VS Code，非常强大的代码文本编辑器，支持大量插件</p><p>功能介绍：<a href="https://www.cnblogs.com/clwydjgs/p/10078065.html" target="_blank" rel="noopener">https://www.cnblogs.com/clwydjgs/p/10078065.html</a></p><p>官方下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></p><p>推荐指数：★★★★★（相较于 Sublime Text 来说，我更倾向于 VS Code）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapjujriamj315s0u0qte.jpg" alt></p><h2 id="Better-And-Better"><a href="#Better-And-Better" class="headerlink" title="Better And Better"></a>Better And Better</h2><p>概括：简称BAB，这是一款非常全能的软件，有了它基本可以替代一堆应用</p><p>功能介绍：<a href="https://www.better365.cn/tv.html" target="_blank" rel="noopener">https://www.better365.cn/tv.html</a></p><p>官方下载地址：<a href="https://www.better365.cn/bab.html" target="_blank" rel="noopener">https://www.better365.cn/bab.html</a></p><p>推荐指数：★★★☆☆（偶尔有软件冲突，导致系统运行缓慢）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapk8a5vs6j31450u07wh.jpg" alt></p><h2 id="iShot"><a href="#iShot" class="headerlink" title="iShot"></a>iShot</h2><p>概括：强大的截图工具，与BAB同属一个开发团队，旗下还有Better Menubar和自动切换输入法</p><p>功能介绍：<a href="https://sspai.com/post/57302" target="_blank" rel="noopener">https://sspai.com/post/57302</a></p><p>官方下载地址：已经上架 App Store，搜索下载即可</p><p>推荐指数：★★★★★（支持截图和录屏，使用下来个人觉得要优于Xnip和Snip）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapk4hc4b2j30u00vbb1l.jpg" alt></p><h2 id="Final-Shell"><a href="#Final-Shell" class="headerlink" title="Final Shell"></a>Final Shell</h2><p>概括：Mac上的 shell 工具，用于连接远程服务器，支持sftp</p><p>功能介绍：<a href="https://blog.csdn.net/sinat_25838589/article/details/79781241" target="_blank" rel="noopener">https://blog.csdn.net/sinat_25838589/article/details/79781241</a></p><p>官方下载地址：<a href="http://www.hostbuf.com/t/988.html" target="_blank" rel="noopener">http://www.hostbuf.com/t/988.html</a></p><p>推荐指数：★★★★★</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gapkzesnj7j30w40sswi2.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;iTerm2&quot;&gt;&lt;a href=&quot;#iTerm2&quot; class=&quot;headerlink&quot; title=&quot;iTerm2&quot;&gt;&lt;/a&gt;iTerm2&lt;/h2&gt;&lt;p&gt;概括：非常强大的终端工具，虽然Mac自带的终端已足够好用，也不妨碍推荐它&lt;/p&gt;
&lt;p&gt;功能介绍：&lt;a href=&quot;https://iterm2.com/features.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://iterm2.com/features.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方下载地址：&lt;a href=&quot;https://iterm2.com/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://iterm2.com/downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;推荐指数：★★★★★&lt;/p&gt;
    
    </summary>
    
    
      <category term="System" scheme="https://lishaojie1993.github.io/categories/System/"/>
    
    
      <category term="macOS" scheme="https://lishaojie1993.github.io/tags/macOS/"/>
    
      <category term="free apps" scheme="https://lishaojie1993.github.io/tags/free-apps/"/>
    
  </entry>
  
  <entry>
    <title>AES对称加密算法</title>
    <link href="https://lishaojie1993.github.io/2019/07/05/AES/"/>
    <id>https://lishaojie1993.github.io/2019/07/05/AES/</id>
    <published>2019-07-05T15:36:05.000Z</published>
    <updated>2020-01-17T09:49:24.465Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AES算法的特点"><a href="#AES算法的特点" class="headerlink" title="AES算法的特点"></a>AES算法的特点</h2><p>AES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客<a href="http://www.lishaojie.top/2019/07/04/MD5/" target="_blank" rel="noopener">《MD5底层实现和解密方法》</a>所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。</p><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用<strong>同一个密钥</strong>。AES支持三种长度的密钥：<strong>128位，192位，256位</strong>。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。</p><p>从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。</p><a id="more"></a><h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>AES算法在对明文加密的时候，并不是把整个明文一股脑加密成一整段密文，而是把明文拆分成一个个独立的明文块，每一个明文块长度128bit。这些明文块经过AES加密器的复杂处理，生成一个个独立的密文块，这些密文块拼接在一起，就是最终的AES加密结果。</p><p>假如一段明文长度是192bit，如果按每128bit一个明文块来拆分的话，第二个明文块只有64bit，不足128bit。这时候怎么办呢？就需要对明文块进行<strong>填充</strong>（Padding）。</p><h4 id="NoPadding"><a href="#NoPadding" class="headerlink" title="NoPadding"></a>NoPadding</h4><p>不做任何填充，但是要求明文必须是16字节的整数倍。</p><h4 id="PKCS5Padding（默认）"><a href="#PKCS5Padding（默认）" class="headerlink" title="PKCS5Padding（默认）"></a>PKCS5Padding（默认）</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字符，且每个字节的值等于缺少的字符数。</p><p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则补全为{1,2,3,4,5,a,b,c,d,e,6,6,6,6,6,6}</p><h4 id="ISO10126Padding"><a href="#ISO10126Padding" class="headerlink" title="ISO10126Padding"></a>ISO10126Padding</h4><p>如果明文块少于16个字节（128bit），在明文块末尾补足相应数量的字节，最后一个字符值等于缺少的字符数，其他字符填充随机数。</p><p>比如明文：{1,2,3,4,5,a,b,c,d,e},缺少6个字节，则可能补全为{1,2,3,4,5,a,b,c,d,e,5,c,3,G,$,6}</p><p><strong>注意：如果在AES加密时使用了某一种填充方式，解密的时候也必须采用同样的填充方式。</strong></p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>AES的工作模式，体现在把明文块加密成密文块的处理过程中。AES加密算法提供了五种不同的工作模式：ECB、CBC、CTR、CFB、OFB，模式之间的主题思想是近似的，在处理细节上有一些差别。</p><h4 id="ECB模式（默认）"><a href="#ECB模式（默认）" class="headerlink" title="ECB模式（默认）"></a>ECB模式（默认）</h4><p>电码本模式  Electronic Codebook Book</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazosrcxlxj30j60apdg3.jpg" alt></p><p>ECB模式是最简单的工作模式，在该模式下，每一个明文块的加密都是独立完成的，互不干涉。好处是简单，有利于并行计算。缺点也很明显，相同的明文块经过加密会变成相同的密文块，因此安全性较差。</p><h4 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h4><p>密码分组链接模式  Cipher Block Chaining</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazou8zo61j30l40bcdgu.jpg" alt></p><p>CBC模式引入了一个新的概念：初始向量IV（Initialization Vector），它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它<strong>前一个明文块所加密出的密文块</strong>相异或。这样以来，相同的明文块加密出的密文块显然是不一样的。好处是安全性更好，缺点是无法并行计算，性能上不如ECB；引入初始化向量IV，增加复杂度。</p><h4 id="CTR模式"><a href="#CTR模式" class="headerlink" title="CTR模式"></a>CTR模式</h4><p>计算器模式  Counter（实现省略……）</p><h4 id="CFB模式"><a href="#CFB模式" class="headerlink" title="CFB模式"></a>CFB模式</h4><p>密码反馈模式  Cipher FeedBack（实现省略……）</p><h4 id="OFB模式"><a href="#OFB模式" class="headerlink" title="OFB模式"></a>OFB模式</h4><p>输出反馈模式  Output FeedBack（实现省略……）</p><p><strong>注意：如果在AES加密时使用了某一种工作模式，解密的时候也必须采用同样的工作模式。</strong></p><p>在Java代码中，如何修改不同长度的密钥和填充模式？</p><p>AES算法在Java的 javax.crypto 包里有很好的封装，调用方式如下：</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazo71c7glj30f90963zq.jpg" alt></p><ol><li>kgen.init传入的第一个参数128决定了密钥的长度是<strong>128bit</strong>。</li><li>Cipher.getInstance(“AES/CBC/NoPadding”)决定了AES选择的填充方式是<strong>NoPadding</strong>，工作模式是<strong>CBC</strong>模式。</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li>我们在调用封装好的AES算法时，表面上使用的Key并不是真正用于AES加密解密的密钥，而是用于生成真正密钥的“种子”。</li><li>填充明文时，如果明文长度原本就是16字节的整数倍，那么除了NoPadding以外，其他的填充方式都会填充一组额外的16字节明文块。</li></ol><h2 id="AES加密算法底层原理"><a href="#AES加密算法底层原理" class="headerlink" title="AES加密算法底层原理"></a>AES加密算法底层原理</h2><h3 id="AES加密步骤"><a href="#AES加密步骤" class="headerlink" title="AES加密步骤"></a>AES加密步骤</h3><ol><li>把明文按照128bit拆分成若干个明文块。</li><li>按照选择的填充方式来填充最后一个明文块。</li><li>每一个明文块利用AES加密器和密钥，加密成密文块。</li><li>拼接所有的密文块，成为最终的密文结果。</li></ol><h3 id="AES加密器需要经过多少轮加密"><a href="#AES加密器需要经过多少轮加密" class="headerlink" title="AES加密器需要经过多少轮加密"></a>AES加密器需要经过多少轮加密</h3><ul><li>初始轮（Initial Round） 1次</li><li>普通轮（Rounds）     N次</li><li>最终轮（Final Round）  1次</li></ul><p>上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。</p><h3 id="除去初始轮各种Key长度对应的轮数"><a href="#除去初始轮各种Key长度对应的轮数" class="headerlink" title="除去初始轮各种Key长度对应的轮数"></a>除去初始轮各种Key长度对应的轮数</h3><ul><li>AES128：10轮</li><li>AES192：12轮</li><li>AES256：14轮</li></ul><h3 id="不同阶段Round的处理步骤"><a href="#不同阶段Round的处理步骤" class="headerlink" title="不同阶段Round的处理步骤"></a>不同阶段Round的处理步骤</h3><p><strong>初始轮只有一个步骤</strong></p><ul><li>加轮密钥（AddRoundKey）</li></ul><p><strong>普通轮有四个步骤</strong></p><ul><li><p>字节代替（SubBytes）</p><p>首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为<strong>S盒</strong>（Subtitution Box）的16X16大小的二维常量数组。假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。</p></li><li><p>行移位（ShiftRows）</p><p>这一步很简单，就像图中所描述的：第一行不变，第二行循环左移<strong>1</strong>个字节，第三行循环左移<strong>2</strong>个字节，第四行循环左移<strong>3</strong>个字节。</p></li><li><p>列混淆（MixColumns）</p><p>这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。</p></li><li><p>加轮密钥（AddRoundKey）</p><p>这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：<strong>扩展密钥</strong>（KeyExpansions）——AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ……一直到W{160-175}用于最终轮（第10轮）的处理。</p></li></ul><p><strong>最终轮有三个步骤</strong></p><ul><li>字节代替（SubBytes）</li><li>行移位（ShiftRows）</li><li>加轮密钥（AddRoundKey）</li></ul><h2 id="AES解密流程"><a href="#AES解密流程" class="headerlink" title="AES解密流程"></a>AES解密流程</h2><p>解密流程基本是把加密流程倒置过来，顺序变为 最终轮-&gt;普通轮-&gt;初始轮。扩展密钥的使用顺序也和加密相反。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AES算法的特点&quot;&gt;&lt;a href=&quot;#AES算法的特点&quot; class=&quot;headerlink&quot; title=&quot;AES算法的特点&quot;&gt;&lt;/a&gt;AES算法的特点&lt;/h2&gt;&lt;p&gt;AES算法（Advanced Encryption Standard）是DES算法的替代者，也是当今最流行的对称加密算法之一。跟上篇博客&lt;a href=&quot;http://www.lishaojie.top/2019/07/04/MD5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《MD5底层实现和解密方法》&lt;/a&gt;所提到的摘要算法不同，摘要算法是不可逆的，主要作用是对信息一致性和完整性的校验。而对称加密算法是可逆的，它的主要作用是保证私密信息不被泄露。&lt;/p&gt;
&lt;h3 id=&quot;密钥&quot;&gt;&lt;a href=&quot;#密钥&quot; class=&quot;headerlink&quot; title=&quot;密钥&quot;&gt;&lt;/a&gt;密钥&lt;/h3&gt;&lt;p&gt;密钥是AES算法实现加密和解密的根本。对称加密算法之所以对称，是因为这类算法对明文的加密和解密需要使用&lt;strong&gt;同一个密钥&lt;/strong&gt;。AES支持三种长度的密钥：&lt;strong&gt;128位，192位，256位&lt;/strong&gt;。平时大家所说的AES128，AES192，AES256，实际上就是指的AES算法对不同长度密钥的使用。&lt;/p&gt;
&lt;p&gt;从安全性来看，AES256安全性最高；从性能来看，AES128性能最高；因为加密处理轮数不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
      <category term="算法" scheme="https://lishaojie1993.github.io/categories/Java/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lishaojie1993.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="AES算法" scheme="https://lishaojie1993.github.io/tags/AES%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MD5加密的底层实现和破解方法</title>
    <link href="https://lishaojie1993.github.io/2019/07/04/MD5/"/>
    <id>https://lishaojie1993.github.io/2019/07/04/MD5/</id>
    <published>2019-07-04T14:07:27.000Z</published>
    <updated>2020-01-17T10:15:37.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息摘要技术"><a href="#信息摘要技术" class="headerlink" title="信息摘要技术"></a>信息摘要技术</h2><p>信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。</p><p>MD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。</p><h2 id="摘要哈希的生成过程"><a href="#摘要哈希的生成过程" class="headerlink" title="摘要哈希的生成过程"></a>摘要哈希的生成过程</h2><ol><li>收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。</li><li>按照规则，把参数名和参数值拼接成一个字符串，同时把给定的<strong>密钥</strong>也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。</li><li>利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。</li></ol><a id="more"></a><h2 id="第三方支付平台验证签名"><a href="#第三方支付平台验证签名" class="headerlink" title="第三方支付平台验证签名"></a>第三方支付平台验证签名</h2><ol><li>发送方和请求方约定相同的字符串拼接规则，约定相同的密钥。</li><li>第三方平台接到支付请求，按规则拼接业务参数和密钥，利用MD5算法生成Sign。</li><li>用第三方平台自己生成的Sign和请求发送过来的Sign做对比，如果两个Sign值一模一样，则签名无误，如果两个Sign值不同，则信息做了篡改。这个过程叫做<strong>验签</strong>。</li></ol><h2 id="MD5算法底层实现原理"><a href="#MD5算法底层实现原理" class="headerlink" title="MD5算法底层实现原理"></a>MD5算法底层实现原理</h2><p>简单概括起来，MD5算法的过程分为四步：</p><ol><li><p>处理原文</p><p>首先，我们计算出原文长度(bit)对512求余的结果，如果不等于448，就需要填充原文使得原文对512求余的结果等于448。填充的方法是第一位填充1，其余位填充0。填充完后，信息的长度就是512*N+448。之后，用剩余的位置（512-448=64位）记录原文的真正长度，把长度的二进制值补在最后。这样处理后的信息长度就是512*(N+1)。</p></li><li><p>设置初始值</p><p>MD5的哈希结果长度为128位，按每32位分成一组共4组。这4组结果是由4个初始值A、B、C、D经过不断演变得到。MD5的官方实现中，A、B、C、D的初始值如下（16进制）：</p><p>A=0x01234567</p><p>B=0x89ABCDEF</p><p>C=0xFEDCBA98</p><p>D=0x76543210</p></li><li><p>循环加工</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazpyfvzzgj309s0ae3yq.jpg" alt></p><p>图中，A，B，C，D就是哈希值的四个分组。每一次循环都会让旧的ABCD产生新的ABCD。一共进行多少次循环呢？由处理后的原文长度决定。假设处理后的原文长度是M，主循环次数 = <strong>M / 512</strong>，每个主循环中包含 <strong>512 / 32 * 4 = 64</strong> 次 子循环。上面这张图所表达的就是<strong>单次子循环</strong>的流程。下面对图中其他元素一一解释：</p><p><strong>1.绿色F</strong></p><p>图中的绿色F，代表非线性函数。官方MD5所用到的函数有四种：</p><p>F(X, Y, Z) =(X&amp;Y) | ((~X) &amp; Z)</p><p>G(X, Y, Z) =(X&amp;Z) | (Y &amp; (~Z))</p><p>H(X, Y, Z) =X^Y^Z</p><p>I(X, Y, Z)=Y^(X|(~Z))</p><p>在主循环下面64次子循环中，F、G、H、I 交替使用，第一个16次使用F，第二个16次使用G，第三个16次使用H，第四个16次使用I。</p><p><strong>2.红色“田”字</strong></p><p>很简单，红色的田字代表相加的意思。</p><p><strong>3.Mi</strong></p><p>Mi是第一步处理后的原文。在第一步中，处理后原文的长度是512的整数倍。把原文的每512位再分成16等份，命名为M0<del>M15，每一等份长度32。在64次子循环中，每16次循环，都会交替用到M1</del>M16之一。</p><p><strong>4.Ki</strong></p><p>一个常量，在64次子循环中，每一次用到的常量都是不同的。</p><p><strong>5.黄色的&lt;&lt;</strong></p><p>左移S位，S的值也是常量。</p></li><li><p>拼接结果</p><p>这一步就很简单了，把循环加工最终产生的A，B，C，D四个值拼接在一起，转换成字符串即可。</p></li></ol><hr><h2 id="MD5破解"><a href="#MD5破解" class="headerlink" title="MD5破解"></a>MD5破解</h2><p>这里要提一点，所谓的MD5破解，并非要把摘要还原成原文，而是通过[碰撞]生成同样的摘要。</p><p>MD5碰撞通常用于登陆密码的破解。应用系统的数据库中存储的用户密码通常都是原密码的MD5哈希值，所以我们只需要碰撞出原文的哈希值即可欺骗过应用系统的验签。</p><h3 id="MD5碰撞方法"><a href="#MD5碰撞方法" class="headerlink" title="MD5碰撞方法"></a>MD5碰撞方法</h3><h4 id="暴力枚举法"><a href="#暴力枚举法" class="headerlink" title="暴力枚举法"></a>暴力枚举法</h4><p>顾名思义，就是简单粗暴的枚举出所有原文，并计算出它们的哈希值，看哪个哈希值和给定的信息摘要一致，这种方法虽简单，但是时间复杂度极高。不过优先尝试生日和有意义的单词可以缩小范围。</p><h4 id="字典法"><a href="#字典法" class="headerlink" title="字典法"></a>字典法</h4><p>如果说暴力枚举法是用时间换空间，那么字典法则就是用空间换时间。黑客利用一个巨大的字典，存储尽可能多的原文和对应的哈希值，每次用给定的信息摘要查找字典，即可快速找到碰撞的结果。不过这样虽然每次破解速度很快，但是生成字典所需要的空间极大。取巧的方式是优先存储常用的密码和摘要。</p><h4 id="彩虹表法"><a href="#彩虹表法" class="headerlink" title="彩虹表法"></a>彩虹表法</h4><p>彩虹表法可以说是字典法的优化，它采用了一种有趣的数据结构：<strong>彩虹表</strong>。</p><p>彩虹表对哈希链进行了改进，把原先的R(X)函数改进成从R1(X)到Rk(X)，一共k个衰减函数。这样一来虽然可能发生碰撞，但是碰撞只会发生在同一级运算，大大减小了存储重复的几率。</p><h4 id="差分攻击"><a href="#差分攻击" class="headerlink" title="差分攻击"></a>差分攻击</h4><p>2009年，冯登国、谢涛利用差分攻击，将MD5的碰撞算法复杂度进一步降低，想了解的小伙伴可以自行查阅相关资料。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>对于单机来说，暴力枚举法的时间成本很高，字典法的空间成本很高。但是利用分布式计算和分布式存储，仍然可以有效破解MD5算法。因此这两种方法同样被黑客们广泛使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信息摘要技术&quot;&gt;&lt;a href=&quot;#信息摘要技术&quot; class=&quot;headerlink&quot; title=&quot;信息摘要技术&quot;&gt;&lt;/a&gt;信息摘要技术&lt;/h2&gt;&lt;p&gt;信息摘要把明文内容按某种规则生成一段哈希值，即使明文消息只改动了一点点，生成的结果也会完全不同。&lt;/p&gt;
&lt;p&gt;MD5（Message-digest-algorithm 5）就是信息摘要的一种实现，它可以把任意长度的明文字符串生成128位的哈希值。&lt;/p&gt;
&lt;h2 id=&quot;摘要哈希的生成过程&quot;&gt;&lt;a href=&quot;#摘要哈希的生成过程&quot; class=&quot;headerlink&quot; title=&quot;摘要哈希的生成过程&quot;&gt;&lt;/a&gt;摘要哈希的生成过程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;收集相关业务参数，在这里是金额和目标账户。当然，实际应用中的参数肯定比这多得多，这里只是做了简化。&lt;/li&gt;
&lt;li&gt;按照规则，把参数名和参数值拼接成一个字符串，同时把给定的&lt;strong&gt;密钥&lt;/strong&gt;也拼接起来。之所以需要密钥，是因为攻击者也可能获知拼接规则。&lt;/li&gt;
&lt;li&gt;利用MD5算法，从原文生成哈希值。MD5生成的哈希值是128位的二进制数，也就是32位的十六进制数。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
      <category term="算法" scheme="https://lishaojie1993.github.io/categories/Java/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lishaojie1993.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="MD5算法" scheme="https://lishaojie1993.github.io/tags/MD5%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>加密算法</title>
    <link href="https://lishaojie1993.github.io/2019/07/03/encryption/"/>
    <id>https://lishaojie1993.github.io/2019/07/03/encryption/</id>
    <published>2019-07-03T15:21:25.000Z</published>
    <updated>2020-01-17T07:05:01.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="加密算法的种类"><a href="#加密算法的种类" class="headerlink" title="加密算法的种类"></a>加密算法的种类</h2><p>从宏观上来看，加密算法可以归结为三大类：<strong>哈希算法、对称加密算法、非对称加密算法。</strong></p><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>从严格意义上来说，<strong>哈希算法并不属于加密算法</strong>，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是<strong>生成信息摘要</strong>，用以验证原信息的完整性和来源的可靠性。</p><p>举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，<strong>Hash（1234_100_abc） = 948569CD3466451F</strong>）</p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazjr47fjuj30fp08d0t4.jpg" alt></p><p>请求方把所有参数，外加双方约定的key拼接起来，并利用哈希算法生成一段信息摘要，而接收方在接收到参数和摘要后，按照同样的规则，也把参数和key拼接起来生成摘要并进行比较，如果完全一致，则证明信息没有被篡改。</p><p>生成信息摘要的过程叫做<strong>签名</strong>，验证信息摘要的过程叫做<strong>验签</strong>。</p><p>哈希算法最著名的当属<strong>MD5算法</strong>。后来，人们觉得MD5算法生成的信息摘要太短（128位），不够安全，于是又有了<strong>SHA系列算法</strong>。</p><hr><h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>上面提到的哈希算法可以解决验签问题，却不能解决明文加密问题。</p><h3 id="什么是对称加密？"><a href="#什么是对称加密？" class="headerlink" title="什么是对称加密？"></a>什么是对称加密？</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazjwvskkzj30gw05c3z0.jpg" alt></p><p>如图所示，一段明文通过密钥进行加密，可以生成一段密文；这段密文通过同样的密钥进行解密，可以还原成明文。这样一来，只要双方事先约定好了密钥，就可以使用密文进行往来通信。</p><p>除了通信过程中的加密以外，数据库存储的敏感信息也可以通过这种方式进行加密。这样即使数据泄露到了外界，泄露出去的也都是密文。</p><h3 id="对称加密包含哪些算法？"><a href="#对称加密包含哪些算法？" class="headerlink" title="对称加密包含哪些算法？"></a>对称加密包含哪些算法？</h3><p>在早期，人们使用<strong>DES算法</strong>进行加密解密；后来，人们觉得DES不够安全，发明了<strong>3DES</strong>算法；而如今，最为流行的对称加密算法是<strong>AES算法</strong>。</p><h3 id="对称加密的优缺点"><a href="#对称加密的优缺点" class="headerlink" title="对称加密的优缺点"></a>对称加密的优缺点</h3><p>对称算法的好处是加密解密的效率比较高，缺点是不够安全，因为通信双方约定的密钥是相同的，只要密钥本身被任何一方泄露出去，通信的密文就会被破解；此外，在双方建立通信之初，服务端把密钥告诉给客户端的时候，也有被拦截到的危险。</p><hr><h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2><h3 id="什么是非对称加密？"><a href="#什么是非对称加密？" class="headerlink" title="什么是非对称加密？"></a>什么是非对称加密？</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazk870sktj30ed09kmyf.jpg" alt></p><p>如图所示，在非对称加密中存在一对密钥，一个叫做<strong>公钥</strong>，另一个叫做<strong>私钥</strong>。在加密解密的过程中，我们既可以使用公钥加密明文，使用私钥解密密文；也可以使用私钥加密明文，使用公钥解密密文。其中最著名的非对称加密当属<strong>RSA算法</strong>。</p><h3 id="非对称加密的通信过程"><a href="#非对称加密的通信过程" class="headerlink" title="非对称加密的通信过程"></a>非对称加密的通信过程</h3><ol><li>在双方建立通信的时候，服务端只把公钥发送给客户端，自己保留私钥。</li><li>客户端利用接受到的公钥，加密另外一个密钥X（可以是对称加密的密钥），发送给服务端。</li><li>服务端获得消息后，利用自己的私钥解密，得到里面隐含的密钥X。</li><li>从此以后，双方可以利用密钥X进行对称加密的通信了。</li></ol><h3 id="非对称加密的优缺点"><a href="#非对称加密的优缺点" class="headerlink" title="非对称加密的优缺点"></a>非对称加密的优缺点</h3><p>好处就是安全性很高，在通信过程中，即使公钥被第三方截获，甚至后续的所有通信都被截获，第三方也无法进行破解。因为第二步利用公钥加密的消息，只有私钥才能解开，所以第三方永远无法知道密钥X是什么。</p><p>缺点是性能较差，无法应用于长期的通信。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;加密算法的种类&quot;&gt;&lt;a href=&quot;#加密算法的种类&quot; class=&quot;headerlink&quot; title=&quot;加密算法的种类&quot;&gt;&lt;/a&gt;加密算法的种类&lt;/h2&gt;&lt;p&gt;从宏观上来看，加密算法可以归结为三大类：&lt;strong&gt;哈希算法、对称加密算法、非对称加密算法。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;哈希算法&quot;&gt;&lt;a href=&quot;#哈希算法&quot; class=&quot;headerlink&quot; title=&quot;哈希算法&quot;&gt;&lt;/a&gt;哈希算法&lt;/h2&gt;&lt;p&gt;从严格意义上来说，&lt;strong&gt;哈希算法并不属于加密算法&lt;/strong&gt;，但它在信息安全领域也起到了很重要的作用。其中一个重要的作用就是&lt;strong&gt;生成信息摘要&lt;/strong&gt;，用以验证原信息的完整性和来源的可靠性。&lt;/p&gt;
&lt;p&gt;举个例子，在网上买东西，需要用到支付宝付款，于是付款时需要通知支付宝，并告诉支付宝商户ID、支付金额等等信息。具体过程如下：（假如key=abc，&lt;strong&gt;Hash（1234_100_abc） = 948569CD3466451F&lt;/strong&gt;）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
      <category term="算法" scheme="https://lishaojie1993.github.io/categories/Java/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lishaojie1993.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="加密算法" scheme="https://lishaojie1993.github.io/tags/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链表“逆序”算法</title>
    <link href="https://lishaojie1993.github.io/2019/06/18/LinkedList-Reverse/"/>
    <id>https://lishaojie1993.github.io/2019/06/18/LinkedList-Reverse/</id>
    <published>2019-06-18T14:06:48.000Z</published>
    <updated>2020-01-17T05:59:38.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逆序本质"><a href="#逆序本质" class="headerlink" title="逆序本质"></a>逆序本质</h2><p>链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li>从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。</li><li>以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li><li>三个临时节点的引用分别向后移动一格位置。</li><li>重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。</li><li>重复第3步的工作，三个临时节点分别向后移动一格位置。</li><li>继续这样迭代下去，直到p2是空为止。</li><li>最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。</li></ol><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Node head; <span class="comment">//这里head是静态成员，其实也可以作为方法参数传入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverseLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//算法实现</span></span><br><span class="line">  Node p1 = head;</span><br><span class="line">  Node p2 = head.next;</span><br><span class="line">  Node p3 = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">while</span>(p2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    p3 = p2.next; <span class="comment">//给p3赋值</span></span><br><span class="line">    p2.next = p1; <span class="comment">//p2指向p1</span></span><br><span class="line">    p1 = p2; <span class="comment">//给p1赋值</span></span><br><span class="line">    p2 = p3; <span class="comment">//给p2赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">  head.next = <span class="keyword">null</span>; <span class="comment">//head指向null</span></span><br><span class="line">  head = p1; <span class="comment">//给head赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> data;</span><br><span class="line">  Node next;</span><br><span class="line">  Node(<span class="keyword">int</span> data)&#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//初始化链表</span></span><br><span class="line">  head = <span class="keyword">new</span> Node(<span class="number">3</span>); <span class="comment">//给头节点赋值</span></span><br><span class="line">  head.next = <span class="keyword">new</span> Node(<span class="number">6</span>); <span class="comment">//头节点的next指向新节点6</span></span><br><span class="line">  </span><br><span class="line">  Node temp = head.next; <span class="comment">//定义临时节点并赋值</span></span><br><span class="line">  temp.next = <span class="keyword">new</span> Node(<span class="number">1</span>); <span class="comment">//临时节点的next指向新节点1</span></span><br><span class="line">  temp = temp.next; <span class="comment">//临时节点指针后移</span></span><br><span class="line">  temp.next = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">  temp = temp.next;</span><br><span class="line">  temp.next = <span class="keyword">new</span> Node(<span class="number">9</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//输出初始化的链表</span></span><br><span class="line">  temp = head;</span><br><span class="line">  <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(temp.data);</span><br><span class="line">    temp = temp.next;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//调用逆序链表的方法</span></span><br><span class="line">  reverseLinkedList();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//输出逆序后的链表</span></span><br><span class="line">  temp = head;</span><br><span class="line">  <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(temp.data);</span><br><span class="line">    temp = temp.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;逆序本质&quot;&gt;&lt;a href=&quot;#逆序本质&quot; class=&quot;headerlink&quot; title=&quot;逆序本质&quot;&gt;&lt;/a&gt;逆序本质&lt;/h2&gt;&lt;p&gt;链表逆序的本质就是把每一个节点原本指向下一个节点的next指针倒转过来，指向它的前置节点。&lt;/p&gt;
&lt;h2 id=&quot;实现步骤&quot;&gt;&lt;a href=&quot;#实现步骤&quot; class=&quot;headerlink&quot; title=&quot;实现步骤&quot;&gt;&lt;/a&gt;实现步骤&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;从链表头部开始，建立三个临时节点的引用，分别为p1，p2，p3。它们分别指向头节点、第二个节点和第三个节点。&lt;/li&gt;
&lt;li&gt;以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。&lt;/li&gt;
&lt;li&gt;三个临时节点的引用分别向后移动一格位置。&lt;/li&gt;
&lt;li&gt;重复第2步的工作，以p2节点为视角，把p2节点原本指向p3的next指针倒转，指向p1。&lt;/li&gt;
&lt;li&gt;重复第3步的工作，三个临时节点分别向后移动一格位置。&lt;/li&gt;
&lt;li&gt;继续这样迭代下去，直到p2是空为止。&lt;/li&gt;
&lt;li&gt;最后把head节点的next指向null，成为逆序链表的尾节点，并且把p1赋值给head，成为头节点。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
      <category term="算法" scheme="https://lishaojie1993.github.io/categories/Java/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lishaojie1993.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="链表逆序算法" scheme="https://lishaojie1993.github.io/tags/%E9%93%BE%E8%A1%A8%E9%80%86%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>八大排序算法整理</title>
    <link href="https://lishaojie1993.github.io/2019/06/17/Sort/"/>
    <id>https://lishaojie1993.github.io/2019/06/17/Sort/</id>
    <published>2019-06-17T14:11:20.000Z</published>
    <updated>2020-01-17T05:06:57.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="排序的定义"><a href="#排序的定义" class="headerlink" title="排序的定义"></a>排序的定义</h2><p>对一序列对象根据某个关键字进行排序。</p><h2 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h2><ul><li><strong>稳定：</strong>如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li><strong>不稳定：</strong>如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li><strong>内排序：</strong>所有排序操作都在内存中完成；</li><li><strong>外排序：</strong>由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><strong>时间复杂度：</strong>一个算法执行所耗费的时间。</li><li><strong>空间复杂度：</strong>运行完一个程序所需内存的大小。</li></ul><a id="more"></a><h2 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazd21f5gxj30om0ggmza.jpg" alt></p><h3 id="比较排序"><a href="#比较排序" class="headerlink" title="比较排序"></a>比较排序</h3><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。<strong>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</strong></p><p>在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以时间复杂度平均O(nlogn)。</p><p>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><h3 id="非比较排序"><a href="#非比较排序" class="headerlink" title="非比较排序"></a>非比较排序</h3><p>计数排序、基数排序、桶排序则属于非比较排序。<strong>非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</strong></p><p>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。</p><p><strong>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</strong></p><h2 id="八大排序算法"><a href="#八大排序算法" class="headerlink" title="八大排序算法"></a>八大排序算法</h2><h3 id="冒泡排序（稳定）"><a href="#冒泡排序（稳定）" class="headerlink" title="冒泡排序（稳定）"></a>冒泡排序（稳定）</h3><p>冒泡排序（Bubble-Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><p>这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素做同样的工作，从第一对到最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><h4 id="过程演示"><a href="#过程演示" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdca6v64g30hs05jwnk.gif" alt></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冒泡排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - <span class="number">1</span> - i; j++)</span><br><span class="line">                <span class="keyword">if</span> (array[j + <span class="number">1</span>] &lt; array[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">                    array[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n) </li><li>最差情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(n2)</li></ul><hr><h3 id="选择排序（不稳定）"><a href="#选择排序（不稳定）" class="headerlink" title="选择排序（不稳定）"></a>选择排序（不稳定）</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间。</p><p>选择排序(Selection-Sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h4 id="过程演示-1"><a href="#过程演示-1" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdj1odlug30hq05f49s.gif" alt></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] selectionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[minIndex]) <span class="comment">//找到最小的数</span></span><br><span class="line">                    minIndex = j; <span class="comment">//将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = array[minIndex];</span><br><span class="line">            array[minIndex] = array[i];</span><br><span class="line">            array[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n2) </li><li>最差情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(n2)</li></ul><hr><h3 id="插入排序（稳定）"><a href="#插入排序（稳定）" class="headerlink" title="插入排序（稳定）"></a>插入排序（稳定）</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h4 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h4><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><h4 id="过程演示-2"><a href="#过程演示-2" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdn0r4w4g30hr0b2k1q.gif" alt></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] insertionSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            current = array[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> preIndex = i;</span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; current &lt; array[preIndex]) &#123;</span><br><span class="line">                array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">                preIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n) </li><li>最坏情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(n2)</li></ul><hr><h3 id="希尔排序（不稳定）"><a href="#希尔排序（不稳定）" class="headerlink" title="希尔排序（不稳定）"></a>希尔排序（不稳定）</h3><p>希尔排序是希尔（Donald-Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p><strong>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</strong></p><h4 id="算法描述-3"><a href="#算法描述-3" class="headerlink" title="算法描述"></a>算法描述</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="过程演示-3"><a href="#过程演示-3" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdrsaujjj30hx0je7fd.jpg" alt></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 希尔排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] ShellSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span> temp, gap = len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (gap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">                temp = array[i];</span><br><span class="line">                <span class="keyword">int</span> preIndex = i - gap;</span><br><span class="line">                <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; array[preIndex] &gt; temp) &#123;</span><br><span class="line">                    array[preIndex + gap] = array[preIndex];</span><br><span class="line">                    preIndex -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                array[preIndex + gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            gap /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlog2 n) </li><li>最坏情况：T(n) = O(nlog2 n) </li><li>平均情况：T(n) =O(nlog2n)　</li></ul><hr><h3 id="归并排序（稳定）"><a href="#归并排序（稳定）" class="headerlink" title="归并排序（稳定）"></a>归并排序（稳定）</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p><strong>归并排序（Merge-Sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</strong></p><h4 id="算法描述-4"><a href="#算法描述-4" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h4 id="过程演示-4"><a href="#过程演示-4" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdvclbg8g30hr0b248f.gif" alt></p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] MergeSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">2</span>) <span class="keyword">return</span> array;</span><br><span class="line">        <span class="keyword">int</span> mid = array.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line">        <span class="keyword">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line">        <span class="keyword">return</span> merge(MergeSort(left), MergeSort(right));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 归并排序——将两段排序好的数组结合成一个排序数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] left, <span class="keyword">int</span>[] right) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[left.length + right.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>; index &lt; result.length; index++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= left.length)</span><br><span class="line">                result[index] = right[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt;= right.length)</span><br><span class="line">                result[index] = left[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (left[i] &gt; right[j])</span><br><span class="line">                result[index] = right[j++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result[index] = left[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n) </li><li>最差情况：T(n) = O(nlogn) </li><li>平均情况：T(n) = O(nlogn)</li></ul><hr><h3 id="快速排序（不稳定）"><a href="#快速排序（不稳定）" class="headerlink" title="快速排序（不稳定）"></a>快速排序（不稳定）</h3><p>快速排序（Quick-Sort）通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="算法描述-5"><a href="#算法描述-5" class="headerlink" title="算法描述"></a>算法描述</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h4 id="过程演示-5"><a href="#过程演示-5" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazdyg13w7g30hp05iqbj.gif" alt></p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] QuickSort(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length &lt; <span class="number">1</span> || start &lt; <span class="number">0</span> || end &gt;= array.length || start &gt; end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> smallIndex = partition(array, start, end);</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &gt; start)</span><br><span class="line">            QuickSort(array, start, smallIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (smallIndex &lt; end)</span><br><span class="line">            QuickSort(array, smallIndex + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速排序算法——partition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = (<span class="keyword">int</span>) (start + Math.random() * (end - start + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">int</span> smallIndex = start - <span class="number">1</span>;</span><br><span class="line">        swap(array, pivot, end);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[end]) &#123;</span><br><span class="line">                smallIndex++;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; smallIndex)</span><br><span class="line">                    swap(array, i, smallIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> smallIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换数组内两个元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlogn) </li><li>最差情况：T(n) = O(n2) </li><li>平均情况：T(n) = O(nlogn)　</li></ul><hr><h3 id="堆排序（不稳定）"><a href="#堆排序（不稳定）" class="headerlink" title="堆排序（不稳定）"></a>堆排序（不稳定）</h3><p>堆排序（Heap-Sort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h4 id="算法描述-6"><a href="#算法描述-6" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h4 id="过程演示-6"><a href="#过程演示-6" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaze1k0uc8g30f70a44qp.gif" alt></p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明全局变量，用于记录数组array的长度；</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 堆排序算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] HeapSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        len = array.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">        <span class="comment">//1.构建一个最大堆</span></span><br><span class="line">        buildMaxHeap(array);</span><br><span class="line">        <span class="comment">//2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆</span></span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(array, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">            len--;</span><br><span class="line">            adjustHeap(array, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从最后一个非叶子节点开始向上构造最大堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (len/<span class="number">2</span> - <span class="number">1</span>); i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) </span></span><br><span class="line">            adjustHeap(array, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整使之成为最大堆</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = i;</span><br><span class="line">        <span class="comment">//如果有左子树，且左子树大于父节点，则将最大指针指向左子树</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> &lt; len &amp;&amp; array[i * <span class="number">2</span>] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = i * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果有右子树，且右子树大于父节点，则将最大指针指向右子树</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt; len &amp;&amp; array[i * <span class="number">2</span> + <span class="number">1</span>] &gt; array[maxIndex])</span><br><span class="line">            maxIndex = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。</span></span><br><span class="line">        <span class="keyword">if</span> (maxIndex != i) &#123;</span><br><span class="line">            swap(array, maxIndex, i);</span><br><span class="line">            adjustHeap(array, maxIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(nlogn) </li><li>最差情况：T(n) = O(nlogn) </li><li>平均情况：T(n) = O(nlogn)</li></ul><hr><h3 id="基数排序（稳定）"><a href="#基数排序（稳定）" class="headerlink" title="基数排序（稳定）"></a>基数排序（稳定）</h3><p>基数排序（Radix-Sort）也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn)，为数组长度，k为数组中的数的最大的位数。</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h4 id="算法描述-7"><a href="#算法描述-7" class="headerlink" title="算法描述"></a>算法描述</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序(利用计数排序适用于小范围数的特点)；</li></ul><h4 id="过程演示-7"><a href="#过程演示-7" class="headerlink" title="过程演示"></a>过程演示</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaze4srwjig30hs0a3kjl.gif" alt></p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基数排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] RadixSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> array;</span><br><span class="line">        <span class="comment">// 1.先算出最大数的位数；</span></span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            max = Math.max(max, array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxDigit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">            max /= <span class="number">10</span>;</span><br><span class="line">            maxDigit++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">10</span>, div = <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            bucketList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, mod *= <span class="number">10</span>, div *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num = (array[j] % mod) / div;</span><br><span class="line">                bucketList.get(num).add(array[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bucketList.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketList.get(j).size(); k++)</span><br><span class="line">                    array[index++] = bucketList.get(j).get(k);</span><br><span class="line">                bucketList.get(j).clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>最佳情况：T(n) = O(n * k) </li><li>最差情况：T(n) = O(n * k) </li><li>平均情况：T(n) = O(n * k)</li></ul><p>基数排序有两种方法：</p><ul><li>MSD 从高位开始进行排序</li><li>LSD 从低位开始进行排序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;排序的定义&quot;&gt;&lt;a href=&quot;#排序的定义&quot; class=&quot;headerlink&quot; title=&quot;排序的定义&quot;&gt;&lt;/a&gt;排序的定义&lt;/h2&gt;&lt;p&gt;对一序列对象根据某个关键字进行排序。&lt;/p&gt;
&lt;h2 id=&quot;术语说明&quot;&gt;&lt;a href=&quot;#术语说明&quot; class=&quot;headerlink&quot; title=&quot;术语说明&quot;&gt;&lt;/a&gt;术语说明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;稳定：&lt;/strong&gt;如果a原本在b前面，而a=b，排序之后a仍然在b的前面；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不稳定：&lt;/strong&gt;如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内排序：&lt;/strong&gt;所有排序操作都在内存中完成；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外排序：&lt;/strong&gt;由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度：&lt;/strong&gt;一个算法执行所耗费的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度：&lt;/strong&gt;运行完一个程序所需内存的大小。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
      <category term="算法" scheme="https://lishaojie1993.github.io/categories/Java/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://lishaojie1993.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="八大排序算法" scheme="https://lishaojie1993.github.io/tags/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>消息队列-MQ</title>
    <link href="https://lishaojie1993.github.io/2019/03/19/MQ/"/>
    <id>https://lishaojie1993.github.io/2019/03/19/MQ/</id>
    <published>2019-03-19T15:28:33.000Z</published>
    <updated>2020-02-14T16:33:42.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用消息队列？说说优缺点？"><a href="#为什么使用消息队列？说说优缺点？" class="headerlink" title="为什么使用消息队列？说说优缺点？"></a>为什么使用消息队列？说说优缺点？</h2><p>我们公司有个什么业务场景，这个场景有个什么技术挑战，如果不用MQ会很麻烦，用了MQ之后带来了很多好处。</p><p>比较核心的使用场景有3个：<strong>解耦、异步、削峰</strong>。同样也是使用MQ的<strong>优点</strong>。</p><p><strong>解耦举例</strong>：A系统产生了一条比较重要的数据，B、C、D系统都需要，如果不使用MQ的话，A系统要做很多事情，比如需要分别调用B、C、D系统的接口传递数据，还要考虑接口的参数，可用性等等， 如果有新系统加入的话，还要更改很麻烦。如果使用MQ的话，A系统把产生的数据直接发送到MQ就不用管了，谁需要这条消息自己去MQ里获取，如果某个系统不需要这些消息了就不用去消费数据了，这样A系统就不需要考虑其他系统是否调用成功，接口是否超时，失败重试等等，所有操作就变得很简单。</p><p>总结：通过一个MQ的发布/订阅模型（Pub/Sub）系统A就跟其他系统解耦了。<a id="more"></a></p><p><strong>异步举例</strong>：A系统发起一次请求，假设A系统本地处理SQL并发送需要20ms，然后分别调用B、C、D系统，分别耗时300ms，450ms，200ms，如果是同步调用的话，总耗时就是这几次调用的和，用户的内心是崩溃的。如果使用MQ的话，系统A可以连续发送3条消息到3个MQ队列中，耗时5ms，系统B、C、D自己从对应的消息队列中获取，需要耗时操作在各自系统执行。因为是异步调用，A系统不需要等待反馈，发送成功后直接给用户反馈的时间就是20ms+5ms=25ms，用户爽歪歪。</p><p>总结：系统间非常耗时的调用，可以使用MQ异步化来做性能优化。异步化可以大幅度提升高延时接口的性能。</p><p><strong>削峰举例</strong>：大量用户（几百万）通过浏览器同时在某一时刻进行操作，这时就会有大量的请求涌入，如果超过数据库瓶颈就会把数据库打死，高峰期过后请求会大量减少，这时可以考虑采用MQ做削峰处理。大量的请求直接发送到MQ，各个系统根据自己的处理能力去MQ拉取消息，延时处理MQ积压的请求，达到削峰的效果。</p><p>总结：削峰可以缓解数据库压力，达到最终一致性。</p><p><strong>缺点</strong>：</p><ul><li>系统的可用性降低，系统引入的外部依赖越多，越容易挂掉。MQ发生故障，可能使系统崩溃。</li><li>系统的复杂性提高，还需要考虑重复消费，消息丢失，消息传递顺序性等等一系列问题。</li><li>一致性问题，A系统把请求发送到MQ返回成功了，但是B、C、D消费消息有失败的，如何解决。</li></ul><hr><h2 id="不同消息中间件的区别以及适用场景？"><a href="#不同消息中间件的区别以及适用场景？" class="headerlink" title="不同消息中间件的区别以及适用场景？"></a>不同消息中间件的区别以及适用场景？</h2><ul><li>单机吞吐量：activemq和rabbitmq吞吐量是万级，rocketmq和kafka都是10万级。</li><li>时效性：影响不大，activemq、rocketmq、kafka都在毫秒级，rabbitmq在微秒级。</li><li>可用性：都可以保证，activemq和rabbitmq都是基于主从架构，后两者基于分布式架构。</li></ul><p>优劣势总结</p><ul><li>activemq非常成熟，功能强大，在业内有广泛应用，不过偶尔会有较低概率丢失消息，还有就是开源社区越来越不活跃，维护次数也越来越少，activemq5.x主要是基于解耦和异步来使用的，较少在大规模吞吐量的场景哦中使用。</li><li>rabbitmq并发能力很强，性能极好，延迟很低，特别适合国内中小型公司，提供非常友好的后台管理界面，开源社区相对来说比较活跃。不过确实吞吐量低一些，而且rabbitmq集群动态扩展很麻烦，erlang开发的，很难读懂源码。</li><li>rocketmq的吞吐量很大，阿里开源的采用分布式架构设计的，扩展方便而且可用性很高，经过参数优化配置可以做到消息0丢失，可以支撑大规模吞吐量、业务复杂的场景，社区很活跃，源码是Java的。缺点是如果阿里抛弃这个技术，社区很可能黄掉，需要自己维护。</li><li>kafka也是可以做到大规模吞吐，分布式架构可用性很高，任意扩展，消息0丢失，功能较为简单，在大数据领域的实时计算以及日志采集被大规模使用。kafka唯一的缺点就是可能消息重复消费。</li></ul><p>综上所述：现在越来越多的公司去使用RocketMQ，大型公司并且对自己公司实力有自信的，推荐使用。对于技术实力较为一般、技术挑战不是很高的中小型公司推荐RabbitMQ，如果是大数据领域的实时计算，日志采集等场景，kafka是业内标准，肯定不会黄。</p><hr><h2 id="RabbitMQ如何保证消息队列的高可用？"><a href="#RabbitMQ如何保证消息队列的高可用？" class="headerlink" title="RabbitMQ如何保证消息队列的高可用？"></a>RabbitMQ如何保证消息队列的高可用？</h2><p>RabbitMQ是比较有代表性的，因为是基于<strong>主从架构</strong>实现的的高可用。</p><p>RabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式。</p><ol><li><p>单机模式</p><p>就是demo级别的，一般就是自己玩玩，没有生产环境使用单机模式的。</p></li><li><p>普通集群模式（不是高可用的）</p><p>意思就是分别在多台机器上启动多个rabbitmq实例，每个机器启动一个，但是你创建的queue只会把元数据和实际数据放在一个rabbitmq实例上，每个实例都去同步queue的元数据。等到你消费的时候，如果你连接到另外一个实例，那么该实例就会从queue所在的实例上拉取实际数据过来。</p><p>该模式有两个缺点：</p><p>​    如果每次随机连接一个实例，可能会在rabbitmq集群内部产生大量的数据传输，造成大量的数据开销；</p><p>​    如果每次都连接queue的实例，那么也就没有什么性能可言，queue宕机后就不能使用了。</p></li><li><p>镜像集群模式（是高可用的）</p><p>这种模式才是真正的rabbitmq的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论是元数据还是queue里的消息都会存在于多个实例上，每次写入消息到queue的时候，都会自动把消息同步到多个实例。</p><p>这样的话好处在于你的任何一个机器宕机了，其他机器都还可以使用。坏处在于开销太大，消息同步所有机器，导致网络带宽压力和消耗都很严重。其次是没有扩展性，如果queue的数据量很大，负载很严重，增加机器也会包含queue的所有数据，并没有办法扩展queue。</p><p><strong>怎么开启这个镜像集群模式呢？</strong></p><p>rabbitmq有很好的管理控制台，在后台新增一个镜像集群模式的策略，指定同步节点的时候要求数据同步到所有节点，再次创建queue的时候，应用这个策略就会自动将数据同步到其他的节点上。</p></li></ol><hr><h2 id="如何保证消息不被重复消费？-幂等性"><a href="#如何保证消息不被重复消费？-幂等性" class="headerlink" title="如何保证消息不被重复消费？(幂等性)"></a>如何保证消息不被重复消费？(幂等性)</h2><p>什么是幂等性，同一条数据重复出现了多次，数据库里只保存一条数据，这就是保证了系统的幂等性。</p><p><strong>如何保证幂等性，需要结合具体的业务场景来思考，先来几个思路：</strong></p><ol><li>比如获取到消息准备写入数据库，先根据主键查一下有没有消费过，如果消费过可以选择不处理或者更新。</li><li>比如是要写入Redis，就不用考虑了，Redis每次都是set，天然幂等性。</li><li>还可以让生产者发送数据时，增加一个全局唯一的ID，维护一张消费记录表，消费数据前，先去消息记录表中查询有没有消费过，如果没有消费就处理，消费过了就不要处理了。</li></ol><hr><h2 id="如何保证消息的可靠性传输，不丢消息？"><a href="#如何保证消息的可靠性传输，不丢消息？" class="headerlink" title="如何保证消息的可靠性传输，不丢消息？"></a>如何保证消息的可靠性传输，不丢消息？</h2><p><strong>消息丢失的3种情况：</strong></p><ol><li><strong>生产者</strong>写入消息的过程中，消息没到rabbitmq，在网络传输过程中丢失了；</li><li><strong>rabbitmq</strong>接受到了消息并暂存入内存，消费者还没来得及消费，rabbitmq自己挂掉了；</li><li><strong>消费者</strong>消费到了这个消息，但是还没来得及处理，自己就挂掉了，rabbitmq以为处理完了。</li></ol><p>情况1<strong>（生产者弄丢了数据）</strong>的解决方案：</p><p><strong>rabbitmq的事务机制</strong>：生产者发送数据之前开启rabbitmq事务（channel.txSelect），然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息，如果收到了消息，就可以提交事务（channel.txCommit）。但是rabbitmq事务一搞，同步机制太耗性能，基本上吞吐量会下来。</p><p><strong>confirm机制</strong>：在生产者那里设置开启confirm模式后，每次写的消息都会分配一个唯一的ID，如果成功写入了rabbitmq中，rabbitmq会回调生产者ack接口，说明这个消息成功写入了。如果rabbitmq没能处理这个消息，会回调一个nack接口，说明这个消息接收失败，需要重发。而且还可以在内存里维护每个消息ID的状态，如果超过一定时间还没有接受到这个消息的回调，也可以重发。</p><p>事务机制和confirm机制最大的不同在于，事务机制是同步的，提交一个事务以后会阻塞在那，但是confirm机制是异步的，发送消息以后可以再发送下一个消息，rabbitmq接收到以后会异步回调生产者接口告知。</p><p>情况2<strong>（rabbitmq弄丢了数据）</strong>的解决方案：</p><p><strong>开启rabbitmq持久化</strong>：意思就是写入消息到rabbitmq后会把消息持久化到磁盘，这样就算rabbitmq自己挂了，恢复之后也会自动读取之前存储的数据，一般数据不会丢。也有可能rabbitmq还没持久化就挂了，导致数据丢失，不过这种情况概率较小。</p><p>设置持久化有两个步骤，第一个步骤是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的消息；第二个步骤是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化。此时rabbitmq就会将消息持久化到磁盘了，<strong>注意：必须同时设置这两个才可以</strong>。</p><p>这个持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会回调生产者的ack接口，所以即使是持久化到磁盘之前rabbitmq挂了，生产者收不到回调，也是会重发的。</p><p>情况3<strong>（消费者弄丢了数据）</strong>的解决方案：</p><p>消费者有autoAck机制，就是消费数据之后，消费者会自动通知rabbitmq消费成功了。但是如果消费的消息还在处理中，还没处理完，消费者宕机了，还是会造成消息丢失。所以这里我们需要关闭autoAck机制，然后等待消费者完全处理完消息后，再手动发送ack给rabbitmq，此时就不会丢失消息了。</p><hr><h2 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h2><p>先看看造成消息错乱的场景</p><p>如果rabbitmq的一个queue对应多个consumer，肯定会发生错乱。</p><p>解决方案：</p><p>拆分多个queue，使每个queue对应一个consumer，这样就可以保证消费的顺序性了；</p><p>一个queue只对应一个consumer，让consumer内部用内存队列排队，然后分发给底层不同的worker来处理。</p><hr><p>如何解决消息队列的延迟以及过期失效的问题？消息队列满了以后怎么处理？有几百万条消息持续积压几小时，说说怎么解决？</p><p>一般这个时候，只能操作临时紧急扩容了，具体操作步骤如下：</p><ol><li>先修复consumer的问题，确保其恢复正常的消费速度，然后将现有的consumer都停掉。</li><li>临时建立好原先10倍或者20倍的queue数量。</li><li>然后写一个临时分发数据的consumer程序，把这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮训写入临时建立好的10倍数量的queue。</li><li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据。</li><li>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消耗数据。</li><li>等快速消费完积压的数据之后，得恢复原来部署的架构，重新用原先的consumer机器来消费消息。</li></ol><p>假设使用的是rabbitmq，设置了过期时间，过量积压最终导致大量数据过期后丢失，这种情况只能是批量重导。到了晚上高峰期过后，查询出来丢失的数据，重新灌入到mq中，把丢失的数据补回来。</p><p>如果是因为积压太久导致mq快写满了，只能临时修改程序，快速消费掉所有消息，然后晚上再补数据。</p><hr><h2 id="如果让你写消息队列，如何架构设计？"><a href="#如果让你写消息队列，如何架构设计？" class="headerlink" title="如果让你写消息队列，如何架构设计？"></a>如果让你写消息队列，如何架构设计？</h2><p><strong>下面说一下设计思路</strong></p><ol><li>首先设计的mq得支持可伸缩，就是需要的时候快速扩容，就可以增加容量和吞吐量。所以需要设计一个分布式系统，参照kafka的设计理念，broker -&gt; topic -&gt; partition，每个partition放一个机器，就存一部分数据。如果资源不够了，可以直接给topic增加partition，然后做数据迁移。</li><li>其次设计的mq需要把数据落地到磁盘，防止数据丢失。根据Kafka的设计思路，顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的。</li><li>还要考虑一下mq的可用性。具体参照Kafka的高可用环节，多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举leader即可对外服务。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么使用消息队列？说说优缺点？&quot;&gt;&lt;a href=&quot;#为什么使用消息队列？说说优缺点？&quot; class=&quot;headerlink&quot; title=&quot;为什么使用消息队列？说说优缺点？&quot;&gt;&lt;/a&gt;为什么使用消息队列？说说优缺点？&lt;/h2&gt;&lt;p&gt;我们公司有个什么业务场景，这个场景有个什么技术挑战，如果不用MQ会很麻烦，用了MQ之后带来了很多好处。&lt;/p&gt;
&lt;p&gt;比较核心的使用场景有3个：&lt;strong&gt;解耦、异步、削峰&lt;/strong&gt;。同样也是使用MQ的&lt;strong&gt;优点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解耦举例&lt;/strong&gt;：A系统产生了一条比较重要的数据，B、C、D系统都需要，如果不使用MQ的话，A系统要做很多事情，比如需要分别调用B、C、D系统的接口传递数据，还要考虑接口的参数，可用性等等， 如果有新系统加入的话，还要更改很麻烦。如果使用MQ的话，A系统把产生的数据直接发送到MQ就不用管了，谁需要这条消息自己去MQ里获取，如果某个系统不需要这些消息了就不用去消费数据了，这样A系统就不需要考虑其他系统是否调用成功，接口是否超时，失败重试等等，所有操作就变得很简单。&lt;/p&gt;
&lt;p&gt;总结：通过一个MQ的发布/订阅模型（Pub/Sub）系统A就跟其他系统解耦了。
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
    
      <category term="分布式" scheme="https://lishaojie1993.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="消息队列" scheme="https://lishaojie1993.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap底层实现</title>
    <link href="https://lishaojie1993.github.io/2019/03/19/ConcurrentHashMap/"/>
    <id>https://lishaojie1993.github.io/2019/03/19/ConcurrentHashMap/</id>
    <published>2019-03-19T14:54:49.000Z</published>
    <updated>2020-01-17T05:09:34.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h2><p>Segment本身就相当于一个HashMap对象，同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。像这样的Segment对象，在ConcurrentHashMap集合中有2的N次方个，共同保存在一个名为segments的数组当中。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaza7kcjxqj30kw0bsgn7.jpg" alt></p><a id="more"></a><p>可以说，ConcurrentHashMap是一个二级哈希表。在一个总的哈希表下面，有若干个子哈希表。这样的二级结构，和数据库的水平拆分有些相似。</p><p>ConcurrentHashMap优势就是采用了[锁分段]技术，每一个Segment就好比一个自治区，读写操作高度自治，Segment之间互不影响。</p><h3 id="并发读写的情况"><a href="#并发读写的情况" class="headerlink" title="并发读写的情况"></a>并发读写的情况</h3><ol><li><p>不同Segment的并发写入——<strong>可以并发执行</strong></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazahwt8gmj30hs083jrj.jpg" alt></p></li><li><p>同一Segment的一写一读——<strong>可以并发执行</strong></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazai5be4aj30jv07wgmh.jpg" alt></p></li><li><p>同一Segment的并发写入——<strong>会发生阻塞</strong></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gazaicuv2mj30k1081q3s.jpg" alt></p></li></ol><p>Segment的写入是需要上锁的，因此对同一Segment的并发写入会被阻塞。</p><p>由此可见，ConcurrentHashMap当中每个Segment各自持有一把锁。在保证线程安全的同时降低了锁的粒度，让并发操作效率更高。</p><h2 id="ConcurrentHashMap读写过程"><a href="#ConcurrentHashMap读写过程" class="headerlink" title="ConcurrentHashMap读写过程"></a>ConcurrentHashMap读写过程</h2><h3 id="Get方法"><a href="#Get方法" class="headerlink" title="Get方法"></a>Get方法</h3><ol><li>为输入的Key做Hash运算，得到hash值。</li><li>通过hash值，定位到对应的Segment对象</li><li>再次通过hash值，定位到Segment当中数组的具体位置。</li></ol><h3 id="Put方法"><a href="#Put方法" class="headerlink" title="Put方法"></a>Put方法</h3><ol><li>为输入的Key做Hash运算，得到hash值。</li><li>通过hash值，定位到对应的Segment对象</li><li>获取可重入锁</li><li>再次通过hash值，定位到Segment当中数组的具体位置。</li><li>插入或覆盖HashEntry对象。</li><li>释放锁。</li></ol><p><strong>从步骤中可以看出，ConcurrentHashMap在读写时都需要二次定位。首先定位到Segment，然后定位到Segment内的具体数组下标。</strong></p><h2 id="ConcurrentHashMap的Size方法"><a href="#ConcurrentHashMap的Size方法" class="headerlink" title="ConcurrentHashMap的Size方法"></a>ConcurrentHashMap的Size方法</h2><h3 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h3><p>ConcurrentHashMap的Size方法是一个嵌套循环，大体逻辑如下：</p><ol><li>遍历所有的Segment。</li><li>把Segment的元素数量累加起来。</li><li>把Segment的修改次数累加起来。</li><li>判断所有Segment的总修改次数是否大于上一次的总修改次数。如果大于，说明统计过程中有修改，重新统计，尝试次数+1；如果不是。说明没有修改，统计结束。</li><li>如果尝试次数超过阈值，则对每一个Segment加锁，再重新统计。</li><li>再次判断所有Segment的总修改次数是否大于上一次的总修改次数。由于已经加锁，次数一定和上次相等。</li><li>释放锁，统计结束。</li></ol><h3 id="官方代码"><a href="#官方代码" class="headerlink" title="官方代码"></a>官方代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">   <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">   <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">    <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">    <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">    <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn't retry</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">            &#125;</span><br><span class="line">            sum = <span class="number">0L</span>;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            overflow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += seg.modCount;</span><br><span class="line">                    <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                    <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                        overflow = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == last)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            last = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                segmentAt(segments, j).unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><p>这种思想和乐观锁悲观锁的思想如出一辙。</p><p>为了尽量不锁住所有Segment，首先乐观地假设Size过程中不会有修改。当尝试一定次数，才无奈转为悲观锁，锁住所有Segment保证强一致性。</p><h2 id="ConcurrentHashMap的扩容机制"><a href="#ConcurrentHashMap的扩容机制" class="headerlink" title="ConcurrentHashMap的扩容机制"></a>ConcurrentHashMap的扩容机制</h2><p>当ConcurrentHashMap中元素的数量达到cap * loadFactor时，就需要进行扩容。扩容主要通过transfer()方法进行，当有线程进行put操作时，如果正在进行扩容，可以通过helpTransfer()方法加入扩容。也就是说，ConcurrentHashMap支持多线程扩容，多个线程处理不同的节点。</p><h2 id="JDK1-8下做了哪些优化"><a href="#JDK1-8下做了哪些优化" class="headerlink" title="JDK1.8下做了哪些优化"></a>JDK1.8下做了哪些优化</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>JDK1.8 放弃了分段锁Segment而是用了Node，采用了 CAS + synchronized 来保证并发安全性，降低锁的粒度，提高性能，并使用CAS操作来确保Node的一些操作的原子性，取代了锁。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>ConcurrentHashMap的一些操作使用了synchronized锁，而不是ReentrantLock,虽然说JDK1.8的synchronized的性能进行了优化，但是我觉得还是使用ReentrantLock锁能更多的提高性能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Segment&quot;&gt;&lt;a href=&quot;#Segment&quot; class=&quot;headerlink&quot; title=&quot;Segment&quot;&gt;&lt;/a&gt;Segment&lt;/h2&gt;&lt;p&gt;Segment本身就相当于一个HashMap对象，同HashMap一样，Segment包含一个HashEntry数组，数组中的每一个HashEntry既是一个键值对，也是一个链表的头节点。像这样的Segment对象，在ConcurrentHashMap集合中有2的N次方个，共同保存在一个名为segments的数组当中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gaza7kcjxqj30kw0bsgn7.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
      <category term="数据结构" scheme="https://lishaojie1993.github.io/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://lishaojie1993.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="高并发" scheme="https://lishaojie1993.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="ConcurrentHashMap" scheme="https://lishaojie1993.github.io/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>HashMap底层原理</title>
    <link href="https://lishaojie1993.github.io/2019/03/18/HashMap/"/>
    <id>https://lishaojie1993.github.io/2019/03/18/HashMap/</id>
    <published>2019-03-18T13:54:59.000Z</published>
    <updated>2020-01-17T05:07:33.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashMap的底层原理"><a href="#HashMap的底层原理" class="headerlink" title="HashMap的底层原理"></a>HashMap的底层原理</h2><p>HashMap是一个用于存储key-value键值对的集合，每一个键值对也叫做Entry。数组中的每一个Entry元素，又是一个链表的头节点。这些键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。</p><p>Hashmap不是线程安全的。在高并发环境下做插入操作，有可能出现环形链表。HashMap数组每一个元素的初始值都是Null，最常使用的两个方法是Put和Get。</p><h3 id="Put方法的原理"><a href="#Put方法的原理" class="headerlink" title="Put方法的原理"></a>Put方法的原理</h3><p>比如调用 hashMap.put(“apple”, 0) ，插入一个Key为“apple”的元素。这时候我们需要利用一个哈希函数：<strong>index = Hash（“apple”）</strong>来确定Entry的插入位置（index），但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。<a id="more"></a></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9a1hu4j30ji06fq3g.jpg" alt></p><p>这时我们可以通过<strong>链表</strong>来解决。需要注意的是，新来的Entry节点插入链表时，使用的是“头插法”，因为HashMap的发明者认为：<strong>后插入的Entry被查找的可能性更大</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gayr9i7blpj30ju06wjrw.jpg" alt></p><h3 id="Get方法的原理"><a href="#Get方法的原理" class="headerlink" title="Get方法的原理"></a>Get方法的原理</h3><p>首先会把需要查询的key做一次Hash映射，得到对应的下标，由于刚才所说的Hash冲突，同一个位置有可能匹配到多个Entry，这时候就需要顺着对应链表的头节点，一个一个向下来查找。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gayreaylimj30jf07tt9n.jpg" alt></p><h2 id="HashMap的特点"><a href="#HashMap的特点" class="headerlink" title="HashMap的特点"></a>HashMap的特点</h2><h3 id="HashMap的默认初始长度"><a href="#HashMap的默认初始长度" class="headerlink" title="HashMap的默认初始长度"></a>HashMap的默认初始长度</h3><p>HashMap的默认初始长度是16，并且每次自动扩展或是手动初始化时，长度必须是2的幂。</p><h3 id="为什么这样设置？"><a href="#为什么这样设置？" class="headerlink" title="为什么这样设置？"></a>为什么这样设置？</h3><p>为了使Hash算法得到的index尽可能均匀分布。例如从Key映射到HashMap数组的对应位置时，会用到一个Hash函数：<strong>index = HashCode（Key） &amp; （Length - 1）</strong>，为了实现高效的Hash算法，采用位运算（与运算）</p><h2 id="高并发下的HashMap"><a href="#高并发下的HashMap" class="headerlink" title="高并发下的HashMap"></a>高并发下的HashMap</h2><h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h3><p>HashMap的容量是有限的，当经过多次元素插入，使得HashMap达到一定饱和度时，key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行<strong>Resize</strong>。</p><h3 id="影响Resize的两个因素"><a href="#影响Resize的两个因素" class="headerlink" title="影响Resize的两个因素"></a>影响Resize的两个因素</h3><ol><li><p>Capacity</p><p>HashMap的当前长度。</p></li><li><p>LoadFactor</p><p>HashMap负载因子，默认值为0.75f。</p></li></ol><p>衡量HashMap是否需要进行Resize的条件如下：</p><p><strong>HashMap.Size  &gt;= Capacity * LoadFactor</strong></p><h3 id="Resize做了什么？"><a href="#Resize做了什么？" class="headerlink" title="Resize做了什么？"></a>Resize做了什么？</h3><ol><li><p>扩容</p><p>创建一个新的Entry空数组，长度是原数组的2倍。</p></li><li><p>Rehash</p><p>遍历原Entry数组，把所有的Entry重新Hash到新数组。</p></li></ol><p><strong>为什么要重新Hash呢？</strong></p><p>因为长度扩大以后，Hash的规则也随之改变。（16=1111；32=11111）</p><p><strong>ReHash的Java代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么HashMap会出现死锁"><a href="#为什么HashMap会出现死锁" class="headerlink" title="为什么HashMap会出现死锁"></a>为什么HashMap会出现死锁</h3><p>在高并发情况下，如果HashMap正好达到临界点准备扩容，此时正好有两个线程在同时访问，在Rehash时链表可能会产生环形，当调用Get查找一个不存在的key，而这个key的Hash结果恰好位于环形链表处，这时程序将会进入死循环。</p><h2 id="JDK1-8下的HashMap优化"><a href="#JDK1-8下的HashMap优化" class="headerlink" title="JDK1.8下的HashMap优化"></a>JDK1.8下的HashMap优化</h2><h3 id="引入红黑树"><a href="#引入红黑树" class="headerlink" title="引入红黑树"></a>引入红黑树</h3><p>我们知道，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦拉链过长则会严重影响HashMap的性能，所以JDK1.8版本引入了红黑树：当链表长度太长（默认超过8）时，链表就转为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能。</p><h3 id="Resize扩容优化"><a href="#Resize扩容优化" class="headerlink" title="Resize扩容优化"></a>Resize扩容优化</h3><p>我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HashMap的底层原理&quot;&gt;&lt;a href=&quot;#HashMap的底层原理&quot; class=&quot;headerlink&quot; title=&quot;HashMap的底层原理&quot;&gt;&lt;/a&gt;HashMap的底层原理&lt;/h2&gt;&lt;p&gt;HashMap是一个用于存储key-value键值对的集合，每一个键值对也叫做Entry。数组中的每一个Entry元素，又是一个链表的头节点。这些键值对（Entry）分散存储在一个数组当中，这个数组就是HashMap的主干。&lt;/p&gt;
&lt;p&gt;Hashmap不是线程安全的。在高并发环境下做插入操作，有可能出现环形链表。HashMap数组每一个元素的初始值都是Null，最常使用的两个方法是Put和Get。&lt;/p&gt;
&lt;h3 id=&quot;Put方法的原理&quot;&gt;&lt;a href=&quot;#Put方法的原理&quot; class=&quot;headerlink&quot; title=&quot;Put方法的原理&quot;&gt;&lt;/a&gt;Put方法的原理&lt;/h3&gt;&lt;p&gt;比如调用 hashMap.put(“apple”, 0) ，插入一个Key为“apple”的元素。这时候我们需要利用一个哈希函数：&lt;strong&gt;index = Hash（“apple”）&lt;/strong&gt;来确定Entry的插入位置（index），但是，因为HashMap的长度是有限的，当插入的Entry越来越多时，再完美的Hash函数也难免会出现index冲突的情况。
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
      <category term="数据结构" scheme="https://lishaojie1993.github.io/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://lishaojie1993.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="HashMap" scheme="https://lishaojie1993.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>分库分表的原理</title>
    <link href="https://lishaojie1993.github.io/2019/03/17/Sub-table/"/>
    <id>https://lishaojie1993.github.io/2019/03/17/Sub-table/</id>
    <published>2019-03-17T15:43:23.000Z</published>
    <updated>2020-02-14T04:41:00.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要分库分表？"><a href="#为什么要分库分表？" class="headerlink" title="为什么要分库分表？"></a>为什么要分库分表？</h2><ul><li><p>数据库的数据会随着业务的发展而不断增多，对数据操作的开销也会越来越大。</p></li><li><p>物理服务器的资源有限（CPU、磁盘、内存、IO）最终数据库所能承载的数据量和数据处理能力遇到瓶颈。</p><p>换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。</p><p>比如单表数据量太大（500w以上），会极大的影响SQL的执行性能。<a id="more"></a></p></li></ul><hr><h2 id="如何进行分库分表？"><a href="#如何进行分库分表？" class="headerlink" title="如何进行分库分表？"></a>如何进行分库分表？</h2><h3 id="数据分表"><a href="#数据分表" class="headerlink" title="数据分表"></a>数据分表</h3><ul><li><h4 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h4><p>根据业务把一个表中的字段(Field)分到不同的表中。这些被分出去的数据通常根据业务需要，例如分出去一些不是经常使用的字段，一些长度较长的字段。一般被拆分的表的字段数比较多。<strong>主要是避免查询的时候出现因为数据量大而造成的“跨页”问题。</strong></p><p>垂直拆分在数据库设计之初就会考虑，尽量在系统上线之前调整。已经上线的项目，做这种操作是要慎重考虑的。</p></li><li><h4 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h4><p>将一个表中的数据，按照关键字(例如：ID)对一个具体的数字取模，得到的余数就是需要存放到的新表的位置。</p><p>水平分表就是把一个表里的数据分配到多个表里去，但是每个库的表结构一样，只不过每个库表存放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义就是将数据均匀的放到更多的库里，然后用更多的库来抗更高的并发，还可以通过多个库的容量来扩容。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtin7sm0xj31tc0quhdv.jpg" alt></p><h3 id="数据分库"><a href="#数据分库" class="headerlink" title="数据分库"></a>数据分库</h3><p>每个物理数据库支持数据都是有限的，每一次的数据库请求都会产生一次数据库链接，当一个库无法支持更多访问的时候，我们会把原来的单个数据库分成多个，帮助分担压力。</p><ul><li>根据业务不同分库，这种情况都会把主营业务和其他功能分开。例如可以分为订单数据库，核算数据库，评论数据库。</li><li>根据冷热数据进行分库，用数据访问频率来划分，例如：近一个月的交易数据属于高频数据，2-6 个月的交易数据属于中频数据，大于 6 个月的数据属于低频数据。</li><li>根据访问数据的地域/时间范围进行分库。</li></ul><p><strong>range和hash的优缺点</strong></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtiwjec6pj30yw09418a.jpg" alt></p><p><strong>分库分表会遇到哪些问题</strong></p><ul><li><p>ID：主键不可以使用 UUID，性能太差，如果是文件名啥的可以用，不依赖数据库直接在系统中生成，即UUID.randomUUID().toString.replace(“-“,””)，UUID 实现起来比较方便，但是占用的空间比较大；可以用数据库自增ID，即通过一张表来存放生成的 Sequence，不过效率都不算高。Sequence 表的方式节省了空间，但是单表性能瓶颈，且所有的 ID 都依赖于单表。这里推荐使用snowflake算法。</p></li><li><p>Join：需要做两次查询，把两次查询的结果在应用层做合并。这种做法是最简单的，在应用层设计的时候需要考虑。</p></li><li><p>排序/分页：数据分配到水平的几个表中的时候，做排序和分页或者一些集合操作是不容易的。这里根据经验介绍两种方法。</p><ol><li><p>对分表的数据先进行排序/分页/聚合，再进行合并。</p></li><li><p>对分表的数据先进行合并再做排序/分页/聚合。</p></li></ol></li><li><p>事务：存在分布式事务的可能，需要考虑补偿事务或者用 TCC(Try Confirm Cancel)协助完成。</p></li></ul><hr><h2 id="如何对数据库进行扩容？"><a href="#如何对数据库进行扩容？" class="headerlink" title="如何对数据库进行扩容？"></a>如何对数据库进行扩容？</h2><p>分库之后的数据库会遇到数据扩容或者数据迁移的情况。这里推荐两种数据库扩容的方案。</p><ul><li><h3 id="主从数据库扩容"><a href="#主从数据库扩容" class="headerlink" title="主从数据库扩容"></a>主从数据库扩容</h3><p>我们这里假设有两个数据库集群，每个集群分别有 M1 S1 和 M2 S2 互为主备。</p><p>由于 M1 和 S1 互为主备所以数据是一样的，M2 和 S2 同样。把原有的 ID %2 模式切换成 ID %4 模式，也就是把两个数据集群扩充到 4 个数据库集群。</p><p>负载均衡器直接把数据路由到原来两个 S1 和 S2 上面，同时 S1 和 S2 会停止与 M1 和 M2 的数据同步，单独作为主库(写操作)存在。</p><p>这些修改不需要重启数据库服务，只需要修改代理配置就可以完成。由于 M1 M2 S1 S2 中会存在一些冗余的数据，可以后台起服务将这些冗余数据删除，不会影响数据使用。</p><p>此时，再考虑数据库可用性，将扩展后的 4 个主库进行主备操作，针对每个主库都建立对应的从库，前者负责写操作，后者负责读操作。下次如果需要扩容也可以按照类似的操作进行。</p></li><li><h3 id="双写数据库扩容"><a href="#双写数据库扩容" class="headerlink" title="双写数据库扩容"></a>双写数据库扩容</h3><p>在没有数据库主从配置的情况下的扩容，假设有数据库 M1 M2，需要对目前的两个数据库做扩容，扩容之后是 4 个库。新增的库是 M3，M4 路由的方式分别是 ID%2=0 和 ID%2=1。</p><p>这个时候新的数据会同时进入 M1 M2 M3 M4 四个库中，而老数据的使用依旧从 M1 M2 中获取。</p><p>与此同时，后台服务对 M1 M3，M2 M4 做数据同步，建议先做全量同步再做数据校验。</p><p>当完成数据同步之后，四个库的数据保持一致了，修改负载均衡代理的配置为 ID%4 的模式。此时扩容就完成了，从原来的 2 个数据库扩展成 4 个数据库。</p><p>当然会存在部分的数据冗余，需要像上面一个方案一样通过后台服务删除这些冗余数据，删除的过程不会影响业务。</p></li></ul><hr><h2 id="用过哪些分库分表的中间件？"><a href="#用过哪些分库分表的中间件？" class="headerlink" title="用过哪些分库分表的中间件？"></a>用过哪些分库分表的中间件？</h2><p><strong>sharding-jdbc 和 mycat</strong>。</p><p>sharding-jdbc是基于client层的，优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高。缺点是如果遇到升级啥的需要各个系统都重新升级再发布。</p><p>mycat是基于proxy层的，优点在于各个项目是透明的，直接访问中间件就可以了，升级维护啥的自己在中间件那里搞就行了。缺点是需要部署，自己维护一套中间件，运维成本高。</p><h2 id="不同的中间件有什么优缺点？"><a href="#不同的中间件有什么优缺点？" class="headerlink" title="不同的中间件有什么优缺点？"></a>不同的中间件有什么优缺点？</h2><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbthfnw403j30yk070k3g.jpg" alt></p><hr><h2 id="如何把单库单表的系统迁移到分库分表？"><a href="#如何把单库单表的系统迁移到分库分表？" class="headerlink" title="如何把单库单表的系统迁移到分库分表？"></a>如何把单库单表的系统迁移到分库分表？</h2><ol><li><h3 id="停机迁移"><a href="#停机迁移" class="headerlink" title="停机迁移"></a>停机迁移</h3><p>发布公告，凌晨0点～2点维护系统，暂停使用。</p><p>数据迁移，修改配置，验证测试。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtrd56mz7j31400k84qp.jpg" alt></p></li></ol><ol start="2"><li><h3 id="不停机双写迁移"><a href="#不停机双写迁移" class="headerlink" title="不停机双写迁移"></a>不停机双写迁移</h3><p>通过修改配置实现在系统写入单库单表的同时，也将数据发送到mycat，往分库分表中写入数据。</p><p>此时还会启动一个后台数据迁移临时工具来将历史数据同步到分库分表中，将历史数据写入分库分表前，先查询分库分表中是否存在，如果不存在，直接写入，如果存在，则通过查询比较两个数据的时间戳，将更新的数据保留在分库分表中。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbtrsa3jy3j31300n64qp.jpg" alt></p></li></ol><hr><h2 id="分库分表以后ID主键如何处理？"><a href="#分库分表以后ID主键如何处理？" class="headerlink" title="分库分表以后ID主键如何处理？"></a>分库分表以后ID主键如何处理？</h2><p>推荐使用Snowflake算法，这是 Twitter 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。</p><p>其核心思想是：生成一个64位的long型ID，其中第一位是符号位0，后面使用 41bit 作为毫秒数，10bit 作为机器的 ID(5 个 bit 是数据中心(机房)，5 个 bit 的机器 ID)，12bit 作为毫秒内的流水号(意味着每个节点在每毫秒可以产生 4096 个 ID)。</p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbushxzxnlj30go05bdg1.jpg" alt></p><hr><h2 id="如何实现mysql的读写分离？"><a href="#如何实现mysql的读写分离？" class="headerlink" title="如何实现mysql的读写分离？"></a>如何实现mysql的读写分离？</h2><p>其实很简单，就是基于主从复制架构，搞一个主库，挂多个从库，我们单单只是写主库，主库会自动把数据同步到从库上去，从库只负责读，借此来分担数据库读压力。</p><h2 id="mysql主从复制的原理？"><a href="#mysql主从复制的原理？" class="headerlink" title="mysql主从复制的原理？"></a>mysql主从复制的原理？</h2><ol><li>mysql里有一个概念-binlog日志，每个增删改操作在操作数据的同时，还会维护一个日志文件，记录这些操作。</li><li>从库连接到主库之后，从库有一个IO线程，将主库的binlog日志拷贝到自己本地，写入relay(中继)日志中。</li><li>接着从库中有一个SQL线程会从relay日志中读取binlog日志，然后执行其中的内容，使主从数据保持一致。</li></ol><p><strong>需要注意的问题（数据延迟和数据丢失）</strong></p><p><img src="https://tva1.sinaimg.cn/large/0082zybply1gbvrsjdv6wj316c0dcwvw.jpg" alt></p><ol><li>从库同步主库的过程是串行化的，也就是说主库上并行的操作在从库上会串行执行。</li><li>由于从库拷贝主库日志以及串行执行的特点，在高并发的场景下，从库的数据同步会有延迟。</li><li>如果主库突然宕机，数据恰好还没同步到从库，导致有些数据在从库里是没有的，造成数据丢失。</li></ol><p><strong>如何解决？</strong></p><p>mysql在这一块有两个机制，一个是<strong>半同步复制</strong>，解决数据丢失问题。一个是<strong>并行复制</strong>，缓解数据延时问题。</p><ul><li>所谓半同步复制（semi-sync）指的就是主库写入binlog日志后，就会立即将数据同步到从库。从库将日志写入到relay日志后，会返回ack给主库，主库收到至少一个ack之后才会认为写操作完成了。</li><li>所谓并行复制，指的是从库开启多个SQL线程，并行读取relay日志进行多库并发重放，有必要让DBA开启并行复制，不过并行复制的意义并不大，并发高了以后生产环境还会有延时问题。</li></ul><p><strong>有没有更好的方法解决主从数据延时问题（重点）</strong></p><ol><li>分库，把一个主库拆分成多个主库，降低主库的写并发，使得延迟时间可以忽略不计。</li><li>重写代码，插入数据成功后直接修改数据，不要查询（因为修改数据在主库，查询在从库）。</li><li>如果确实存在数据写入后立马就要查到，可以对这个查询设置直连主库（不推荐，失去读写分离的意义）。</li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>因为数据量的上升，为了提高性能会对系统进行分表分库。</li><li>从分表来说，有水平分表和垂直分表两种方式。</li><li>从分库来说，可以根据业务，冷热数据等来进行分库，分库以后通过主从库来实现读写分离。</li><li>如果对分库之后数据库做扩容，有两种方式，主从数据库扩容和双写数据库扩容。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要分库分表？&quot;&gt;&lt;a href=&quot;#为什么要分库分表？&quot; class=&quot;headerlink&quot; title=&quot;为什么要分库分表？&quot;&gt;&lt;/a&gt;为什么要分库分表？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据库的数据会随着业务的发展而不断增多，对数据操作的开销也会越来越大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;物理服务器的资源有限（CPU、磁盘、内存、IO）最终数据库所能承载的数据量和数据处理能力遇到瓶颈。&lt;/p&gt;
&lt;p&gt;换句话说需要合理的数据库架构来存放不断增长的数据，这个就是分库分表的设计初衷。目的就是为了缓解数据库的压力，最大限度提高数据操作的效率。&lt;/p&gt;
&lt;p&gt;比如单表数据量太大（500w以上），会极大的影响SQL的执行性能。
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
    
      <category term="数据库" scheme="https://lishaojie1993.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Sub-table" scheme="https://lishaojie1993.github.io/tags/Sub-table/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引,B+Tree详解</title>
    <link href="https://lishaojie1993.github.io/2019/03/16/BTree/"/>
    <id>https://lishaojie1993.github.io/2019/03/16/BTree/</id>
    <published>2019-03-16T15:00:13.000Z</published>
    <updated>2020-01-17T05:08:13.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql索引？"><a href="#Mysql索引？" class="headerlink" title="Mysql索引？"></a>Mysql索引？</h2><h3 id="索引是什么？"><a href="#索引是什么？" class="headerlink" title="索引是什么？"></a>索引是什么？</h3><p>索引是为了加速对表中数据行的检索而创建的一种分散存储的<strong>数据结构</strong>。</p><h3 id="为什么要创建索引？"><a href="#为什么要创建索引？" class="headerlink" title="为什么要创建索引？"></a>为什么要创建索引？</h3><ol><li>创建索引可以大大提高系统的查询性能。</li><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li><li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面。</li><li>在使用分组喝排序子句进行数据检索时，同样可以显著减少查询中分组喝排序的时间。</li><li>通过使用索引，可以在查询过程中，使用优化隐藏器，提高系统的性能。</li></ol><a id="more"></a><h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如要建立聚集索引，则需要空间更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。</li></ol><h3 id="适合添加索引的字段"><a href="#适合添加索引的字段" class="headerlink" title="适合添加索引的字段"></a>适合添加索引的字段</h3><p>经常需要搜索的列、主键、外键、经常需要范围查询的列、经常需要排序的列、经常使用的where子句的列。</p><p>注意：建立索引一般按照select的where条件来建立，比如条件是where f1 and f2，需要在f1、f2上同时建立。</p><h3 id="不适合添加索引的字段"><a href="#不适合添加索引的字段" class="headerlink" title="不适合添加索引的字段"></a>不适合添加索引的字段</h3><p>查询中很少使用的字段、区分度不高的列、text,image,bit等数据量大的列、修改性能大于检索性能不要加。</p><h2 id="二叉树的缺陷"><a href="#二叉树的缺陷" class="headerlink" title="二叉树的缺陷"></a>二叉树的缺陷</h2><p><strong>搜索效率不足，树的深度不可控。</strong>（树的深度决定着搜索时IO次数）</p><p><strong>节点数据内容太少。</strong>（没有很好的利用系统和磁盘的数据交换特性）</p><h2 id="B-树的特点"><a href="#B-树的特点" class="headerlink" title="B-树的特点"></a>B-树的特点</h2><p>B-树是一种多路平衡二叉树，相比于二叉树大大降低了树的高度，减少了磁盘IO。</p><h2 id="B-树的特点-1"><a href="#B-树的特点-1" class="headerlink" title="B+树的特点"></a>B+树的特点</h2><ol><li>每一个根节点的元素都出现在子节点中，是子节点的最大（或最小）元素。</li><li>根节点的最大元素就是整个B+树的最大元素，无论插入删除多少元素，始终保持最大元素在根节点中。</li><li>由于特点1，所以叶子节点包含了全量的元素信息。</li><li>每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。</li></ol><h3 id="卫星数据的位置"><a href="#卫星数据的位置" class="headerlink" title="卫星数据的位置"></a>卫星数据的位置</h3><p>在B-树中，无论中间节点还是叶子节点都带有卫星数据。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gay4wwcz3lj30ji0brae3.jpg" alt></p><p>在B+树中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gay4x092ahj30jk0bfjv0.jpg" alt></p><p>PS：在数据库的聚集索引(Clustered Index)中，叶子节点直接包含卫星数据；在非聚集索引(NonClustered Index)中，叶子节点带有指向卫星数据的指针。</p><h3 id="B-树的优点"><a href="#B-树的优点" class="headerlink" title="B+树的优点"></a>B+树的优点</h3><ul><li>B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的元素，这就意味着数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询时IO次数更少。</li><li>B+树的查找性能更稳定，因为B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，所以B-树的查找性能不如B+树稳定。</li><li>在范围查找方面，B-树只能依靠繁琐的中序遍历，反观B+树则要简单的多，只需要在链表上做遍历即可。</li></ul><p><strong>综上所述，B+树相比于B-树的优势有三个</strong></p><ol><li>单一节点存储更多的元素，使得查询的IO次数更少。</li><li>所有查询都要查找到子节点，查询性能稳定。</li><li>所有叶子节点形成有序链表，便于范围查询。</li></ol><h2 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gay93ok47nj30sz0gj45e.jpg" alt></p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gay94rzzm0j30sy0ef47q.jpg" alt></p><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gay95n2xzmj30sp0i4gyc.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mysql索引？&quot;&gt;&lt;a href=&quot;#Mysql索引？&quot; class=&quot;headerlink&quot; title=&quot;Mysql索引？&quot;&gt;&lt;/a&gt;Mysql索引？&lt;/h2&gt;&lt;h3 id=&quot;索引是什么？&quot;&gt;&lt;a href=&quot;#索引是什么？&quot; class=&quot;headerlink&quot; title=&quot;索引是什么？&quot;&gt;&lt;/a&gt;索引是什么？&lt;/h3&gt;&lt;p&gt;索引是为了加速对表中数据行的检索而创建的一种分散存储的&lt;strong&gt;数据结构&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;为什么要创建索引？&quot;&gt;&lt;a href=&quot;#为什么要创建索引？&quot; class=&quot;headerlink&quot; title=&quot;为什么要创建索引？&quot;&gt;&lt;/a&gt;为什么要创建索引？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;创建索引可以大大提高系统的查询性能。&lt;/li&gt;
&lt;li&gt;通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。&lt;/li&gt;
&lt;li&gt;可以加速表和表之间的连接，特别是在实现数据的参考完整性方面。&lt;/li&gt;
&lt;li&gt;在使用分组喝排序子句进行数据检索时，同样可以显著减少查询中分组喝排序的时间。&lt;/li&gt;
&lt;li&gt;通过使用索引，可以在查询过程中，使用优化隐藏器，提高系统的性能。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
      <category term="数据结构" scheme="https://lishaojie1993.github.io/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://lishaojie1993.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="B+Tree" scheme="https://lishaojie1993.github.io/tags/B-Tree/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字解析</title>
    <link href="https://lishaojie1993.github.io/2019/03/15/volatile/"/>
    <id>https://lishaojie1993.github.io/2019/03/15/volatile/</id>
    <published>2019-03-15T14:56:30.000Z</published>
    <updated>2020-01-16T15:21:55.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="volatile的两大特性"><a href="#volatile的两大特性" class="headerlink" title="volatile的两大特性"></a>volatile的两大特性</h2><ol><li>保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。（先行发生原则）</li><li>阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。</li></ol><h2 id="Java内存模型JMM"><a href="#Java内存模型JMM" class="headerlink" title="Java内存模型JMM"></a>Java内存模型JMM</h2><p>Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。<a id="more"></a></p><p>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</p><h3 id="主内存（Main-Memory）"><a href="#主内存（Main-Memory）" class="headerlink" title="主内存（Main Memory）"></a>主内存（Main Memory）</h3><p>主内存可以简单理解为计算机当中的内存，但又不完全等同。主内存被所有的线程所共享，对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。</p><h3 id="工作内存（Working-Memory）"><a href="#工作内存（Working-Memory）" class="headerlink" title="工作内存（Working Memory）"></a>工作内存（Working Memory）</h3><p>工作内存可以简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。</p><h3 id="为什么所有的线程不直接操作主内存？"><a href="#为什么所有的线程不直接操作主内存？" class="headerlink" title="为什么所有的线程不直接操作主内存？"></a>为什么所有的线程不直接操作主内存？</h3><p>直接操作主内存太慢了，工作内存类似于高速缓存，访问速度更快。</p><h2 id="volatile的出现"><a href="#volatile的出现" class="headerlink" title="volatile的出现"></a>volatile的出现</h2><p>多线程的情况下，由于工作内存所更新的变量不会立即同步到主内存，为了防止产生错误的结果，可以使用同步锁来保证线程安全，但是对程序的性能影响太大，所以产生了volatile。</p><h3 id="volatile的可见性"><a href="#volatile的可见性" class="headerlink" title="volatile的可见性"></a>volatile的可见性</h3><p>当一个线程修改了变量的值，新的值会立刻同步到主内存当中。而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。为什么volatile关键字可以有这样的特性？这得益于java语言的<strong>先行发生原则</strong>（happens-before）。</p><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>在计算机科学中，先行发生原则是两个事件的结果之间的关系，如果一个事件发生在另一个事件之前，结果必须反映，即使这些事件实际上是乱序执行的（通常是优化程序流程）。</p><p>这里所谓的事件，实际上就是各种指令操作，比如读操作、写操作、初始化操作、锁操作等等。先行发生原则作用于很多场景下，包括同步锁、线程启动、线程终止、volatile。</p><h4 id="volatile的适用范围"><a href="#volatile的适用范围" class="headerlink" title="volatile的适用范围"></a>volatile的适用范围</h4><ol><li><p><strong>运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//开启10个线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">new</span> Thread(</span><br><span class="line">      <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">              Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每个线程当中让count值自增100次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">100</span>;j++)&#123;</span><br><span class="line">              count++;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(<span class="string">"count="</span>+count);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中的实际值要小于1000.</p></li><li><p><strong>变量不需要与其他的状态变量共同参与不变约束。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> start = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">int</span> end = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>线程A执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (start &lt; end)&#123;</span><br><span class="line"> <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程B执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start+=<span class="number">3</span>;</span><br><span class="line">end+=<span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>这种情况下，一旦在线程A的循环中执行了线程B，start有可能先更新成6，造成了一瞬间 start == end，从而跳出while循环的可能性。</p></li></ol><h4 id="什么是指令重排？"><a href="#什么是指令重排？" class="headerlink" title="什么是指令重排？"></a>什么是指令重排？</h4><p>指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。</p><h4 id="指令重排的目的"><a href="#指令重排的目的" class="headerlink" title="指令重排的目的"></a>指令重排的目的</h4><p>为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果。</p><h3 id="volatile的内存屏障"><a href="#volatile的内存屏障" class="headerlink" title="volatile的内存屏障"></a>volatile的内存屏障</h3><h4 id="什么是内存屏障？"><a href="#什么是内存屏障？" class="headerlink" title="什么是内存屏障？"></a>什么是内存屏障？</h4><p>内存屏障也称为内存栅栏或栅栏指令，是一种屏障指令，它使CPU或编译器对屏障指令之前和之后发出的内存操作执行一个排序约束。 这通常意味着在屏障之前发布的操作被保证在屏障之后发布的操作之前执行。</p><h4 id="内存屏障的-4-种类型"><a href="#内存屏障的-4-种类型" class="headerlink" title="内存屏障的 4 种类型"></a>内存屏障的 4 种类型</h4><p><strong>LoadLoad屏障</strong>：</p><p>抽象场景：Load1; LoadLoad; Load2</p><p>Load1 和 Load2 代表两条读取指令。在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</p><p><strong>StoreStore屏障：</strong></p><p>抽象场景：Store1; StoreStore; Store2</p><p>Store1 和 Store2代表两条写入指令。在Store2写入执行前，保证Store1的写入操作对其它处理器可见</p><p><strong>LoadStore屏障：</strong></p><p>抽象场景：Load1; LoadStore; Store2</p><p>在Store2被写入前，保证Load1要读取的数据被读取完毕。</p><p><strong>StoreLoad屏障：</strong></p><p>抽象场景：Store1; StoreLoad; Load2</p><p>在Load2读取操作执行前，保证Store1的写入对所有处理器可见。StoreLoad屏障的开销是四种屏障中最大的。</p><h4 id="volatile如何防止指令重排"><a href="#volatile如何防止指令重排" class="headerlink" title="volatile如何防止指令重排"></a>volatile如何防止指令重排</h4><p>在一个变量被volatile修饰后，JVM会为我们做两件事：</p><ol><li>在每个volatile写操作前插入<strong>StoreStore</strong>屏障，在写操作后插入<strong>StoreLoad</strong>屏障。</li><li>在每个volatile读操作前插入<strong>LoadLoad</strong>屏障，在读操作后插入<strong>LoadStore</strong>屏障。</li></ol><p>从而成功阻止了指令重排序。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;volatile的两大特性&quot;&gt;&lt;a href=&quot;#volatile的两大特性&quot; class=&quot;headerlink&quot; title=&quot;volatile的两大特性&quot;&gt;&lt;/a&gt;volatile的两大特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;保证变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。（先行发生原则）&lt;/li&gt;
&lt;li&gt;阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Java内存模型JMM&quot;&gt;&lt;a href=&quot;#Java内存模型JMM&quot; class=&quot;headerlink&quot; title=&quot;Java内存模型JMM&quot;&gt;&lt;/a&gt;Java内存模型JMM&lt;/h2&gt;&lt;p&gt;Java内存模型(即Java Memory Model，简称JMM)本身是一种抽象的概念，并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
    
      <category term="高并发" scheme="https://lishaojie1993.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="volatile" scheme="https://lishaojie1993.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>分布式缓存-Redis</title>
    <link href="https://lishaojie1993.github.io/2019/03/12/redis/"/>
    <id>https://lishaojie1993.github.io/2019/03/12/redis/</id>
    <published>2019-03-12T15:46:44.000Z</published>
    <updated>2020-02-14T16:18:37.938Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis单线程模型原理剖析？"><a href="#redis单线程模型原理剖析？" class="headerlink" title="redis单线程模型原理剖析？"></a>redis单线程模型原理剖析？</h2><p>redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。</p><h2 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h2><ol><li>纯内存操作。</li><li>核心是基于非阻塞的IO多路复用机制。</li><li>单线程——避免了多线程的频繁上下文切换问题。</li><li>Resp协议。<a id="more"></a></li></ol><h2 id="使用redis有什么缺点？"><a href="#使用redis有什么缺点？" class="headerlink" title="使用redis有什么缺点？"></a>使用redis有什么缺点？</h2><ul><li>缓存和数据库双写一致性问题</li><li>缓存雪崩、缓存击穿</li><li>缓存的并发竞争</li></ul><h2 id="redis支持的数据类型和使用场景"><a href="#redis支持的数据类型和使用场景" class="headerlink" title="redis支持的数据类型和使用场景"></a>redis支持的数据类型和使用场景</h2><ol><li><p>string</p><p>最基本的类型，普通的set和get，做简单的key-value缓存。</p></li><li><p>hash</p><p>类似map的一种结构，特别适合用存储对象，可以仅仅修改这个对象中的某个字段。</p></li><li><p>list</p><p>有序列表，这个是可以玩出很多花样的：</p><p>比如可以基于redis的list实现简单的高性能分页，类似于微博的那种一直下拉。</p><p>还可以搞个简单的消息队列，从list头进去，从list尾巴取出来。</p></li><li><p>set</p><p>无序集合，自动去重。</p><p>如果某个系统部署在多台机器上，可以基于redis实现全局的set去重。</p><p>还可以基于set玩交集，并集，差集的操作，比如利用交集，可以查看两个人的粉丝列表中的共同好友。</p></li><li><p>sorted set</p><p>有序集合，自动去重。</p><p>这个也可以玩很多花样，写数据进去的时候给一个分数，自动根据分数排序，可以自定义排序规则。</p><p>比如想根据数据的时间排序，那么在写入数据的时候把时间作为分数，这样就会按时间排序了。</p><p>排行榜：将每个用户以及对应的分数写入进去，会自动排序，可以查看前几名的结果。</p><p>zadd board 85 jack</p><p>zadd board 72 tom</p><p>zadd board 96 jerry</p><p>zrevrange board 0 2：可以查看前三名的排序结果</p><p>zrank board tom：返回3，意思是tom排名第3</p></li></ol><hr><h2 id="redis的过期策略有哪些"><a href="#redis的过期策略有哪些" class="headerlink" title="redis的过期策略有哪些"></a>redis的过期策略有哪些</h2><p><strong>定期删除+惰性删除</strong></p><p>所谓<strong>定期删除</strong>，指的是redis默认每隔100ms就随机抽取一些过期时间的key，检测是否过期，如果过期就删除。注意：这里redis不是遍历所有过期的key（CPU负载太高），而是随机抽取。</p><p>所谓<strong>惰性删除</strong>，指的是定期删除可能会导致很多过期的key到了时间也没被删除，所以在获取某个key的时候，redis会查一下这个key是否过期，如果过期了此时就会删除，不会返回结果。</p><p>产生问题：如果定期删除漏掉了很多过期key没删，惰性删除是用到的时候才删，如果过期了并且一直没用到就会导致有大量的过期key堆积，这时候就需要走<strong>内存淘汰机制</strong>了。</p><ol><li>no-enviction（驱逐）：禁止驱逐数据，再写入会报错。<strong>（默认，应该没人用）</strong></li><li>allkeys-lru：从数据集中挑选最近最少使用的数据淘汰。<strong>（推荐使用）</strong></li><li>allkeys-random：从数据集中任意选择数据淘汰。</li><li>volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</li><li>volatile-ttl：从<code>已设置过期时间的</code>数据集中挑选<code>将要过期的</code>数据淘汰。</li><li>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</li></ol><hr><h2 id="怎么保证redis的高并发-amp-高可用？"><a href="#怎么保证redis的高并发-amp-高可用？" class="headerlink" title="怎么保证redis的高并发&amp;高可用？"></a>怎么保证redis的高并发&amp;高可用？</h2><p>redis高并发：采用<strong>主从架构</strong>，一主多从，一般来说，很多项目其实就足够了，单主用来写入数据，单机几万QPS，多从用来查询数据，多个从实例可以提供每秒上10万的QPS。如果redis高并发的同时还需要容纳大量的数据：几十G甚至几百G的数据，这样的话就需要采用redis集群了，还能提供每秒几十万的读写并发。</p><p>redis高可用：如果做主从架构部署，其实加上<strong>哨兵</strong>就可以了，任何一个实例宕机，都会自动切换。</p><h3 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h3><p>主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑10+的<strong>读QPS</strong></p><p>首先考虑读写分离，做成主从架构，一主多从，主负责写，并且将数据同步到其他slave节点，从节点负责读，所有的读请求都走从节点。好处是可以水平扩容，就是说如果QPS再增加，只需要继续增加slave就可以了。 </p><h4 id="主从复制的核心原理"><a href="#主从复制的核心原理" class="headerlink" title="主从复制的核心原理"></a>主从复制的核心原理</h4><p>当启动一个slave的时候，该节点会发送一个PSYNC命令给master，如果这是slave的重新连接，master仅仅会发送给slave部分缺少的数据进行<strong>增量复制</strong>，如果这是slave第一次连接master，会触发一次<strong>全量复制</strong>。</p><p>官方解释：</p><ol><li>slave启动时，仅仅保存master的host和ip（redis.conf中配置的），此时复制流程还没开始。</li><li>slave内部有个定时任务，每秒都会check是否有新的master要连接和复制，如果发现则建立网络连接。</li><li>slave发送ping给master，如果master配置了requirepass，那么slave必须发送masterauth口令过去认证。</li><li>master第一次执行全量复制，将所有数据发送给slave。</li><li>master后续还会持续将写命令异步发送给slave。</li></ol><p>全量复制：开始full resynchronized的时候，master会启动一个后台线程，生成一份RDB快照文件，同时还会将从客户端收到的所有写命令缓存在内存中。RDB文件生成完毕以后，master会将这个RDB发送给slave，slave会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着master会将内存中缓存的写命令发送给slave，slave来同步这些数据。</p><p>增量复制：master根据slave发送的psync中的offset，在backlog中查找到部分丢失的数据，发送给slave。</p><h4 id="主从复制的断点续传"><a href="#主从复制的断点续传" class="headerlink" title="主从复制的断点续传"></a>主从复制的断点续传</h4><p>从redis2.8开始就支持主从复制的断点续传了。在主从复制过程中，如果网络连接断掉了，可以接着上次复制的地方继续复制，而不是重新开始复制。master会在内存中维护一个backlog，master和slave都会保存一个复制数据的replica offset和一个master run id，offset就是保存在backlog中的。如果master和slave网络中断了，slave会让master从上次的replica offset开始继续复制。但是如果没有找到对应的offset，那么就会执行一次resynchronized。</p><p>官方解释：</p><ol><li>master和slave都会维护一个offset，slave每秒都会上报自己的offect给master，master记录在backlog中，这样才能知道双方数据是否一致。</li><li>master还会维护一个backlog文件，默认是1M大小，给slave复制数据时也会记录在backlog中，主要是用来做全量复制中断后的增量复制的。</li><li>master重启或者加载了之前的RDB数据是会变的，run id也会变，所以slave需要根据不同的run id区分，如果run id不同就需要做全量复制。</li><li>从节点使用psync从master进行复制，发送psync runid offset到master。master会根据自身的情况返回相应的信息，可能是FULLRESYNC runid offset触发全量复制，也可能是CONTINUE触发增量复制。</li></ol><h4 id="无磁盘化复制"><a href="#无磁盘化复制" class="headerlink" title="无磁盘化复制"></a>无磁盘化复制</h4><p>在redis的配置文件中开启无磁盘化复制以后，master会在内存中直接创建rdb文件然后发送给slave，不会保存在本地磁盘。这里不建议开启，开启也很简单，主要涉及到两个参数：repl-diskless-sync no 默认是no，改成yes就可以了，repl-diskless-sync-delay 5 默认是延迟5s在开始复制，因为需要等待更多的slave重新连接。</p><h4 id="过期key处理"><a href="#过期key处理" class="headerlink" title="过期key处理"></a>过期key处理</h4><p>slave不会过期key，只会等待master过期key。</p><p>如果master过期了一个key，或者通过LRU淘汰了一个key，master会模拟一条del命令发送给slave。</p><h4 id="redis的心跳检测机制"><a href="#redis的心跳检测机制" class="headerlink" title="redis的心跳检测机制"></a>redis的心跳检测机制</h4><p>在命令传播阶段，slave每隔一秒向master发送一个心跳，主要用来检测双方的网络连接状态。</p><h4 id="redis的持久化"><a href="#redis的持久化" class="headerlink" title="redis的持久化"></a>redis的持久化</h4><p>如果采用了主从架构，建议必须开启master node的持久化。</p><p>不建议用slave node作为master node的热备，因为那样的话如果关掉master的持久化（RDB和AOF都关闭）可能在master宕机重启的时候数据是空的，然后从节点一复制，slave node的数据也丢了。</p><p>即使slave node可以自动接管master node，也可能哨兵还没有检测到master failure，master node就重启了，还是可能导致上面的所有slave node数据被清空的故障。</p><p><strong>持久化方式RDB和AOF</strong></p><ul><li>RDB持久化机制：通过快照的方式，对redis中的数据进行周期性的持久化。</li><li>AOF持久化机制：通过记录写命令，以append-only模式写入到日志文件中，redis重启时重新构建。</li></ul><p>如果同时开启了RDB和AOF两种持久化机制，在redis重启时会使用AOF来构建数据，因为AOF数据更加完整。</p><p>如果我们想要redis仅仅作为纯内存的缓存来用，可以关掉RDB和AOF持久化机制。</p><p><strong>RDB的优点</strong></p><ol><li>RDB会生成多个数据文件，非常适合做冷备，可以上传到云盘定期维护。</li><li>RDB对redis的性能影响非常小，定期把数据写入到磁盘，使redis保持高性能。</li><li>通过RDB数据文件来做数据恢复更加快速，直接把文件加载到内存即可。</li></ol><p><strong>RDB的缺点</strong></p><ol><li>最大的缺点就是可能造成部分数据丢失。由于RDB是定期备份，可能每隔5分钟甚至更久，如果redis突然宕机，可能会丢失部分数据，所以RDB不适合作为第一优先的恢复方案。</li><li>RDB每次执行快照生成数据文件的时候，如果数据文件特别大，可能会导致redis对客户提供的服务暂停数秒，所以不要让RDB备份的间隔太长，否则每次生成的文件太大，影响redis本身的性能。</li></ol><p><strong>AOF的优点</strong></p><ol><li>AOF可以更好的保护数据不丢失，一般AOF会每隔一秒记录一次，所以最多丢失1秒的数据。</li><li>AOF日志以append-only模式写入，没有磁盘寻址开销，写入性能高，且文件不易破损。</li><li>AOF日志文件过大的时候，出现后台重写操作也不会影响reids客户端的读写效率。</li><li>AOF特别合适误删除的紧急恢复，比如输入了flushall清空了数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall删除，然后再将AOF文件放回去，就可以自动恢复。</li></ol><p><strong>AOF的缺点</strong></p><ol><li>最大的缺点就是做数据恢复的时候会比较慢，做冷备和定期备份不方便，需要手写复杂脚本。</li><li>对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大。</li><li>AOF开启后，支持的QPS会比RDB低，因为每秒一次fsync，不过性能还是很高的。</li><li>如果想保证一条数据都不丢，也是可以的，设置成每写入一条数据就fsync一次，不过性能会大降。</li><li>AOF相比于RDB更加脆弱一些，恢复数据后可能导致跟原来不一样，容易产生bug。</li></ol><p><strong>RDB和AOF到底如何选择</strong></p><ul><li>不要仅仅使用RDB，因为那样会导致丢失很多数据。</li><li>也不要仅仅使用AOF，因为AOF不适合做冷备，恢复数据比较慢还容易产生bug。</li><li>所以综合使用AOF和RDB两种持久化机制，用AOF保证数据不丢失，作为数据恢复的第一选择；用RDB来做不同程度的冷备，在AOF文件都丢失或者损坏不可用的时候，还可以使用RDB快照来进行数据恢复。</li></ul><hr><h3 id="redis的哨兵机制"><a href="#redis的哨兵机制" class="headerlink" title="redis的哨兵机制"></a>redis的哨兵机制</h3><p>sentinal，中文名是哨兵，是redis集群架构中非常重要的一个组件，主要功能如下：</p><ol><li>集群监控：负责监控redis master和slave进程是否正常工作。</li><li>消息通知：如果某个redis实例有故障，哨兵负责发送消息给管理员报警。</li><li>故障转移：如果master挂掉了，会自动转移到slave上。</li><li>配置中心：如果故障转移发生了，把新的master地址通知到客户端。</li></ol><p>哨兵本身也是分布式的，作为一个哨兵集群在运行，互相协同工作。</p><ol><li>故障转移时，判断一个master是否宕机，需要大部分的哨兵同意才行，涉及到分布式选举。</li><li>即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的，保证了系统的高可用性。</li></ol><h4 id="哨兵的核心知识"><a href="#哨兵的核心知识" class="headerlink" title="哨兵的核心知识"></a>哨兵的核心知识</h4><ol><li>哨兵至少需要3个实例，来保证自己的健壮性。</li><li>哨兵+redis主从的部署架构，是不会保证数据零丢失的，只能保证redis集群的高可用。</li><li>对于哨兵+redis主从的复杂架构，尽量在测试和生产环境都进行充足的测试和演练。</li></ol><p><strong>为什么redis哨兵集群少于3个节点无法正常工作</strong></p><p>如果哨兵集群只有两个节点，两个哨兵的majority=2，其中master所在的机器宕机了，这时只剩下一个哨兵，哨兵切换故障需要满足大多数哨兵同意原则，此时没有majority来运行执行故障转移，所以两个哨兵节点不能工作。</p><h4 id="sdown和odown转换机制？"><a href="#sdown和odown转换机制？" class="headerlink" title="sdown和odown转换机制？"></a>sdown和odown转换机制？</h4><p>master宕机有sdown和odown两种失败状态</p><ul><li>sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，就是主观宕机。</li><li>odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，就是客观宕机。</li><li>sdown达成的条件很简单，如果一个哨兵ping一个master，超过了is-master-after-milliseconds指定的毫秒数之后，就主观认为master宕机了</li><li>sdown到odown的转换条件也很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，也就是客观认为master宕机。</li></ul><h4 id="哨兵和slave集群的自动发现机制"><a href="#哨兵和slave集群的自动发现机制" class="headerlink" title="哨兵和slave集群的自动发现机制"></a>哨兵和slave集群的自动发现机制</h4><p>哨兵互相之间的发现，是通过redis的pub/sub系统实现的，每个哨兵都会往_sentinel_:hello channel里发送一个消息，内容是自己的host、ip和runid，还有对这个master的监控配置。每个哨兵也会去监听自己监控的master+slave对应的_sentinel_:hello channel，然后去感到到同样在监听这个master+slave的其他哨兵的存在，每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步。</p><h4 id="slave-master选举算法"><a href="#slave-master选举算法" class="headerlink" title="slave-master选举算法"></a>slave-master选举算法</h4><p>如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来准备升级为master。</p><p><strong>从节点过滤</strong>：判断跟master断开连接的时长</p><p>如果一个slave跟master断开连接已经超过了（down-after-milliseconds的10倍+master宕机的时长），那么slave就被认为不适合选举为master。</p><ol><li>slave配置的优先级（slave-priority=100）</li><li>复制offset</li><li>run id</li></ol><p>说明：</p><ol><li>然后把剩下了的slave按照优先级进行排序，slave priority越低，优先级就越高。</li><li>如果slave priority相同，就看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高。</li><li>如果上面两个条件都相同，那么选择一个run id比较小的那个slave。</li></ol><h4 id="slave配置的自动纠正"><a href="#slave配置的自动纠正" class="headerlink" title="slave配置的自动纠正"></a>slave配置的自动纠正</h4><p>哨兵会自动纠正slave的配置信息。比如某台slave要成为潜在的master候选人，哨兵会确保slave在复制现有的master数据；如果slave连接到了一个错误的master上，比如故障转移后，哨兵会确保它们连接到正确的master上。</p><h4 id="quorum和majority"><a href="#quorum和majority" class="headerlink" title="quorum和majority"></a>quorum和majority</h4><p>每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还要得到majority哨兵的授权，才能正式执行切换。</p><p>如果quorum &lt; majority，比如5个哨兵，majority就是3，quorum设置为2，可以执行切换。</p><p>如果quorum &gt;= majority，比如5个哨兵，设置quorum是5，那么必须5个哨兵都授权才能切换。</p><h4 id="configuration-epoch"><a href="#configuration-epoch" class="headerlink" title="configuration epoch"></a>configuration epoch</h4><p>哨兵进行切换之前，执行切换的那个哨兵从要切换到新的master那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的。如果第一次master切换失败了，那么其他哨兵会等待failover-timeout时间，然后继续执行切换，此时会重新获得一个新的configuration epoch，作为新的version号。</p><h4 id="configuration传播"><a href="#configuration传播" class="headerlink" title="configuration传播"></a>configuration传播</h4><p>哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他哨兵，通过pub/sub消息机制。</p><p>这里version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的，其他的哨兵都是根据版本号的大小来更新自己的master配置。</p><hr><h2 id="异步复制和集群脑裂导致数据丢失"><a href="#异步复制和集群脑裂导致数据丢失" class="headerlink" title="异步复制和集群脑裂导致数据丢失"></a>异步复制和集群脑裂导致数据丢失</h2><p>场景一：异步复制导致的数据丢失</p><p>client往redis master写入数据，master还没来得及复制给slave，此时，master宕机了，哨兵检测到master宕机后，从slave中投票选举出新的master，但是没来得及复制的数据就丢失了。</p><p>场景二：集群脑裂导致的数据丢失</p><p>master出现了网络异常，与其他slave节点失去联系，但没有挂掉，其他slave节点上的哨兵机制重新选举了master，不过此时的client跟旧的master网络是好的，发送了数据到旧的master数据没有得到同步，此时检测到该master有问题，修好网络后作为slave挂在到新的master节点上，但是新的master没有同步网络异常时的数据导致丢失。</p><p><strong>如何降低损失？</strong></p><ul><li>min-slaves-to-write 1</li><li>min-slaves-max-lag 10</li></ul><p>配置说明：要求至少有一个slave，数据复制和同步的延迟不能超过10秒。也就是说一旦所有的slave数据的复制和同步都超过了10秒，这时master就不会再接收写请求了，可以把数据落差保持在可控范围内，减少数据损失。</p><p>上述配置也适合脑裂，master发生脑裂以后，所有slave都不向旧的master发送数据，10秒之后旧master停止接收写请求，同样也可以减少脑裂带来的数据丢失。</p><hr><h2 id="分布式集群-redis-cluster"><a href="#分布式集群-redis-cluster" class="headerlink" title="分布式集群-redis cluster"></a>分布式集群-redis cluster</h2><ol><li>自动将数据进行分片，每个master上放一部分数据。</li><li>提供内置的高可用支持，部分master不可用时，还是可以继续工作的。</li></ol><p>redis cluster可以突破单机redis在海量数据面前的瓶颈。</p><p><strong>redis cluster VS replication+sentinal</strong></p><p>如果数据量很少，只有几个G，主要是承载高并发性能的场景，那么单机足够了。采用主从架构，再搭建一个sentinal集群，保证高可用。如果你的数据量很大，建议使用redis cluster。</p><h3 id="分布式数据存储的核心算法"><a href="#分布式数据存储的核心算法" class="headerlink" title="分布式数据存储的核心算法"></a>分布式数据存储的核心算法</h3><h4 id="最老土的hash算法和弊端"><a href="#最老土的hash算法和弊端" class="headerlink" title="最老土的hash算法和弊端"></a>最老土的hash算法和弊端</h4><p>把请求的数据进行hash运算，对hash值取模（针对master数量）然后放入对应的master节点中，如果某台master宕机了，该节点中的缓存数据就会失效，更严重的是由于master数量少了，导致取模方式改变，新的请求通过取模运算后得不到有效缓存，会造成几乎100%的请求涌入数据库重新生成缓存，这里会涉及到<strong>大量的缓存重建</strong>，这是致命的。</p><h4 id="一致性hash算法-自动缓存迁移"><a href="#一致性hash算法-自动缓存迁移" class="headerlink" title="一致性hash算法(自动缓存迁移)"></a>一致性hash算法(自动缓存迁移)</h4><p>有请求过来以后，同样是把key进行hash运算，然后会把hash值对应在圆环的各个点上，key落在圆环上以后就会顺时针旋转去寻找距离自己最近的master节点，如果任何一个master节点宕机，只有在该master上的缓存会失效，比如有3台master节点，宕机一台，1/3的数据流量会瞬间涌入数据库，重新查询一次，在环上的master节点越多，宕机后失效的数据越少。这只是均匀分布的情况，如有区间存在缓存热点，还是会有弊端。</p><h4 id="一致性hash算法-虚拟节点"><a href="#一致性hash算法-虚拟节点" class="headerlink" title="一致性hash算法+虚拟节点"></a>一致性hash算法+虚拟节点</h4><p>基于一致性hash算法，在各个master节点之间，再创建均匀分布的虚拟节点，在每个区间内，大量的数据都会均匀的分布到不同的节点，不会存在大量的缓存顺时针同时融入一个master内，实现了自动的<strong>负载均衡</strong>。</p><h4 id="hash-slot算法"><a href="#hash-slot算法" class="headerlink" title="hash slot算法"></a>hash slot算法</h4><p>redis cluster有固定的16384个哈希槽，对每个key计算CRC16的值，然后对16384取模，注意不是对机器取模，所以即使有任何一台机器宕机，其他master中的缓存是不受影响的，经过短暂的数据迁移后，会把宕机中的缓存数据均匀分布到其他的master中继续提供服务。而且master slot让node的增加和移除变得很简单，只需要针对机器的个数均匀分配16384个哈希槽就可以了。</p><hr><h3 id="redis集群模式的工作原理"><a href="#redis集群模式的工作原理" class="headerlink" title="redis集群模式的工作原理"></a>redis集群模式的工作原理</h3><h4 id="节点间的内部通信机制"><a href="#节点间的内部通信机制" class="headerlink" title="节点间的内部通信机制"></a>节点间的内部通信机制</h4><p><strong>基础通信原理</strong></p><p>redis cluster节点间采用<strong>gossip</strong>协议进行通信。</p><p>跟集中式不同，不是将元数据（节点信息、故障等）集中存储在某个节点上，而是互相之间不断通信，保持整个集群所有节点的数据是完整的。</p><ul><li>集中式：好处在于，元数据的更新和读取的时效性非常好，一旦有变更，其他节点立刻就能感知到。缺点是所有的元数据的更新全部集中在一个地方，可能导致元数据的存储压力。</li><li>gossip：好处在于，元数据的更新比较分散，更新请求会陆陆续续的打到所有节点上去更新，降低了压力。缺点是元数据的更新有一定的延迟，可能导致集群的一些操作滞后。</li></ul><p>10000端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口，每个节点每隔一段时间都会往另外几个节点发送ping信息，收到后返回pong。通过通信端口结合gossip协议相互交换信息，包括故障信息、节点的增加和删除、hash slot信息等等。</p><p><strong>gossip协议</strong></p><p>gossip协议包含多种消息，包括ping、pong、meet、fail等。</p><ul><li>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始和其他节点进行通信。</li><li>ping：每个节点都会频繁的给其他节点发送ping，其中包含自己的状态还有自己维护集群的元数据，互相通过ping进行元数据的交换和更新。</li><li>pong：返回ping和meet，包含自己的状态和其他信息，也可以用于广播和更新。</li><li>fail：某个节点判断另一个节点fail后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</li></ul><p><strong>ping消息深入</strong></p><p>每个节点每秒会执行10次ping，每次会选择5个最久没有通信的其他节点。如果发现某个节点通信延时达到了cluster_node_timeout，就会立即发送ping，避免数据交换延迟过长。所以cluster_node_timeout可以调节，如果调节比较大，就可以降低发送的频率。每次ping需要带上自己的节点信息，还有就是带上1/10的其他节点信息，发送出去，进行数据交换。至少包含3个其他节点的信息，最多包含（总节点-2）个其他节点信息。</p><hr><p>jedis的运行原理：重定向，计算hash slot，采用smart jedis，在本地维护了一个hash slot -&gt; node的映射表缓存。</p><h4 id="高性能与主备切换原理"><a href="#高性能与主备切换原理" class="headerlink" title="高性能与主备切换原理"></a>高性能与主备切换原理</h4><p>redis cluster的高可用原理，几乎和哨兵是一样的。</p><ol><li><p>判断节点宕机</p><p>如果一个节点认为另外一个节点宕机了，就是pfail，主观宕机。如果多个节点都认为另外一个节点pfail了，那么就是客观宕机fail。节点之间把pfail放在gossip ping中进行通信，超过半数认为pfail就是fail。</p></li><li><p>从节点过滤</p><p>对于宕机的master，从其所有的从节点slave中选择一个切换成master，检查每个slave与宕机的master断开连接的时间，如果超过了（cluster-node-timeout * cluster-slave-validity-factor）将失去选举资格。</p></li><li><p>master选举</p><p>每个从节点都根据自己对master复制数据的offset，来设置一个选举时间，offset越大（复制数据越多），选举时间越靠前，优先进行选举。然后开始进行投票，具体过程和哨兵类似，选举通过成为新的master。</p></li></ol><p>综上所述：redis cluster功能强大，直接集成了replication和sentinal的功能。</p><hr><h2 id="缓存雪崩、缓存穿透、缓存击穿"><a href="#缓存雪崩、缓存穿透、缓存击穿" class="headerlink" title="缓存雪崩、缓存穿透、缓存击穿"></a>缓存雪崩、缓存穿透、缓存击穿</h2><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>定义：指在某一时间段，缓存集体失效。</p><h4 id="造成缓存雪崩的原因"><a href="#造成缓存雪崩的原因" class="headerlink" title="造成缓存雪崩的原因"></a>造成缓存雪崩的原因</h4><ol><li>比如双11零点抢购，大量商品被集中放入到缓存，假设缓存时效为一小时，那么到了凌晨1点的时候缓存就集体失效了，大量的请求会打在数据库上，对数据库来说，就会产生周期性的压力波峰，可能造成缓存雪崩。</li><li>缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</li></ol><h4 id="如何预防缓存雪崩？"><a href="#如何预防缓存雪崩？" class="headerlink" title="如何预防缓存雪崩？"></a>如何预防缓存雪崩？</h4><p>针对缓存集体失效：如果是电商项目，一般是采取不同分类商品，缓存不同周期。在同一分类中的商品，加上一个随机因子。这样能尽可能分散缓存过期时间，而且，热门类目的商品缓存时间长一些，冷门类目的商品缓存时间短一些，也能节省缓存服务的资源。</p><p>针对缓存服务器宕机：redis高可用（主从+哨兵 或者 redis cluster），避免全盘奔溃。</p><h4 id="缓存雪崩了如何恢复？"><a href="#缓存雪崩了如何恢复？" class="headerlink" title="缓存雪崩了如何恢复？"></a>缓存雪崩了如何恢复？</h4><p>本地ehcache缓存+hystrix限流&amp;降级，避免mysql被打死。事后通过redis持久化快速恢复缓存数据。</p><hr><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>定义：是指查询一个数据库一定不存在的数据，请求穿过了缓存，直接打在了数据库。</p><h4 id="造成缓存穿透的原因"><a href="#造成缓存穿透的原因" class="headerlink" title="造成缓存穿透的原因"></a>造成缓存穿透的原因</h4><p>代码bug或者恶意攻击。</p><h4 id="如何预防缓存穿透？"><a href="#如何预防缓存穿透？" class="headerlink" title="如何预防缓存穿透？"></a>如何预防缓存穿透？</h4><p>如果从数据库查询的对象为空，也放入缓存，只是设定的缓存过期时间较短，比如设置为60秒。</p><hr><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>定义：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><h3 id="如何预防缓存击穿？"><a href="#如何预防缓存击穿？" class="headerlink" title="如何预防缓存击穿？"></a>如何预防缓存击穿？</h3><p>这种情况遇到的比较少，真有这种爆款key，设置成永不过期就可以了。</p><hr><h2 id="如何保证缓存与数据库的双写一致性"><a href="#如何保证缓存与数据库的双写一致性" class="headerlink" title="如何保证缓存与数据库的双写一致性"></a>如何保证缓存与数据库的双写一致性</h2><h3 id="先删缓存，再更新数据库"><a href="#先删缓存，再更新数据库" class="headerlink" title="先删缓存，再更新数据库"></a>先删缓存，再更新数据库</h3><p>最经典的缓存+数据库读写的模式：暂存模式（cache aside pattern）</p><ol><li>读的时候先读缓存，缓存没有的话就读数据库，然后把数据库的数据放到缓存，同时返回相应。</li><li>更新的时候，<strong>先删除缓存，再更新数据库</strong>，如果修改数据库失败了，那么数据库中是旧数据，缓存中是空的，不会造成不一致，因为读的时候缓存中没有，还会把旧的数据库数据更新到缓存中。反过来，如果先更改数据库再删除缓存，如果缓存删除失败了，则会导致数据不一致。</li></ol><p>为什么是删除缓存，而不是更新缓存呢？</p><p>原因很简单，很多时候复杂点的缓存场景，不单单是修改了一个值那么简单，而是需要结合多张表去计算才能得到缓存结果，就算真的是简单场景的缓存，也需要看看这个缓存是不是被频繁的使用到，否则只是增加麻烦而已。</p><p>其实删除缓存就是一个lazy计算的思想，不需要每次都做复杂的运算，它被用到的时候再计算就好了。</p><hr><h3 id="高并发场景下的数据不一致"><a href="#高并发场景下的数据不一致" class="headerlink" title="高并发场景下的数据不一致"></a>高并发场景下的数据不一致</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没有修改，一个请求过来，去读缓存，发现缓存空了，去查询数据库，把旧的数据放到了缓存中，然后数据库完成了修改，此时数据库和缓存的数据不一致了。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>把数据库与缓存的更新读取操作进行异步串行化。</p><ul><li>更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个内存队列中。</li><li>读取数据的时候，如果发现数据不在缓存中，那么将进行（重新读取+更新缓存）操作，也根据唯一标识路由并发送到同一个内存队列中。</li></ul><p>一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。</p><p>这样的话，一个数据变更的操作，先删除缓存，然后去更新数据库，但是还没有完成更新；此时如果一个读请求过来，读到了空的缓存，可以先将缓存更新的请求发送到队列中积压，然后同步等待缓存更新完成。</p><p>这里有一个优化点，一个队列中，多个读请求（更新缓存）串在一起是没有意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，就不用再放更新操作进入队列了，直接等待前面的缓存更新完成即可。如果请求还在等待范围内，不断轮询发现可以取到值了就返回，超过等待时长就返回数据库中的旧值。</p><h4 id="解决方案需要注意的问题"><a href="#解决方案需要注意的问题" class="headerlink" title="解决方案需要注意的问题"></a>解决方案需要注意的问题</h4><p><strong>读请求 长时间堵塞</strong></p><p>由于读请求做了非常轻度的异步化，所以一定要注意读超时问题，每个读请求必须在超时时间范围内返回。</p><p>该方案的最大风险在于可能数据更新很频繁，或者包含了对多个数据项的修改，导致队列中积压了大量的更新操作在里面，然后读请求发生了大量的超时，最后导致大量的读请求直接走数据库。一定要提前做好压力测试和真实数据模拟，不过一般来说数据的写频率是很低的，所以队列中积压的应该不会太多。如果真的导致积压过多的话，可以采取增加内存队列的方式来解决。</p><p><strong>读请求 并发量过高</strong></p><p>上述方案有可能突然大量的读请求在几十毫秒内hang在服务器上，看需要几台服务器才能扛得住，所以要计算好每个读请求不要hang太久。</p><p><strong>多服务实例部署的请求路由</strong></p><p>可能这个服务部署了多个实例，那么必须保证，执行数据更新操作以及执行缓存更新操作的请求，都通过nginx服务器路由到相同的服务器实例上。</p><p><strong>热点商品的路由问题</strong></p><p>万一某个商品的读写请求特别高，全部打到相同的机器的相同队列里去了，可能造成某台机器的压力过大。</p><p>因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以更新频率不是太高的话，这个问题影响不是很大，不过的缺可能某些机器的负载高一些。</p><hr><h2 id="如何保证redis并发竞争的数据一致性"><a href="#如何保证redis并发竞争的数据一致性" class="headerlink" title="如何保证redis并发竞争的数据一致性"></a>如何保证redis并发竞争的数据一致性</h2><p>客户端角度：为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。</p><p>服务器角度：采用分布式锁，确保同一时刻只能有一个系统实例在操作某个key，获得分布式锁以后，每次要写之前，先判断当前这个value的时间戳是否比缓存中的时间戳更新，如果更新，可以写入；否则，就不能用旧数据覆盖新数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;redis单线程模型原理剖析？&quot;&gt;&lt;a href=&quot;#redis单线程模型原理剖析？&quot; class=&quot;headerlink&quot; title=&quot;redis单线程模型原理剖析？&quot;&gt;&lt;/a&gt;redis单线程模型原理剖析？&lt;/h2&gt;&lt;p&gt;redis基于reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器——file event handler。这个文件事件处理器是单线程的，所以redis才叫做单线程模型。redis采用IO多路复用机制同时监听多个socket，根据socket上的事件来选择对应的事件处理器来处理这个事件。&lt;/p&gt;
&lt;h2 id=&quot;redis为什么这么快？&quot;&gt;&lt;a href=&quot;#redis为什么这么快？&quot; class=&quot;headerlink&quot; title=&quot;redis为什么这么快？&quot;&gt;&lt;/a&gt;redis为什么这么快？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;纯内存操作。&lt;/li&gt;
&lt;li&gt;核心是基于非阻塞的IO多路复用机制。&lt;/li&gt;
&lt;li&gt;单线程——避免了多线程的频繁上下文切换问题。&lt;/li&gt;
&lt;li&gt;Resp协议。
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
    
      <category term="分布式" scheme="https://lishaojie1993.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="redis" scheme="https://lishaojie1993.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>线程池实现原理与源码分析</title>
    <link href="https://lishaojie1993.github.io/2019/03/11/Thread-Pool/"/>
    <id>https://lishaojie1993.github.io/2019/03/11/Thread-Pool/</id>
    <published>2019-03-11T13:26:44.000Z</published>
    <updated>2020-01-21T12:07:31.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h2><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><ol><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ol><h3 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h3><ol><li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<a id="more"></a></li></ol><p>对应到代码层面就是<code>ThreadPoolExecutor</code>执行<code>execute()</code>方法</p><ol><li>当<kbd>workerCount</kbd> &lt; <kbd>corePoolSize</kbd>，创建新线程执行任务。</li><li>当<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且阻塞队列workQueue未满，把新的任务放入阻塞队列。</li><li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>corePoolSize</kbd>，并且<kbd>workerCount</kbd> &lt; <kbd>maximumPoolSize</kbd>，创建新线程执行任务。</li><li>当workQueue已满，并且<kbd>workerCount</kbd> &gt;= <kbd>maximumPoolSize</kbd>，采取拒绝策略,根据不同的拒绝策略处理,默认拒绝策略是直接抛异常。</li></ol><p>由于创建新线程时（第1步、第3步）需要获取全局锁，所以ThreadPoolExecutor采取上述步骤的总体设计思路，是为了在执行execute()方法时，尽可能地避免获取全局锁（那将会是一个严重的可伸缩瓶颈）。</p><h3 id="线程池状态转换模型"><a href="#线程池状态转换模型" class="headerlink" title="线程池状态转换模型"></a>线程池状态转换模型</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb1qb2e8lbj31lo0jiu0x.jpg" alt></p><ul><li><code>RUNNING</code> 自然是运行状态，指可以接受任务执行队列里的任务</li><li><code>SHUTDOWN</code> 指调用了 <code>shutdown()</code> 方法，不再接受新任务了，但是队列里的任务得执行完毕。</li><li><code>STOP</code> 指调用了 <code>shutdownNow()</code> 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li><li><code>TIDYING</code> 所有任务都执行完毕，在调用 <code>shutdown()/shutdownNow()</code> 中都会尝试更新为这个状态。</li><li><code>TERMINATED</code> 终止状态，当执行 <code>terminated()</code> 后会更新为这个状态。</li></ul><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="创建线程池"><a href="#创建线程池" class="headerlink" title="创建线程池"></a>创建线程池</h3><p>我们可以通过ThreadPoolExecutor的<strong>构造方法</strong>来创建线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">int</span> maximumPoolSize,                              </span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">   TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">   BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">   RejectedExecutionHandler handler)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面介绍一下代码中的参数：</p><ol><li><p>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，如果当前poolSize&lt;corePoolSize时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p></li><li><p>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</p></li><li><p>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p></li><li><p>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p></li><li><p>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ul><li><p>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</p></li><li><p>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</p></li><li><p>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</p></li><li><p>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p></li></ul></li><li><p>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线<br>程设置有意义的名字，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"XX-task-%d"</span>).build();</span><br></pre></td></tr></table></figure></li><li><p>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</p><ul><li>AbortPolicy：直接抛出异常。(默认)</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。</li></ul></li></ol><p>当然，也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化存储不能处理的任务。</p><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</p><p>区别:</p><ul><li>execute()方法用于提交<strong>不需要返回值</strong>的任务;</li><li>submit()方法用于提交<strong>需要返回值</strong>的任务。</li></ul><p>execute方法：</p><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。通过以下代码可知execute()方法输入的任务是一个Runnable类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>submit方法：</p><p>线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方<br>法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(haveReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object s = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line"><span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><ul><li>shutdown()</li><li>shutdownNow()</li></ul><p>它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。</p><p>区别：</p><p>shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</p><p>总结：</p><p>至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</p><h3 id="线程池实例Demo"><a href="#线程池实例Demo" class="headerlink" title="线程池实例Demo"></a>线程池实例Demo</h3><ol><li><p>首先构造一个线程池，用ArrayBlockingQueue作为其等待队列，队列初始化容量为1。该线程池核心容量为 10，最大容量为20，线程存活时间为1分钟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> BlockingQueue blockingQueue=<span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">static</span> ThreadPoolExecutor threadPoolExecutor=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, TimeUnit.MINUTES, blockingQueue);</span><br></pre></td></tr></table></figure></li><li><p>另外构造了一个实现Runable接口的类TaskBusyWithoutResult类，其模拟一个繁忙的任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskBusyWithoutResult</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TaskBusyWithoutResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"线程"</span>+Thread.currentThread()+<span class="string">"开始运行"</span>);</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">10000</span>*<span class="number">10000</span>;</span><br><span class="line">       <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           i--;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"线程"</span>+Thread.currentThread()+<span class="string">"运行结束"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>向线程池提交20个任务，执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> TaskBusyWithoutResult();</span><br><span class="line">        threadPoolExecutor.submit(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="线程池源码分析"><a href="#线程池源码分析" class="headerlink" title="线程池源码分析"></a>线程池源码分析</h2><p><strong>基于JDK1.8</strong></p><h3 id="ctl-变量"><a href="#ctl-变量" class="headerlink" title="ctl 变量"></a>ctl 变量</h3><p>后面execute方法会用到ctl，这个变量是为了把工作线程数量和线程池状态放在一个int型变量存储而设置的一个原子类型的变量。 在ctl中，低位的29位表示工作线程的数量，高位用来表示RUNNING、SHUTDOWN、STOP等状态。上面定义的三个方法只是为了计算得到线程池的状态和工作线程的数量，以及得到ctl。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Packing and unpacking ctl</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h3 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute()方法"></a>execute()方法</h3><ul><li>if (! isRunning(recheck) &amp;&amp; remove(command))这句。由于&amp;&amp;是短路与，意思就是前面如果非真，后面不会执行。所以如果线程池不是Running状态时，才把现成移出工作队列，再使用饱和策略。</li><li>addWorker(command, false)：我们看到有addWorker(command, true)和addWorker(command, false)。true和false分别代表在检查工作线程数量的时候是应该与corePoolSize对比还是应该maximumPoolSize对比。只有第一个if时，也就是当前线程数小于corePoolSize时才用addWorker(command, true)。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//如果提交了空的任务 抛出异常</span></span><br><span class="line"> <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"> <span class="keyword">int</span> c = ctl.get();<span class="comment">//获取当前线程池的状态</span></span><br><span class="line">   <span class="comment">//检查当前工作线程数量是否小于核心线程数量</span></span><br><span class="line"> <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">   <span class="comment">//通过addWorker方法提交任务</span></span><br><span class="line">   <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   c = ctl.get();<span class="comment">//如果提交失败 需要二次检查状态</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//向工作线程提交任务 </span></span><br><span class="line"> <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">   <span class="comment">// 再次检查状态</span></span><br><span class="line">      <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">        reject(command);</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//扩容失败 则拒绝任务</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">   reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWorker-方法"><a href="#addWorker-方法" class="headerlink" title="addWorker()方法"></a>addWorker()方法</h3><p>这个方法是任务提交的一个核心方法，在里面完成了状态检查、新建任务、执行任务等一系列动作，主要工作是在线程池中创建一个新的线程并执行。</p><p>这个方法可以分为两个阶段来看，第一个阶段是判断是否有必要新增一个工作线程，如果有则利用CAS更新工作线程的数量；第二部分是将提交的任务封装成一个工作线程Worker然后加入到线程池的容器中，开始执行新提交的任务。这个Worker在执行完任务后，还会循环地获取工作队列里的任务来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">       retry:</span><br><span class="line">   <span class="comment">//死循环更新状态</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">//获取运行状态</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//检查线程池是否处于关闭状态</span></span><br><span class="line">           <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">               ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                  firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  ! workQueue.isEmpty()))</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   </span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         <span class="comment">//获取当前工作线程数量</span></span><br><span class="line">               <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">       <span class="comment">//如果已经超过corePoolSize获取maximumPoolSize 返回false</span></span><br><span class="line">               <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                   wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       <span class="comment">//CAS增加一个工作线程</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">       <span class="comment">//再次获取状态</span></span><br><span class="line">               c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">       <span class="comment">//如果状态更新失败 则循环更新</span></span><br><span class="line">               <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                   <span class="keyword">continue</span> retry;</span><br><span class="line">               <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">       <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">       Worker w = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           w = <span class="keyword">new</span> Worker(firstTask);<span class="comment">//初始化一个工作线程</span></span><br><span class="line">           <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">           <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获得锁</span></span><br><span class="line">               <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">               mainLock.lock();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                   <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                   <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                   <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                       (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">           <span class="comment">//添加工作这到hashset中保存</span></span><br><span class="line">                       workers.add(w);</span><br><span class="line">                       <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                       <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                           largestPoolSize = s;</span><br><span class="line">                       workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   mainLock.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">       <span class="comment">//工作线程启动 执行第一个任务 就是新提交的任务</span></span><br><span class="line">                   t.start();</span><br><span class="line">                   workerStarted = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">               addWorkerFailed(w);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> workerStarted;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Worker的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker()方法"></a>runWorker()方法</h3><p>在addWorker方法快要结束的地方，调用了t.start()方法，我们知道它实际执行的就是Worker对象的run()方法，而worker的run()方法是这样定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它实际上是将自己委托给线程池的runWorker方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//不断地从blockingQueue获取任务</span></span><br><span class="line">           <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               w.lock();</span><br><span class="line">               <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">               <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">               <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">               <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">               <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                    (Thread.interrupted() &amp;&amp;</span><br><span class="line">                     runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                   !wt.isInterrupted())</span><br><span class="line">                   wt.interrupt();</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//执行beforeExecute方法</span></span><br><span class="line">                   beforeExecute(wt, task);</span><br><span class="line">                   Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//调用Runable的run方法</span></span><br><span class="line">                       task.run();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                       thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// 执行aferExecute方法</span></span><br><span class="line">                       afterExecute(task, thrown);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   task = <span class="keyword">null</span>;</span><br><span class="line">                   w.completedTasks++;</span><br><span class="line">                   w.unlock();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           processWorkerExit(w, completedAbruptly);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下runWorker方法的执行过程：</p><ol><li>while循环中，不断地通过getTask()方法从workerQueue中获取任务</li><li>如果线程池正在停止，则中断线程。否则调用3.</li><li>调用task.run()执行任务；</li><li>如果task为null则跳出循环，执行processWorkerExit()方法，销毁线程workers.remove(w);</li></ol><p>它在不断执行我们提交的任务的run方法。而这个任务可能是我们新提交的，也有可能是从等待队列中获取的。这样就实现了线程池的完成逻辑。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p><strong>创建线程池的5个方法：</strong></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>只有一个线程的线程池，因此所有提交的任务是<strong>顺序执行</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><p>构造方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。</p><p>返回单线程的Executor，将多个任务交给此Exector时，这个线程处理完一个任务后接着处理下一个任务，若该线程出现异常，将会有一个新的线程来替代。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><hr><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>缓存型线程池，先查看池中有没有以前建立的线程，如果有，就重用，如果没有，就建一个新的线程加入池中。如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newCachedThreadPool();</span><br></pre></td></tr></table></figure><p>构造方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>,<span class="comment">//线程池维护线程的最少数量</span></span><br><span class="line">                Integer.MAX_VALUE,<span class="comment">//线程池维护线程的最大数量</span></span><br><span class="line">                <span class="number">60L</span>,<span class="comment">//线程池维护线程所允许的空闲时间，60秒</span></span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">//线程池维护线程所允许的空闲时间的单位</span></span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exe= Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskID=i;</span><br><span class="line">            exe.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"线程ID："</span>+taskID+<span class="string">",执行第 "</span>+j+<span class="string">" 次"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">线程ID：3，执行第 1 次</span><br><span class="line">线程ID：4，执行第 1 次</span><br><span class="line">线程ID：2，执行第 1 次</span><br><span class="line">线程ID：5，执行第 1 次</span><br><span class="line">线程ID：1，执行第 1 次</span><br><span class="line"></span><br><span class="line">线程ID：2，执行第 2 次</span><br><span class="line">线程ID：3，执行第 2 次</span><br><span class="line">线程ID：4，执行第 2 次</span><br><span class="line">线程ID：1，执行第 2 次</span><br><span class="line">线程ID：5，执行第 2 次</span><br><span class="line"></span><br><span class="line">线程ID：2，执行第 3 次</span><br><span class="line">线程ID：3，执行第 3 次</span><br><span class="line">线程ID：4，执行第 3 次</span><br><span class="line">线程ID：5，执行第 3 次</span><br><span class="line">线程ID：1，执行第 3 次</span><br></pre></td></tr></table></figure><p>可以看到执行结果是5个任务在交替进行的</p><p>newCachedThreadPool的总结：</p><ol><li>重用：缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。</li><li>使用场景：缓存型池子通常用于执行一些生存期很短的异步型任务，因此在一些面向连接的daemon型SERVER中用得不多。</li><li>超时：能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout是60s，超过这个IDLE时长，线程实例将被终止及移出池。</li><li>结束：注意，放入CachedThreadPool的线程不必担心其结束，超过TIMEOUT不活动，其会自动被终止。</li></ol><hr><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>定长线程池，可控制线程最大并发数。如果当前需要执行的任务超过池大小，那么多出的任务处于等待状态，直到有空闲下来的线程执行任务，如果当前需要执行的任务小于池大小，空闲的线程也不会去销毁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>构造方法源码：有两个重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                nThreads,<span class="comment">//线程池维护线程的最少数量</span></span><br><span class="line">                nThreads,<span class="comment">//线程池维护线程的最大数量</span></span><br><span class="line">                <span class="number">0L</span>, <span class="comment">//线程池维护线程所允许的空闲时间</span></span><br><span class="line">                TimeUnit.MILLISECONDS,<span class="comment">//线程池维护线程所允许的空闲时间的单位</span></span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService exe = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskID = i;</span><br><span class="line">            exe.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"线程ID："</span> + taskID + <span class="string">"，执行第 "</span> + j + <span class="string">" 次"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">线程ID：2，执行第 1 次</span><br><span class="line">线程ID：1，执行第 1 次</span><br><span class="line">线程ID：3，执行第 1 次</span><br><span class="line"></span><br><span class="line">线程ID：2，执行第 2 次</span><br><span class="line">线程ID：3，执行第 2 次</span><br><span class="line">线程ID：1，执行第 2 次</span><br><span class="line"></span><br><span class="line">线程ID：2，执行第 3 次</span><br><span class="line">线程ID：3，执行第 3 次</span><br><span class="line">线程ID：1，执行第 3 次</span><br><span class="line"></span><br><span class="line">线程ID：4，执行第 1 次</span><br><span class="line">线程ID：5，执行第 1 次</span><br><span class="line">线程ID：4，执行第 2 次</span><br><span class="line"></span><br><span class="line">线程ID：5，执行第 2 次</span><br><span class="line">线程ID：4，执行第 3 次</span><br><span class="line">线程ID：5，执行第 3 次</span><br></pre></td></tr></table></figure><p>创建了一个固定大小的线程池，容量为3，然后循环执行了5个任务。由输出结果可以看到，前3个任务首先执行完，然后空闲下来的线程去执行第4,5个任务。<br>newFixedThreadPool的总结：</p><ol><li>重用：fixedThreadPool与cacheThreadPool差不多，也是能reuse就用，但不能随时建新的线程。</li><li>固定数目：其独特之处在于，任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。</li><li>超时：和cacheThreadPool不同，FixedThreadPool没有IDLE机制（可能也有，但既然文档没提，肯定非常长，类似依赖上层的TCP或UDP IDLE机制之类的）。</li><li>使用场景：所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。</li></ol><hr><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><p>调度型线程池,支持定时及周期性任务执行，也是一个固定长度的线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService exe= Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>构造方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, <span class="comment">// 线程池维护线程的最少数量</span></span><br><span class="line">        Integer.MAX_VALUE, <span class="comment">//线程池维护线程的最大数量</span></span><br><span class="line">        <span class="number">0</span>, <span class="comment">// 线程池维护线程所允许的空闲时间</span></span><br><span class="line">        NANOSECONDS,<span class="comment">//线程池维护线程所允许的空闲时间的单位</span></span><br><span class="line">        <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ScheduledExecutorService exe= Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> taskID=i;</span><br><span class="line">                exe.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"线程："</span>+taskID+<span class="string">",时间："</span>+ LocalDateTime.now()+<span class="string">" 执行一次"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码scheduleAtFixedRate后面的参数 0 表示立即执行，2表示2秒执行一次调度。执行结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">线程：1,时间：2016-12-11T13:09:18.544 执行一次</span><br><span class="line">线程：2,时间：2016-12-11T13:09:18.544 执行一次</span><br><span class="line">线程：3,时间：2016-12-11T13:09:18.544 执行一次</span><br><span class="line"></span><br><span class="line">线程：5,时间：2016-12-11T13:09:20.557 执行一次</span><br><span class="line">线程：1,时间：2016-12-11T13:09:20.557 执行一次</span><br><span class="line">线程：4,时间：2016-12-11T13:09:20.557 执行一次</span><br><span class="line"></span><br><span class="line">线程：4,时间：2016-12-11T13:09:22.572 执行一次</span><br><span class="line">线程：2,时间：2016-12-11T13:09:22.572 执行一次</span><br><span class="line">线程：3,时间：2016-12-11T13:09:22.572 执行一次</span><br><span class="line"></span><br><span class="line">线程：5,时间：2016-12-11T13:09:24.586 执行一次</span><br><span class="line">线程：1,时间：2016-12-11T13:09:24.586 执行一次</span><br><span class="line">线程：2,时间：2016-12-11T13:09:24.586 执行一次</span><br></pre></td></tr></table></figure><p>newScheduledThreadPool的线程池大小只设置了3，所以一次只能执行3个线程，然后可以看到每2秒执行一次任务调度。</p><hr><h3 id="newSingleThreadScheduledPool"><a href="#newSingleThreadScheduledPool" class="headerlink" title="newSingleThreadScheduledPool"></a>newSingleThreadScheduledPool</h3><p>单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果当前线程意外终止，会创建一个新线程继续执行任务，这和我们直接创建线程不同，也和newFixedThreadPool(1)不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService exe= Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><p>构造方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService exe= Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> taskID=i;</span><br><span class="line">            exe.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"线程ID："</span>+taskID+<span class="string">"，执行第 "</span>+j+<span class="string">" 次"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">线程ID：1，执行第 1 次</span><br><span class="line">线程ID：1，执行第 2 次</span><br><span class="line">线程ID：1，执行第 3 次</span><br><span class="line">线程ID：2，执行第 1 次</span><br><span class="line">线程ID：2，执行第 2 次</span><br><span class="line">线程ID：2，执行第 3 次</span><br><span class="line">线程ID：3，执行第 1 次</span><br><span class="line">线程ID：3，执行第 2 次</span><br><span class="line">线程ID：3，执行第 3 次</span><br><span class="line">线程ID：4，执行第 1 次</span><br><span class="line">线程ID：4，执行第 2 次</span><br><span class="line">线程ID：4，执行第 3 次</span><br><span class="line">线程ID：5，执行第 1 次</span><br><span class="line">线程ID：5，执行第 2 次</span><br><span class="line">线程ID：5，执行第 3 次</span><br></pre></td></tr></table></figure><p>每个结果都是相隔0.5秒打印出来的，顺序执行下去。</p><ul><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程池原理&quot;&gt;&lt;a href=&quot;#线程池原理&quot; class=&quot;headerlink&quot; title=&quot;线程池原理&quot;&gt;&lt;/a&gt;线程池原理&lt;/h2&gt;&lt;h3 id=&quot;使用线程池的好处&quot;&gt;&lt;a href=&quot;#使用线程池的好处&quot; class=&quot;headerlink&quot; title=&quot;使用线程池的好处&quot;&gt;&lt;/a&gt;使用线程池的好处&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;降低资源消耗&lt;/strong&gt;。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高响应速度&lt;/strong&gt;。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源,还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;线程池的实现原理&quot;&gt;&lt;a href=&quot;#线程池的实现原理&quot; class=&quot;headerlink&quot; title=&quot;线程池的实现原理&quot;&gt;&lt;/a&gt;线程池的实现原理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。&lt;/li&gt;
&lt;li&gt;线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。&lt;/li&gt;
&lt;li&gt;线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
      <category term="高并发" scheme="https://lishaojie1993.github.io/categories/Java/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="高并发" scheme="https://lishaojie1993.github.io/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程池" scheme="https://lishaojie1993.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>win10系统激活，内附激活码和激活软件</title>
    <link href="https://lishaojie1993.github.io/2019/03/10/win-activation/"/>
    <id>https://lishaojie1993.github.io/2019/03/10/win-activation/</id>
    <published>2019-03-10T14:45:30.000Z</published>
    <updated>2020-01-14T00:55:01.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本文提供两种激活方式，随意选择"><a href="#本文提供两种激活方式，随意选择" class="headerlink" title="本文提供两种激活方式，随意选择"></a>本文提供两种激活方式，随意选择</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><ol><li><p>启动win10点击桌面左下角的开始菜单，点击“设置”图标，选择“更新和安全”，并切换到“激活”选项卡，在此就可以查看到当前系统的激活状态。<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gausj7rd5jj30s40hlabi.jpg" alt></p><a id="more"></a></li><li><p>在开始菜单处点击鼠标右键，选择Windows PowerShell（管理员）。<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gara1vmqssj30aq0icaau.jpg" alt></p></li><li><p>此时将“以管理员身份”打开“MSDOS”窗口，在此界面中输入：slmgr.vbs /upk，按回车进行确定。<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gara4r1m07j30cd040dft.jpg" alt></p></li><li><p>此时弹出窗口显未“已成功卸载了产品密钥”</p></li><li><p>接着输入以下命令：slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</p></li><li><p>弹出窗口提示：“成功的安装了产品密钥”。</p></li><li><p>继续输入以下命令：slmgr /skms zh.us.to</p></li><li><p>弹出窗口提示：“密钥管理服务计算机名成功的设置为zh.us.to”。</p></li><li><p>接下来输入以下命令：slmgr /ato此时将弹出窗口提示：“成功的激活了产品”。</p></li><li><p>最后就可以再次查看当前Win10专业版系统的激活状态啦。</p></li></ol><p>以上只演示了Win10专业版系统的激活方法，如果大家拥有Win10正式版其它系统版本的密钥，也可以利用类似的操作方法进行激活。</p><h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>激活软件下载链接:<a href="https://pan.baidu.com/s/19D-n_3S4Ulqx5VZhbcB6fQ" target="_blank" rel="noopener">https://pan.baidu.com/s/19D-n_3S4Ulqx5VZhbcB6fQ</a>  密码:md2f</p><p>此软件还附带激活Office功能，在我的电脑上右键查看属性，就可以看到系统的激活状态了。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1garaedv33mj30ol0gg75z.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;本文提供两种激活方式，随意选择&quot;&gt;&lt;a href=&quot;#本文提供两种激活方式，随意选择&quot; class=&quot;headerlink&quot; title=&quot;本文提供两种激活方式，随意选择&quot;&gt;&lt;/a&gt;本文提供两种激活方式，随意选择&lt;/h2&gt;&lt;h3 id=&quot;方式一&quot;&gt;&lt;a href=&quot;#方式一&quot; class=&quot;headerlink&quot; title=&quot;方式一&quot;&gt;&lt;/a&gt;方式一&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;启动win10点击桌面左下角的开始菜单，点击“设置”图标，选择“更新和安全”，并切换到“激活”选项卡，在此就可以查看到当前系统的激活状态。&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gausj7rd5jj30s40hlabi.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="System" scheme="https://lishaojie1993.github.io/categories/System/"/>
    
    
      <category term="Windows" scheme="https://lishaojie1993.github.io/tags/Windows/"/>
    
      <category term="activation" scheme="https://lishaojie1993.github.io/tags/activation/"/>
    
  </entry>
  
  <entry>
    <title>Nginx相关</title>
    <link href="https://lishaojie1993.github.io/2018/06/06/nginx/"/>
    <id>https://lishaojie1993.github.io/2018/06/06/nginx/</id>
    <published>2018-06-06T13:32:24.000Z</published>
    <updated>2020-01-16T13:26:35.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Nginx安装配置"><a href="#Nginx安装配置" class="headerlink" title="Nginx安装配置"></a>Nginx安装配置</h2><p><a href="https://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="noopener">https://www.runoob.com/linux/nginx-install-setup.html</a></p><p><strong>正向代理</strong>：正向代理的对象是客户端    举例：访问Youtube挂VPN</p><p><strong>反向代理</strong>：反向代理的对象是服务器    举例：各大电商平台的服务器</p><p><strong>常用的web服务器</strong>：Apache，Nginx，Tomcat，Jetty，Netty，Jboss，iis等</p><p><strong>nginx的常用命令</strong></p><ul><li>./nginx   启动</li><li>./nginx -t  检查nginx.conf文件格式</li><li>./nginx -s stop  停止</li><li>./nginx -s reload  重启nginx</li></ul><a id="more"></a><h2 id="nginx的核心配置文件"><a href="#nginx的核心配置文件" class="headerlink" title="nginx的核心配置文件"></a>nginx的核心配置文件</h2><p>main、events、http</p><p><strong>nginx.conf</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">worker_processes  2; #工作进程数</span><br><span class="line">error_log  /usr/local/webserver/nginx/logs/nginx_error.log warn;</span><br><span class="line">worker_rlimit_nofile 10240; #最大打开文件的限制</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  10240; #不能超过上面的数字</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types; #请求头的映射关系表</span><br><span class="line">    default_type  application/octet-stream; #上面找不到的话会用这个</span><br><span class="line">    sendfile        on; #用来开启高效传输的模式</span><br><span class="line">    keepalive_timeout  65; #http连接的超时时间</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>proxy.conf</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">    listen 8080;</span><br><span class="line">    server_name  sjaylee;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://mysvr;</span><br><span class="line">        root   html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>upstream.conf</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream.conf</span><br><span class="line">upstream mysvr&#123;</span><br><span class="line">    server 10.211.55.4:8081;</span><br><span class="line">    server 10.211.55.4:8082;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="location的匹配规则"><a href="#location的匹配规则" class="headerlink" title="location的匹配规则"></a>location的匹配规则</h2><p>基础语法有三种：</p><ul><li>location pattern {}    一般匹配</li><li>location = pattern {}    精准匹配</li><li>location ~pattern {}    正则匹配</li></ul><p><strong>nginx的负载均衡和负载均衡的调度算法</strong></p><p>upstream：ip_hash、轮询(默认)、weight、fair、url_hash。</p><p>ip_hash算法是对服务器的IP地址进行hash运算来获取对应代理服务器，好处是不需要考虑session跨域。</p><p>weight算法是根据权重来合理分配各个代理服务器的调用比例。</p><h2 id="nginx日志切分"><a href="#nginx日志切分" class="headerlink" title="nginx日志切分"></a>nginx日志切分</h2><p>第一步：分析如何去实现日志切分，编写shell脚本，记得要给脚本赋予可执行权限。</p><p>第二步：启动定时任务对脚本进行调度：crontab -e</p><p>定时任务格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/1 * * * * sh /usr/<span class="built_in">local</span>/webserver/nginx/logs/access.log</span><br></pre></td></tr></table></figure><p>第三步：新增split_log.sh文件，并给其增加权限，chmod 777 文件名</p><p><strong>split_log.sh</strong></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1garbdepmokj30ik0mm4ev.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Nginx安装配置&quot;&gt;&lt;a href=&quot;#Nginx安装配置&quot; class=&quot;headerlink&quot; title=&quot;Nginx安装配置&quot;&gt;&lt;/a&gt;Nginx安装配置&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/linux/nginx-install-setup.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.runoob.com/linux/nginx-install-setup.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正向代理&lt;/strong&gt;：正向代理的对象是客户端    举例：访问Youtube挂VPN&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反向代理&lt;/strong&gt;：反向代理的对象是服务器    举例：各大电商平台的服务器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用的web服务器&lt;/strong&gt;：Apache，Nginx，Tomcat，Jetty，Netty，Jboss，iis等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx的常用命令&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;./nginx   启动&lt;/li&gt;
&lt;li&gt;./nginx -t  检查nginx.conf文件格式&lt;/li&gt;
&lt;li&gt;./nginx -s stop  停止&lt;/li&gt;
&lt;li&gt;./nginx -s reload  重启nginx&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://lishaojie1993.github.io/categories/Java/"/>
    
    
      <category term="分布式" scheme="https://lishaojie1993.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="nginx" scheme="https://lishaojie1993.github.io/tags/nginx/"/>
    
  </entry>
  
</feed>
